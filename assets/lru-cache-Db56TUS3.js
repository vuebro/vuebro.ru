import{r as C}from"./yallist-CCGksDJH.js";var S,L;function G(){if(L)return S;L=1;const T=C(),l=Symbol("max"),a=Symbol("length"),f=Symbol("lengthCalculator"),w=Symbol("allowStale"),c=Symbol("maxAge"),u=Symbol("dispose"),E=Symbol("noDisposeOnSet"),i=Symbol("lruList"),h=Symbol("cache"),d=Symbol("updateAgeOnGet"),A=()=>1;class O{constructor(t){if(typeof t=="number"&&(t={max:t}),t||(t={}),t.max&&(typeof t.max!="number"||t.max<0))throw new TypeError("max must be a non-negative number");this[l]=t.max||1/0;const e=t.length||A;if(this[f]=typeof e!="function"?A:e,this[w]=t.stale||!1,t.maxAge&&typeof t.maxAge!="number")throw new TypeError("maxAge must be a number");this[c]=t.maxAge||0,this[u]=t.dispose,this[E]=t.noDisposeOnSet||!1,this[d]=t.updateAgeOnGet||!1,this.reset()}set max(t){if(typeof t!="number"||t<0)throw new TypeError("max must be a non-negative number");this[l]=t||1/0,y(this)}get max(){return this[l]}set allowStale(t){this[w]=!!t}get allowStale(){return this[w]}set maxAge(t){if(typeof t!="number")throw new TypeError("maxAge must be a non-negative number");this[c]=t,y(this)}get maxAge(){return this[c]}set lengthCalculator(t){typeof t!="function"&&(t=A),t!==this[f]&&(this[f]=t,this[a]=0,this[i].forEach(e=>{e.length=this[f](e.value,e.key),this[a]+=e.length})),y(this)}get lengthCalculator(){return this[f]}get length(){return this[a]}get itemCount(){return this[i].length}rforEach(t,e){e=e||this;for(let r=this[i].tail;r!==null;){const n=r.prev;p(this,t,r,e),r=n}}forEach(t,e){e=e||this;for(let r=this[i].head;r!==null;){const n=r.next;p(this,t,r,e),r=n}}keys(){return this[i].toArray().map(t=>t.key)}values(){return this[i].toArray().map(t=>t.value)}reset(){this[u]&&this[i]&&this[i].length&&this[i].forEach(t=>this[u](t.key,t.value)),this[h]=new Map,this[i]=new T,this[a]=0}dump(){return this[i].map(t=>b(this,t)?!1:{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[i]}set(t,e,r){if(r=r||this[c],r&&typeof r!="number")throw new TypeError("maxAge must be a number");const n=r?Date.now():0,o=this[f](e,t);if(this[h].has(t)){if(o>this[l])return m(this,this[h].get(t)),!1;const v=this[h].get(t).value;return this[u]&&(this[E]||this[u](t,v.value)),v.now=n,v.maxAge=r,v.value=e,this[a]+=o-v.length,v.length=o,this.get(t),y(this),!0}const g=new _(t,e,o,n,r);return g.length>this[l]?(this[u]&&this[u](t,e),!1):(this[a]+=g.length,this[i].unshift(g),this[h].set(t,this[i].head),y(this),!0)}has(t){if(!this[h].has(t))return!1;const e=this[h].get(t).value;return!b(this,e)}get(t){return x(this,t,!0)}peek(t){return x(this,t,!1)}pop(){const t=this[i].tail;return t?(m(this,t),t.value):null}del(t){m(this,this[h].get(t))}load(t){this.reset();const e=Date.now();for(let r=t.length-1;r>=0;r--){const n=t[r],o=n.e||0;if(o===0)this.set(n.k,n.v);else{const g=o-e;g>0&&this.set(n.k,n.v,g)}}}prune(){this[h].forEach((t,e)=>x(this,e,!1))}}const x=(s,t,e)=>{const r=s[h].get(t);if(r){const n=r.value;if(b(s,n)){if(m(s,r),!s[w])return}else e&&(s[d]&&(r.value.now=Date.now()),s[i].unshiftNode(r));return n.value}},b=(s,t)=>{if(!t||!t.maxAge&&!s[c])return!1;const e=Date.now()-t.now;return t.maxAge?e>t.maxAge:s[c]&&e>s[c]},y=s=>{if(s[a]>s[l])for(let t=s[i].tail;s[a]>s[l]&&t!==null;){const e=t.prev;m(s,t),t=e}},m=(s,t)=>{if(t){const e=t.value;s[u]&&s[u](e.key,e.value),s[a]-=e.length,s[h].delete(e.key),s[i].removeNode(t)}};class _{constructor(t,e,r,n,o){this.key=t,this.value=e,this.length=r,this.now=n,this.maxAge=o||0}}const p=(s,t,e,r)=>{let n=e.value;b(s,n)&&(m(s,e),s[w]||(n=void 0)),n&&t.call(r,n.value,n.key,s)};return S=O,S}export{G as r};
