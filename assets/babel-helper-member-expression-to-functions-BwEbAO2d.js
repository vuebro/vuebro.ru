import{r as ie}from"./babel-types-CE9sEDWp.js";var M={},R;function re(){if(R)return M;R=1,Object.defineProperty(M,"__esModule",{value:!0});var B=ie();function k(e){if(e&&e.__esModule)return e;var i=Object.create(null);return e&&Object.keys(e).forEach(function(n){if(n!=="default"){var s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(i,n,s.get?s:{enumerable:!0,get:function(){return e[n]}})}}),i.default=e,Object.freeze(i)}var D=k(B);function _(e){const i=e,{node:n,parentPath:s}=i;if(s.isLogicalExpression()){const{operator:t,right:o}=s.node;if(t==="&&"||t==="||"||t==="??"&&n===o)return _(s)}if(s.isSequenceExpression()){const{expressions:t}=s.node;return t[t.length-1]===n?_(s):!0}return s.isConditional({test:n})||s.isUnaryExpression({operator:"!"})||s.isLoop({test:n})}const{LOGICAL_OPERATORS:$,arrowFunctionExpression:b,assignmentExpression:g,binaryExpression:h,booleanLiteral:z,callExpression:C,cloneNode:p,conditionalExpression:K,identifier:L,isMemberExpression:X,isOptionalCallExpression:H,isOptionalMemberExpression:S,isUpdateExpression:J,logicalExpression:j,memberExpression:T,nullLiteral:y,optionalCallExpression:Q,optionalMemberExpression:V,sequenceExpression:N,updateExpression:I}=D;class Y{constructor(){this._map=void 0,this._map=new WeakMap}has(i){return this._map.has(i)}get(i){if(!this.has(i))return;const n=this._map.get(i),{value:s}=n;return n.count--,n.count===0?g("=",s,i):s}set(i,n,s){return this._map.set(i,{count:s,value:n})}}function q(e,i){const{node:n}=e;if(S(n))return T(i,n.property,n.computed);if(e.isOptionalCallExpression()){const s=e.get("callee");if(e.node.optional&&s.isOptionalMemberExpression()){const t=s.node.object,o=e.scope.maybeGenerateMemoised(t);return s.get("object").replaceWith(g("=",o,t)),C(T(i,L("call")),[o,...e.node.arguments])}return C(i,e.node.arguments)}return e.node}function Z(e){for(;e&&!e.isProgram();){const{parentPath:i,container:n,listKey:s}=e,t=i.node;if(s){if(n!==t[s])return!0}else if(n!==t)return!0;e=i}return!1}const m={memoise(){},handle(e,i){const{node:n,parent:s,parentPath:t,scope:o}=e;if(e.isOptionalMemberExpression()){if(Z(e))return;const l=e.find(({node:r,parent:c})=>S(c)?c.optional||c.object!==r:H(c)?r!==e.node&&c.optional||c.callee!==r:!0);if(o.path.isPattern()){l.replaceWith(C(b([],l.node),[]));return}const E=_(l),u=l.parentPath;if(u.isUpdateExpression({argument:n}))throw e.buildCodeFrameError("can't handle update expression");const x=u.isAssignmentExpression({left:l.node}),d=u.isUnaryExpression({operator:"delete"});if(d&&l.isOptionalMemberExpression()&&l.get("property").isPrivateName())throw e.buildCodeFrameError("can't delete a private class element");let a=e;for(;;){if(a.isOptionalMemberExpression()){if(a.node.optional)break;a=a.get("object");continue}else if(a.isOptionalCallExpression()){if(a.node.optional)break;a=a.get("callee");continue}throw new Error(`Internal error: unexpected ${a.node.type}`)}const w=a.isOptionalMemberExpression()?a.node.object:a.node.callee,A=o.maybeGenerateMemoised(w),O=A??w,te=t.isOptionalCallExpression({callee:n}),F=r=>te,ne=t.isCallExpression({callee:n});a.replaceWith(q(a,O)),F()?s.optional?t.replaceWith(this.optionalCall(e,s.arguments)):t.replaceWith(this.call(e,s.arguments)):ne?e.replaceWith(this.boundGet(e)):this.delete&&t.isUnaryExpression({operator:"delete"})?t.replaceWith(this.delete(e)):t.isAssignmentExpression()?G(this,e,t):e.replaceWith(this.get(e));let f=e.node;for(let r=e;r!==l;){const c=r.parentPath;if(c===l&&F()&&s.optional){f=c.node;break}f=q(c,f),r=c}let P;const W=l.parentPath;if(X(f)&&W.isOptionalCallExpression({callee:l.node,optional:!0})){const{object:r}=f;P=e.scope.maybeGenerateMemoised(r),P&&(f.object=g("=",P,r))}let U=l;(d||x)&&(U=W,f=W.node);const v=A?g("=",p(O),p(w)):p(O);if(E){let r;i?r=h("!=",v,y()):r=j("&&",h("!==",v,y()),h("!==",p(O),o.buildUndefinedNode())),U.replaceWith(j("&&",r,f))}else{let r;i?r=h("==",v,y()):r=j("||",h("===",v,y()),h("===",p(O),o.buildUndefinedNode())),U.replaceWith(K(r,d?z(!0):o.buildUndefinedNode(),f))}if(P){const r=W.node;W.replaceWith(Q(V(r.callee,L("call"),!1,!0),[p(P),...r.arguments],!1))}return}if(J(s,{argument:n})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:l,prefix:E}=s;this.memoise(e,2);const u=o.generateUidIdentifierBasedOnNode(n);o.push({id:u});const x=[g("=",p(u),this.get(e))];if(E){x.push(I(l,p(u),E));const d=N(x);t.replaceWith(this.set(e,d));return}else{const d=o.generateUidIdentifierBasedOnNode(n);o.push({id:d}),x.push(g("=",p(d),I(l,p(u),E)),p(u));const a=N(x);t.replaceWith(N([this.set(e,a),p(d)]));return}}if(t.isAssignmentExpression({left:n})){G(this,e,t);return}if(t.isCallExpression({callee:n})){t.replaceWith(this.call(e,t.node.arguments));return}if(t.isOptionalCallExpression({callee:n})){if(o.path.isPattern()){t.replaceWith(C(b([],t.node),[]));return}t.replaceWith(this.optionalCall(e,t.node.arguments));return}if(this.delete&&t.isUnaryExpression({operator:"delete"})){t.replaceWith(this.delete(e));return}if(t.isForXStatement({left:n})||t.isObjectProperty({value:n})&&t.parentPath.isObjectPattern()||t.isAssignmentPattern({left:n})&&t.parentPath.isObjectProperty({value:s})&&t.parentPath.parentPath.isObjectPattern()||t.isArrayPattern()||t.isAssignmentPattern({left:n})&&t.parentPath.isArrayPattern()||t.isRestElement()){e.replaceWith(this.destructureSet(e));return}t.isTaggedTemplateExpression()?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e))}};function G(e,i,n){if(e.simpleSet){i.replaceWith(e.simpleSet(i));return}const{operator:s,right:t}=n.node;if(s==="=")n.replaceWith(e.set(i,t));else{const o=s.slice(0,-1);$.includes(o)?(e.memoise(i,1),n.replaceWith(j(o,e.get(i),e.set(i,t)))):(e.memoise(i,2),n.replaceWith(e.set(i,h(o,e.get(i),t))))}}function ee(e,i,n){e.traverse(i,Object.assign({},m,n,{memoiser:new Y}))}return M.default=ee,M}export{re as r};
