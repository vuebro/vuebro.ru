import{r as se}from"./assert-DVti1A0a.js";import{r as h}from"./babel-core-Bs32w3bm.js";import{r as ie}from"./babel-helper-module-imports-DoEuVeLX.js";import{r as ee}from"./babel-traverse-CY8MFp_n.js";import{r as ae}from"./path-browserify-DQtFYpBN.js";import{r as le}from"./babel-helper-validator-identifier-D_Npcg8R.js";var X={},z={},W;function ue(){if(W)return z;W=1,Object.defineProperty(z,"__esModule",{value:!0}),z.default=D;var t=h(),P=ee();let u;function D(y){u||(u=P.visitors.environmentVisitor({ThisExpression(w){w.replaceWith(t.types.unaryExpression("void",t.types.numericLiteral(0),!0))}}),u.noScope=!0),(0,P.default)(y.node,u)}return z}var F={},U;function ce(){if(U)return F;U=1,Object.defineProperty(F,"__esModule",{value:!0}),F.default=u;var t=h();function P(e){do switch(e.parent.type){case"TSTypeAnnotation":case"TSTypeAliasDeclaration":case"TSTypeReference":case"TypeAnnotation":case"TypeAlias":return!0;case"ExportSpecifier":return e.parentPath.parent.exportKind==="type";default:if(e.parentPath.isStatement()||e.parentPath.isExpression())return!1}while(e=e.parentPath)}function u(e,E,_){const x=new Map,A=new Map,N=l=>{e.requeue(l)};for(const[l,d]of E.source){for(const[f,m]of d.imports)x.set(f,[l,m,null]);for(const f of d.importsNamespace)x.set(f,[l,null,f])}for(const[l,d]of E.local){let f=A.get(l);f||(f=[],A.set(l,f)),f.push(...d.names)}const i={metadata:E,requeueInParent:N,scope:e.scope,exported:A};e.traverse(D,i);const s={seen:new WeakSet,metadata:E,requeueInParent:N,scope:e.scope,imported:x,exported:A,buildImportReference([l,d,f],m){const o=E.source.get(l);if(o.referenced=!0,f){if(o.wrap){var p;m=(p=_(m,o.wrap))!=null?p:m}return m}let v=t.types.identifier(o.name);if(o.wrap){var r;v=(r=_(v,o.wrap))!=null?r:v}if(d==="default"&&o.interop==="node-default")return v;const n=E.stringSpecifiers.has(d);return t.types.memberExpression(v,n?t.types.stringLiteral(d):t.types.identifier(d),n)}};e.traverse(M,s)}const D={Scope(e){e.skip()},ClassDeclaration(e){const{requeueInParent:E,exported:_,metadata:x}=this,{id:A}=e.node;if(!A)throw new Error("Expected class to have a name");const N=A.name,i=_.get(N)||[];if(i.length>0){const s=t.types.expressionStatement(y(x,i,t.types.identifier(N),e.scope));s._blockHoist=e.node._blockHoist,E(e.insertAfter(s)[0])}},VariableDeclaration(e){const{requeueInParent:E,exported:_,metadata:x}=this,A=e.node.kind==="var";for(const N of e.get("declarations")){const{id:i}=N.node;let{init:s}=N.node;if(t.types.isIdentifier(i)&&_.has(i.name)&&!t.types.isArrowFunctionExpression(s)&&(!t.types.isFunctionExpression(s)||s.id)&&(!t.types.isClassExpression(s)||s.id)){if(!s){if(A)continue;s=e.scope.buildUndefinedNode()}N.node.init=y(x,_.get(i.name),s,e.scope),E(N.get("init"))}else for(const l of Object.keys(N.getOuterBindingIdentifiers()))if(_.has(l)){const d=t.types.expressionStatement(y(x,_.get(l),t.types.identifier(l),e.scope));d._blockHoist=e.node._blockHoist,E(e.insertAfter(d)[0])}}}},y=(e,E,_,x)=>{const A=e.exportName;for(let N=x;N!=null;N=N.parent)N.hasOwnBinding(A)&&N.rename(A);return(E||[]).reduce((N,i)=>{const{stringSpecifiers:s}=e,l=s.has(i);return t.types.assignmentExpression("=",t.types.memberExpression(t.types.identifier(A),l?t.types.stringLiteral(i):t.types.identifier(i),l),N)},_)},w=e=>t.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `,M={ReferencedIdentifier(e){const{seen:E,buildImportReference:_,scope:x,imported:A,requeueInParent:N}=this;if(E.has(e.node))return;E.add(e.node);const i=e.node.name,s=A.get(i);if(s){if(P(e))throw e.buildCodeFrameError(`Cannot transform the imported binding "${i}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);const l=e.scope.getBinding(i);if(x.getBinding(i)!==l)return;const f=_(s,e.node);if(f.loc=e.node.loc,(e.parentPath.isCallExpression({callee:e.node})||e.parentPath.isOptionalCallExpression({callee:e.node})||e.parentPath.isTaggedTemplateExpression({tag:e.node}))&&t.types.isMemberExpression(f))e.replaceWith(t.types.sequenceExpression([t.types.numericLiteral(0),f]));else if(e.isJSXIdentifier()&&t.types.isMemberExpression(f)){const{object:m,property:o}=f;e.replaceWith(t.types.jsxMemberExpression(t.types.jsxIdentifier(m.name),t.types.jsxIdentifier(o.name)))}else e.replaceWith(f);N(e),e.skip()}},UpdateExpression(e){const{scope:E,seen:_,imported:x,exported:A,requeueInParent:N,buildImportReference:i}=this;if(_.has(e.node))return;_.add(e.node);const s=e.get("argument");if(s.isMemberExpression())return;const l=e.node;if(s.isIdentifier()){const d=s.node.name;if(E.getBinding(d)!==e.scope.getBinding(d))return;const f=A.get(d),m=x.get(d);if((f==null?void 0:f.length)>0||m)if(m)e.replaceWith(t.types.assignmentExpression(l.operator[0]+"=",i(m,s.node),w(d)));else if(l.prefix)e.replaceWith(y(this.metadata,f,t.types.cloneNode(l),e.scope));else{const o=E.generateDeclaredUidIdentifier(d);e.replaceWith(t.types.sequenceExpression([t.types.assignmentExpression("=",t.types.cloneNode(o),t.types.cloneNode(l)),y(this.metadata,f,t.types.identifier(d),e.scope),t.types.cloneNode(o)]))}}N(e),e.skip()},AssignmentExpression:{exit(e){const{scope:E,seen:_,imported:x,exported:A,requeueInParent:N,buildImportReference:i}=this;if(_.has(e.node))return;_.add(e.node);const s=e.get("left");if(!s.isMemberExpression())if(s.isIdentifier()){const l=s.node.name;if(E.getBinding(l)!==e.scope.getBinding(l))return;const d=A.get(l),f=x.get(l);if((d==null?void 0:d.length)>0||f){const m=e.node;f&&(m.left=i(f,s.node),m.right=t.types.sequenceExpression([m.right,w(l)]));const{operator:o}=m;let p;o==="="?p=m:o==="&&="||o==="||="||o==="??="?p=t.types.assignmentExpression("=",m.left,t.types.logicalExpression(o.slice(0,-1),t.types.cloneNode(m.left),m.right)):p=t.types.assignmentExpression("=",m.left,t.types.binaryExpression(o.slice(0,-1),t.types.cloneNode(m.left),m.right)),e.replaceWith(y(this.metadata,d,p,e.scope)),N(e),e.skip()}}else{const l=s.getOuterBindingIdentifiers(),d=Object.keys(l).filter(o=>E.getBinding(o)===e.scope.getBinding(o)),f=d.find(o=>x.has(o));f&&(e.node.right=t.types.sequenceExpression([e.node.right,w(f)]));const m=[];if(d.forEach(o=>{const p=A.get(o)||[];p.length>0&&m.push(y(this.metadata,p,t.types.identifier(o),e.scope))}),m.length>0){let o=t.types.sequenceExpression(m);e.parentPath.isExpressionStatement()&&(o=t.types.expressionStatement(o),o._blockHoist=e.parentPath.node._blockHoist);const p=e.insertAfter(o)[0];N(p)}}}},ForXStatement(e){const{scope:E,node:_}=e,{left:x}=_,{exported:A,imported:N,scope:i}=this;if(!t.types.isVariableDeclaration(x)){let s=!1,l;const d=e.get("body").scope;for(const o of Object.keys(t.types.getOuterBindingIdentifiers(x)))i.getBinding(o)===E.getBinding(o)&&(A.has(o)&&(s=!0,d.hasOwnBinding(o)&&d.rename(o)),N.has(o)&&!l&&(l=o));if(!s&&!l)return;e.ensureBlock();const f=e.get("body"),m=E.generateUidIdentifierBasedOnNode(x);e.get("left").replaceWith(t.types.variableDeclaration("let",[t.types.variableDeclarator(t.types.cloneNode(m))])),E.registerDeclaration(e.get("left")),s&&f.unshiftContainer("body",t.types.expressionStatement(t.types.assignmentExpression("=",x,m))),l&&f.unshiftContainer("body",t.types.expressionStatement(w(l)))}}};return F}var T={},G;function te(){if(G)return T;G=1,Object.defineProperty(T,"__esModule",{value:!0}),T.default=M,T.hasExports=u,T.isSideEffectImport=D,T.validateImportInteropOption=y;var t=ae(),P=le();function u(i){return i.hasExports}function D(i){return i.imports.size===0&&i.importsNamespace.size===0&&i.reexports.size===0&&i.reexportNamespace.size===0&&!i.reexportAll}function y(i){if(typeof i!="function"&&i!=="none"&&i!=="babel"&&i!=="node")throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${i}).`);return i}function w(i,s,l){return typeof i=="function"?y(i(s,l)):i}function M(i,s,{importInterop:l,initializeReexports:d=!1,getWrapperPayload:f,esNamespaceOnly:m=!1,filename:o}){s||(s=i.scope.generateUidIdentifier("exports").name);const p=new Set;A(i);const{local:v,sources:r,hasExports:n}=_(i,{initializeReexports:d,getWrapperPayload:f},p);N(i);for(const[a,c]of r){const{importsNamespace:S,imports:g}=c;if(S.size>0&&g.size===0){const[R]=S;c.name=R}const I=w(l,a,o);I==="none"?c.interop="none":I==="node"&&c.interop==="namespace"?c.interop="node-namespace":I==="node"&&c.interop==="default"?c.interop="node-default":m&&c.interop==="namespace"&&(c.interop="default")}return{exportName:s,exportNameListName:null,hasExports:n,local:v,source:r,stringSpecifiers:p}}function e(i,s){if(i.isIdentifier())return i.node.name;if(i.isStringLiteral()){const l=i.node.value;return(0,P.isIdentifierName)(l)||s.add(l),l}else throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${i.node.type}`)}function E(i){if(!i.isExportSpecifier())throw i.isExportNamespaceSpecifier()?i.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`."):i.buildCodeFrameError("Unexpected export specifier type")}function _(i,{getWrapperPayload:s,initializeReexports:l},d){const f=x(i,l,d),m=new Map,o=new Map,p=(r,n)=>{const a=r.value;let c=o.get(a);return c?m.get(a).push(n):(c={name:i.scope.generateUidIdentifier((0,t.basename)(a,(0,t.extname)(a))).name,interop:"none",loc:null,imports:new Map,importsNamespace:new Set,reexports:new Map,reexportNamespace:new Set,reexportAll:null,wrap:null,get lazy(){return this.wrap==="lazy"},referenced:!1},o.set(a,c),m.set(a,[n])),c};let v=!1;i.get("body").forEach(r=>{if(r.isImportDeclaration()){const n=p(r.node.source,r.node);n.loc||(n.loc=r.node.loc),r.get("specifiers").forEach(a=>{if(a.isImportDefaultSpecifier()){const c=a.get("local").node.name;n.imports.set(c,"default");const S=f.get(c);S&&(f.delete(c),S.names.forEach(g=>{n.reexports.set(g,"default")}),n.referenced=!0)}else if(a.isImportNamespaceSpecifier()){const c=a.get("local").node.name;n.importsNamespace.add(c);const S=f.get(c);S&&(f.delete(c),S.names.forEach(g=>{n.reexportNamespace.add(g)}),n.referenced=!0)}else if(a.isImportSpecifier()){const c=e(a.get("imported"),d),S=a.get("local").node.name;n.imports.set(S,c);const g=f.get(S);g&&(f.delete(S),g.names.forEach(I=>{n.reexports.set(I,c)}),n.referenced=!0)}})}else if(r.isExportAllDeclaration()){v=!0;const n=p(r.node.source,r.node);n.loc||(n.loc=r.node.loc),n.reexportAll={loc:r.node.loc},n.referenced=!0}else if(r.isExportNamedDeclaration()&&r.node.source){v=!0;const n=p(r.node.source,r.node);n.loc||(n.loc=r.node.loc),r.get("specifiers").forEach(a=>{E(a);const c=e(a.get("local"),d),S=e(a.get("exported"),d);if(n.reexports.set(S,c),n.referenced=!0,S==="__esModule")throw a.get("exported").buildCodeFrameError('Illegal export "__esModule".')})}else(r.isExportNamedDeclaration()||r.isExportDefaultDeclaration())&&(v=!0)});for(const r of o.values()){let n=!1,a=!1;r.importsNamespace.size>0&&(n=!0,a=!0),r.reexportAll&&(a=!0);for(const c of r.imports.values())c==="default"?n=!0:a=!0;for(const c of r.reexports.values())c==="default"?n=!0:a=!0;n&&a?r.interop="namespace":n&&(r.interop="default")}if(s)for(const[r,n]of o)n.wrap=s(r,n,m.get(r));return{hasExports:v,local:f,sources:o}}function x(i,s,l){const d=new Map;i.get("body").forEach(o=>{let p;if(o.isImportDeclaration())p="import";else{if(o.isExportDefaultDeclaration()&&(o=o.get("declaration")),o.isExportNamedDeclaration()){if(o.node.declaration)o=o.get("declaration");else if(s&&o.node.source&&o.get("source").isStringLiteral()){o.get("specifiers").forEach(v=>{E(v),d.set(v.get("local").node.name,"block")});return}}if(o.isFunctionDeclaration())p="hoisted";else if(o.isClassDeclaration())p="block";else if(o.isVariableDeclaration({kind:"var"}))p="var";else if(o.isVariableDeclaration())p="block";else return}Object.keys(o.getOuterBindingIdentifiers()).forEach(v=>{d.set(v,p)})});const f=new Map,m=o=>{const p=o.node.name;let v=f.get(p);if(!v){const r=d.get(p);if(r===void 0)throw o.buildCodeFrameError(`Exporting local "${p}", which is not declared.`);v={names:[],kind:r},f.set(p,v)}return v};return i.get("body").forEach(o=>{if(o.isExportNamedDeclaration()&&(s||!o.node.source))if(o.node.declaration){const p=o.get("declaration"),v=p.getOuterBindingIdentifierPaths();Object.keys(v).forEach(r=>{if(r==="__esModule")throw p.buildCodeFrameError('Illegal export "__esModule".');m(v[r]).names.push(r)})}else o.get("specifiers").forEach(p=>{const v=p.get("local"),r=p.get("exported"),n=m(v),a=e(r,l);if(a==="__esModule")throw r.buildCodeFrameError('Illegal export "__esModule".');n.names.push(a)});else if(o.isExportDefaultDeclaration()){const p=o.get("declaration");if(p.isFunctionDeclaration()||p.isClassDeclaration())m(p.get("id")).names.push("default");else throw p.buildCodeFrameError("Unexpected default expression export.")}}),f}function A(i){i.get("body").forEach(s=>{if(s.isExportDefaultDeclaration()){{var l;(l=s.splitExportDeclaration)!=null||(s.splitExportDeclaration=ee().NodePath.prototype.splitExportDeclaration)}s.splitExportDeclaration()}})}function N(i){i.get("body").forEach(s=>{if(s.isImportDeclaration())s.remove();else if(s.isExportNamedDeclaration())s.node.declaration?(s.node.declaration._blockHoist=s.node._blockHoist,s.replaceWith(s.node.declaration)):s.remove();else if(s.isExportDefaultDeclaration()){const l=s.get("declaration");if(l.isFunctionDeclaration()||l.isClassDeclaration())l._blockHoist=s.node._blockHoist,s.replaceWith(l);else throw l.buildCodeFrameError("Unexpected default expression export.")}else s.isExportAllDeclaration()&&s.remove()})}return T}var C={},Y;function fe(){if(Y)return C;Y=1,Object.defineProperty(C,"__esModule",{value:!0}),C.toGetWrapperPayload=u,C.wrapReference=D;var t=h(),P=te();function u(y){return(w,M)=>{if(y===!1||(0,P.isSideEffectImport)(M)||M.reexportAll)return null;if(y===!0)return w.includes(".")?null:"lazy";if(Array.isArray(y))return y.includes(w)?"lazy":null;if(typeof y=="function")return y(w)?"lazy":null;throw new Error(".lazy must be a boolean, string array, or function")}}function D(y,w){return w==="lazy"?t.types.callExpression(y,[]):null}return C}var q={},K;function J(){if(K)return q;K=1,Object.defineProperty(q,"__esModule",{value:!0}),q.buildDynamicImport=P;var t=h();q.getDynamicImportSource=function(D){const[y]=D.arguments;return t.types.isStringLiteral(y)||t.types.isTemplateLiteral(y)?y:t.template.expression.ast`\`\${${y}}\``};function P(u,D,y,w){const M=t.types.isCallExpression(u)?u.arguments[0]:u.source;if(t.types.isStringLiteral(M)||t.types.isTemplateLiteral(M)&&M.quasis.length===0)return D?t.template.expression.ast`
        Promise.resolve().then(() => ${w(M)})
      `:w(M);const e=t.types.isTemplateLiteral(M)?t.types.identifier("specifier"):t.types.templateLiteral([t.types.templateElement({raw:""}),t.types.templateElement({raw:""})],[t.types.identifier("specifier")]);return D?t.template.expression.ast`
      (specifier =>
        new Promise(r => r(${e}))
          .then(s => ${w(t.types.identifier("s"))})
      )(${M})
    `:y?t.template.expression.ast`
      (specifier =>
        new Promise(r => r(${w(e)}))
      )(${M})
    `:t.template.expression.ast`
      (specifier => ${w(e)})(${M})
    `}return q}var j={},Q;function pe(){if(Q)return j;Q=1,Object.defineProperty(j,"__esModule",{value:!0}),j.default=t;{const P=t;j.default=t=function(D,y){var w,M,e,E;return P(D,{moduleId:(w=y.moduleId)!=null?w:D.moduleId,moduleIds:(M=y.moduleIds)!=null?M:D.moduleIds,getModuleId:(e=y.getModuleId)!=null?e:D.getModuleId,moduleRoot:(E=y.moduleRoot)!=null?E:D.moduleRoot})}}function t(P,u){const{filename:D,filenameRelative:y=D,sourceRoot:w=u.moduleRoot}=P,{moduleId:M,moduleIds:e=!!M,getModuleId:E,moduleRoot:_=w}=u;if(!e)return null;if(M!=null&&!E)return M;let x=_!=null?_+"/":"";if(y){const A=w!=null?new RegExp("^"+w+"/?"):"";x+=y.replace(A,"").replace(/\.\w*$/,"")}return x=x.replace(/\\/g,"/"),E&&E(x)||x}return j}var Z;function Ne(){return Z||(Z=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"buildDynamicImport",{enumerable:!0,get:function(){return E.buildDynamicImport}}),t.buildNamespaceInitStatements=i,t.ensureStatementsHoisted=A,Object.defineProperty(t,"getModuleName",{enumerable:!0,get:function(){return _.default}}),Object.defineProperty(t,"hasExports",{enumerable:!0,get:function(){return M.hasExports}}),Object.defineProperty(t,"isModule",{enumerable:!0,get:function(){return D.isModule}}),Object.defineProperty(t,"isSideEffectImport",{enumerable:!0,get:function(){return M.isSideEffectImport}}),t.rewriteModuleStatementsAndPrepareHeader=x,Object.defineProperty(t,"rewriteThis",{enumerable:!0,get:function(){return y.default}}),t.wrapInterop=N;var P=se(),u=h(),D=ie(),y=ue(),w=ce(),M=te(),e=fe(),E=J(),_=pe();t.getDynamicImportSource=J().getDynamicImportSource;function x(r,{exportName:n,strict:a,allowTopLevelThis:c,strictMode:S,noInterop:g,importInterop:I=g?"none":"babel",lazy:R,getWrapperPayload:b=e.toGetWrapperPayload(R??!1),wrapReference:k=e.wrapReference,esNamespaceOnly:O,filename:H,constantReexports:$=arguments[1].loose,enumerableModuleMeta:re=arguments[1].loose,noIncompleteNsImportDetection:ne}){(0,M.validateImportInteropOption)(I),P((0,D.isModule)(r),"Cannot process module statements in a script"),r.node.sourceType="script";const L=(0,M.default)(r,n,{importInterop:I,initializeReexports:$,getWrapperPayload:b,esNamespaceOnly:O,filename:H});c||(0,y.default)(r),(0,w.default)(r,L,k),S!==!1&&(r.node.directives.some(oe=>oe.value.value==="use strict")||r.unshiftContainer("directives",u.types.directive(u.types.directiveLiteral("use strict"))));const B=[];(0,M.hasExports)(L)&&!a&&B.push(d(L,re));const V=m(r,L);return V&&(L.exportNameListName=V.name,B.push(V.statement)),B.push(...o(r,L,k,$,ne)),{meta:L,headers:B}}function A(r){r.forEach(n=>{n._blockHoist=3})}function N(r,n,a){if(a==="none")return null;if(a==="node-namespace")return u.types.callExpression(r.hub.addHelper("interopRequireWildcard"),[n,u.types.booleanLiteral(!0)]);if(a==="node-default")return null;let c;if(a==="default")c="interopRequireDefault";else if(a==="namespace")c="interopRequireWildcard";else throw new Error(`Unknown interop: ${a}`);return u.types.callExpression(r.hub.addHelper(c),[n])}function i(r,n,a=!1,c=e.wrapReference){var S;const g=[],I=u.types.identifier(n.name);for(const b of n.importsNamespace)b!==n.name&&g.push(u.template.statement`var NAME = SOURCE;`({NAME:b,SOURCE:u.types.cloneNode(I)}));const R=(S=c(I,n.wrap))!=null?S:I;a&&g.push(...l(r,n,!0,c));for(const b of n.reexportNamespace)g.push((u.types.isIdentifier(R)?u.template.statement`EXPORTS.NAME = NAMESPACE;`:u.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({EXPORTS:r.exportName,NAME:b,NAMESPACE:u.types.cloneNode(R)}));if(n.reexportAll){const b=f(r,u.types.cloneNode(R),a);b.loc=n.reexportAll.loc,g.push(b)}return g}const s={constant:({exports:r,exportName:n,namespaceImport:a})=>u.template.statement.ast`
      ${r}.${n} = ${a};
    `,constantComputed:({exports:r,exportName:n,namespaceImport:a})=>u.template.statement.ast`
      ${r}["${n}"] = ${a};
    `,spec:({exports:r,exportName:n,namespaceImport:a})=>u.template.statement.ast`
      Object.defineProperty(${r}, "${n}", {
        enumerable: true,
        get: function() {
          return ${a};
        },
      });
    `};function l(r,n,a,c){var S;let g=u.types.identifier(n.name);g=(S=c(g,n.wrap))!=null?S:g;const{stringSpecifiers:I}=r;return Array.from(n.reexports,([R,b])=>{let k=u.types.cloneNode(g);b==="default"&&n.interop==="node-default"||(I.has(b)?k=u.types.memberExpression(k,u.types.stringLiteral(b),!0):k=u.types.memberExpression(k,u.types.identifier(b)));const O={exports:r.exportName,exportName:R,namespaceImport:k};return a||u.types.isIdentifier(k)?I.has(R)?s.constantComputed(O):s.constant(O):s.spec(O)})}function d(r,n=!1){return(n?u.template.statement`
        EXPORTS.__esModule = true;
      `:u.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({EXPORTS:r.exportName})}function f(r,n,a){return(a?u.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `:u.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({NAMESPACE:n,EXPORTS:r.exportName,VERIFY_NAME_LIST:r.exportNameListName?(0,u.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({EXPORTS_LIST:r.exportNameListName}):null})}function m(r,n){const a=Object.create(null);for(const g of n.local.values())for(const I of g.names)a[I]=!0;let c=!1;for(const g of n.source.values()){for(const I of g.reexports.keys())a[I]=!0;for(const I of g.reexportNamespace)a[I]=!0;c=c||!!g.reexportAll}if(!c||Object.keys(a).length===0)return null;const S=r.scope.generateUidIdentifier("exportNames");return delete a.default,{name:S.name,statement:u.types.variableDeclaration("var",[u.types.variableDeclarator(S,u.types.valueToNode(a))])}}function o(r,n,a,c=!1,S=!1){const g=[];for(const[R,b]of n.local)if(b.kind!=="import"){if(b.kind==="hoisted")g.push([b.names[0],v(n,b.names,u.types.identifier(R))]);else if(!S)for(const k of b.names)g.push([k,null])}for(const R of n.source.values()){if(!c){const b=l(n,R,!1,a),k=[...R.reexports.keys()];for(let O=0;O<b.length;O++)g.push([k[O],b[O]])}if(!S)for(const b of R.reexportNamespace)g.push([b,null])}g.sort(([R],[b])=>R<b?-1:b<R?1:0);const I=[];if(S)for(const[,R]of g)I.push(R);else for(let b=0;b<g.length;b+=100){let k=[];for(let O=0;O<100&&b+O<g.length;O++){const[H,$]=g[b+O];$!==null?(k.length>0&&(I.push(v(n,k,r.scope.buildUndefinedNode())),k=[]),I.push($)):k.push(H)}k.length>0&&I.push(v(n,k,r.scope.buildUndefinedNode()))}return I}const p={computed:({exports:r,name:n,value:a})=>u.template.expression.ast`${r}["${n}"] = ${a}`,default:({exports:r,name:n,value:a})=>u.template.expression.ast`${r}.${n} = ${a}`,define:({exports:r,name:n,value:a})=>u.template.expression.ast`
      Object.defineProperty(${r}, "${n}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${n}"] = ${a}`};function v(r,n,a){const{stringSpecifiers:c,exportName:S}=r;return u.types.expressionStatement(n.reduce((g,I)=>{const R={exports:S,name:I,value:g};return I==="__proto__"?p.define(R):c.has(I)?p.computed(R):p.default(R)},a))}}(X)),X}export{Ne as r};
