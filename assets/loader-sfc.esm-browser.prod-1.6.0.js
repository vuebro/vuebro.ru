import { onMounted as ET, nextTick as wT, getCurrentScope as _T, onScopeDispose as PT, getCurrentInstance as AT, shallowRef as i1, readonly as CT, watch as IT } from "vue";
/**
* @vue/compiler-sfc v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function kt(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const s of e.split(",")) t[s] = 1;
  return (s) => s in t;
}
const NT = Object.freeze({}), ac = () => {
}, Dn = () => !1, Dg = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), kr = Object.assign, OT = Object.prototype.hasOwnProperty, Bp = (e, t) => OT.call(e, t), gt = Array.isArray, Fg = (e) => typeof e == "function", De = (e) => typeof e == "string", rs = (e) => typeof e == "symbol", ss = (e) => e !== null && typeof e == "object", jg = Object.prototype.toString, ql = (e) => jg.call(e), Bg = (e) => ql(e) === "[object Object]", o1 = kt(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Up = kt("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), ia = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (s) => t[s] || (t[s] = e(s));
}, LT = /-\w/g, Dt = ia((e) => e.replace(LT, (t) => t.slice(1).toUpperCase())), RT = /\B([A-Z])/g, MT = ia((e) => e.replace(RT, "-$1").toLowerCase()), Yr = ia((e) => e.charAt(0).toUpperCase() + e.slice(1)), DT = ia((e) => e ? `on${Yr(e)}` : ""), FT = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function So(e) {
  return FT.test(e) ? `__props.${e}` : `__props[${JSON.stringify(e)}]`;
}
const jn = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "NEED_HYDRATION", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "CACHED", [-2]: "BAIL" }, jT = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, a1 = kt("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
function mi(e, t = 0, s = e.length) {
  if ((t = Math.max(0, Math.min(t, e.length))) > (s = Math.max(0, Math.min(s, e.length)))) return "";
  let n = e.split(/(\r?\n)/);
  const i = n.filter((l, p) => p % 2 == 1);
  n = n.filter((l, p) => p % 2 == 0);
  let o = 0;
  const c = [];
  for (let l = 0; l < n.length; l++) if (o += n[l].length + (i[l] && i[l].length || 0), o >= t) {
    for (let p = l - 2; p <= l + 2 || s > o; p++) {
      if (p < 0 || p >= n.length) continue;
      const d = p + 1;
      c.push(`${d}${" ".repeat(Math.max(3 - String(d).length, 0))}|  ${n[p]}`);
      const g = n[p].length, f = i[p] && i[p].length || 0;
      if (p === l) {
        const x = t - (o - (g + f)), m = Math.max(1, s > o ? g - x : s - t);
        c.push("   |  " + " ".repeat(x) + "^".repeat(m));
      } else if (p > l) {
        if (s > o) {
          const x = Math.max(Math.min(s - o, g), 1);
          c.push("   |  " + "^".repeat(x));
        }
        o += g + f;
      }
    }
    break;
  }
  return c.join(`
`);
}
function Ug(e) {
  if (gt(e)) {
    const t = {};
    for (let s = 0; s < e.length; s++) {
      const n = e[s], i = De(n) ? $g(n) : Ug(n);
      if (i) for (const o in i) t[o] = i[o];
    }
    return t;
  }
  if (De(e) || ss(e)) return e;
}
const BT = /;(?![^(]*\))/g, UT = /:([^]+)/, $T = /\/\*[^]*?\*\//g;
function $g(e) {
  const t = {};
  return e.replace($T, "").split(BT).forEach((s) => {
    if (s) {
      const n = s.split(UT);
      n.length > 1 && (t[n[0].trim()] = n[1].trim());
    }
  }), t;
}
function qT(e) {
  if (!e) return "";
  if (De(e)) return e;
  let t = "";
  for (const s in e) {
    const n = e[s];
    (De(n) || typeof n == "number") && (t += `${s.startsWith("--") ? s : MT(s)}:${n};`);
  }
  return t;
}
function qg(e) {
  let t = "";
  if (De(e)) t = e;
  else if (gt(e)) for (let s = 0; s < e.length; s++) {
    const n = qg(e[s]);
    n && (t += n + " ");
  }
  else if (ss(e)) for (const s in e) e[s] && (t += s + " ");
  return t.trim();
}
const VT = kt("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), HT = kt("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), zT = kt("annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics"), Vg = kt("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), Hg = kt("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), WT = /[>/="'\u0009\u000a\u000c\u0020]/, cc = {};
function GT(e) {
  if (cc.hasOwnProperty(e)) return cc[e];
  const t = WT.test(e);
  return t && console.error(`unsafe attribute name: ${e}`), cc[e] = !t;
}
const XT = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, KT = kt("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"), JT = kt("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"), YT = kt("accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns"), QT = /["'&<>]/;
function ur(e) {
  const t = "" + e, s = QT.exec(t);
  if (!s) return t;
  let n, i, o = "", c = 0;
  for (i = s.index; i < t.length; i++) {
    switch (t.charCodeAt(i)) {
      case 34:
        n = "&quot;";
        break;
      case 38:
        n = "&amp;";
        break;
      case 39:
        n = "&#39;";
        break;
      case 60:
        n = "&lt;";
        break;
      case 62:
        n = "&gt;";
        break;
      default:
        continue;
    }
    c !== i && (o += t.slice(c, i)), c = i + 1, o += n;
  }
  return c !== i ? o + t.slice(c, i) : o;
}
const ZT = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g, zg = (e) => !(!e || e.__v_isRef !== !0), Eo = (e) => De(e) ? e : e == null ? "" : gt(e) || ss(e) && (e.toString === jg || !Fg(e.toString)) ? zg(e) ? Eo(e.value) : JSON.stringify(e, Wg, 2) : String(e), Wg = (e, t) => zg(t) ? Wg(e, t.value) : ((s) => ql(s) === "[object Map]")(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((s, [n, i], o) => (s[lc(n, o) + " =>"] = i, s), {}) } : ((s) => ql(s) === "[object Set]")(t) ? { [`Set(${t.size})`]: [...t.values()].map((s) => lc(s)) } : rs(t) ? lc(t) : !ss(t) || gt(t) || Bg(t) ? t : String(t), lc = (e, t = "") => {
  var s;
  return rs(e) ? `Symbol(${(s = e.description) != null ? s : t})` : e;
}, rn = Symbol("Fragment"), Ts = Symbol("Teleport"), dn = Symbol("Suspense"), Qn = Symbol("KeepAlive"), $p = Symbol("BaseTransition"), Qr = Symbol("openBlock"), qp = Symbol("createBlock"), Vp = Symbol("createElementBlock"), gi = Symbol("createVNode"), oa = Symbol("createElementVNode"), fn = Symbol("createCommentVNode"), aa = Symbol("createTextVNode"), ca = Symbol("createStaticVNode"), Zn = Symbol("resolveComponent"), yi = Symbol("resolveDynamicComponent"), la = Symbol("resolveDirective"), Gg = Symbol("resolveFilter"), pa = Symbol("withDirectives"), ha = Symbol("renderList"), Hp = Symbol("renderSlot"), zp = Symbol("createSlots"), xi = Symbol("toDisplayString"), Es = Symbol("mergeProps"), ua = Symbol("normalizeClass"), da = Symbol("normalizeStyle"), sn = Symbol("normalizeProps"), mn = Symbol("guardReactiveProps"), fa = Symbol("toHandlers"), wo = Symbol("camelize"), Xg = Symbol("capitalize"), _o = Symbol("toHandlerKey"), ei = Symbol("setBlockTracking"), Kg = Symbol("pushScopeId"), Jg = Symbol("popScopeId"), ma = Symbol("withCtx"), nn = Symbol("unref"), ti = Symbol("isRef"), ga = Symbol("withMemo"), Wp = Symbol("isMemoSame"), Mt = { [rn]: "Fragment", [Ts]: "Teleport", [dn]: "Suspense", [Qn]: "KeepAlive", [$p]: "BaseTransition", [Qr]: "openBlock", [qp]: "createBlock", [Vp]: "createElementBlock", [gi]: "createVNode", [oa]: "createElementVNode", [fn]: "createCommentVNode", [aa]: "createTextVNode", [ca]: "createStaticVNode", [Zn]: "resolveComponent", [yi]: "resolveDynamicComponent", [la]: "resolveDirective", [Gg]: "resolveFilter", [pa]: "withDirectives", [ha]: "renderList", [Hp]: "renderSlot", [zp]: "createSlots", [xi]: "toDisplayString", [Es]: "mergeProps", [ua]: "normalizeClass", [da]: "normalizeStyle", [sn]: "normalizeProps", [mn]: "guardReactiveProps", [fa]: "toHandlers", [wo]: "camelize", [Xg]: "capitalize", [_o]: "toHandlerKey", [ei]: "setBlockTracking", [Kg]: "pushScopeId", [Jg]: "popScopeId", [ma]: "withCtx", [nn]: "unref", [ti]: "isRef", [ga]: "withMemo", [Wp]: "isMemoSame" };
function Gp(e) {
  Object.getOwnPropertySymbols(e).forEach((t) => {
    Mt[t] = e[t];
  });
}
const tt = { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 }, source: "" };
function Ns(e, t = "") {
  return { type: 0, source: t, children: e, helpers: /* @__PURE__ */ new Set(), components: [], directives: [], hoists: [], imports: [], cached: [], temps: 0, codegenNode: void 0, loc: tt };
}
function on(e, t, s, n, i, o, c, l = !1, p = !1, d = !1, g = tt) {
  return e && (l ? (e.helper(Qr), e.helper(_s(e.inSSR, d))) : e.helper(ws(e.inSSR, d)), c && e.helper(pa)), { type: 13, tag: t, props: s, children: n, patchFlag: i, dynamicProps: o, directives: c, isBlock: l, disableTracking: p, isComponent: d, loc: g };
}
function Nr(e, t = tt) {
  return { type: 17, loc: t, elements: e };
}
function Ft(e, t = tt) {
  return { type: 15, loc: t, properties: e };
}
function Ve(e, t) {
  return { type: 16, loc: tt, key: De(e) ? ue(e, !0) : e, value: t };
}
function ue(e, t = !1, s = tt, n = 0) {
  return { type: 4, loc: s, content: e, isStatic: t, constType: t ? 3 : n };
}
function Po(e, t) {
  return { type: 5, loc: t, content: De(e) ? ue(e, !1, t) : e };
}
function dt(e, t = tt) {
  return { type: 8, loc: t, children: e };
}
function we(e, t = [], s = tt) {
  return { type: 14, loc: s, callee: e, arguments: t };
}
function Wt(e, t = void 0, s = !1, n = !1, i = tt) {
  return { type: 18, params: e, returns: t, newline: s, isSlot: n, loc: i };
}
function or(e, t, s, n = !0) {
  return { type: 19, test: e, consequent: t, alternate: s, newline: n, loc: tt };
}
function Yg(e, t, s = !1, n = !1) {
  return { type: 20, index: e, value: t, needPauseTracking: s, inVOnce: n, needArraySpread: !1, loc: tt };
}
function bi(e) {
  return { type: 21, body: e, loc: tt };
}
function Xp(e) {
  return { type: 22, elements: e, loc: tt };
}
function Ao(e, t, s) {
  return { type: 23, test: e, consequent: t, alternate: s, loc: tt };
}
function oo(e, t) {
  return { type: 24, left: e, right: t, loc: tt };
}
function Qg(e) {
  return { type: 25, expressions: e, loc: tt };
}
function Zg(e) {
  return { type: 26, returns: e, loc: tt };
}
function ws(e, t) {
  return e || t ? gi : oa;
}
function _s(e, t) {
  return e || t ? qp : Vp;
}
function ya(e, { helper: t, removeHelper: s, inSSR: n }) {
  e.isBlock || (e.isBlock = !0, s(ws(n, e.isComponent)), t(Qr), t(_s(n, e.isComponent)));
}
var pc, ey = new Uint16Array('áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e) => e.charCodeAt(0))), ev = new Uint16Array("È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((e) => e.charCodeAt(0)));
const tv = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), Vl = (pc = String.fromCodePoint) !== null && pc !== void 0 ? pc : function(e) {
  let t = "";
  return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += String.fromCharCode(e), t;
};
var ft;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(ft || (ft = {}));
var zr, ut, mr;
function Hl(e) {
  return e >= ft.ZERO && e <= ft.NINE;
}
function rv(e) {
  return e >= ft.UPPER_A && e <= ft.UPPER_F || e >= ft.LOWER_A && e <= ft.LOWER_F;
}
function sv(e) {
  return e === ft.EQUALS || (function(t) {
    return t >= ft.UPPER_A && t <= ft.UPPER_Z || t >= ft.LOWER_A && t <= ft.LOWER_Z || Hl(t);
  })(e);
}
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(zr || (zr = {})), (function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(ut || (ut = {})), (function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(mr || (mr = {}));
class ty {
  constructor(t, s, n) {
    this.decodeTree = t, this.emitCodePoint = s, this.errors = n, this.state = ut.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = mr.Strict;
  }
  startEntity(t) {
    this.decodeMode = t, this.state = ut.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(t, s) {
    switch (this.state) {
      case ut.EntityStart:
        return t.charCodeAt(s) === ft.NUM ? (this.state = ut.NumericStart, this.consumed += 1, this.stateNumericStart(t, s + 1)) : (this.state = ut.NamedEntity, this.stateNamedEntity(t, s));
      case ut.NumericStart:
        return this.stateNumericStart(t, s);
      case ut.NumericDecimal:
        return this.stateNumericDecimal(t, s);
      case ut.NumericHex:
        return this.stateNumericHex(t, s);
      case ut.NamedEntity:
        return this.stateNamedEntity(t, s);
    }
  }
  stateNumericStart(t, s) {
    return s >= t.length ? -1 : (32 | t.charCodeAt(s)) === ft.LOWER_X ? (this.state = ut.NumericHex, this.consumed += 1, this.stateNumericHex(t, s + 1)) : (this.state = ut.NumericDecimal, this.stateNumericDecimal(t, s));
  }
  addToNumericResult(t, s, n, i) {
    if (s !== n) {
      const o = n - s;
      this.result = this.result * Math.pow(i, o) + parseInt(t.substr(s, o), i), this.consumed += o;
    }
  }
  stateNumericHex(t, s) {
    const n = s;
    for (; s < t.length; ) {
      const i = t.charCodeAt(s);
      if (!Hl(i) && !rv(i)) return this.addToNumericResult(t, n, s, 16), this.emitNumericEntity(i, 3);
      s += 1;
    }
    return this.addToNumericResult(t, n, s, 16), -1;
  }
  stateNumericDecimal(t, s) {
    const n = s;
    for (; s < t.length; ) {
      const i = t.charCodeAt(s);
      if (!Hl(i)) return this.addToNumericResult(t, n, s, 10), this.emitNumericEntity(i, 2);
      s += 1;
    }
    return this.addToNumericResult(t, n, s, 10), -1;
  }
  emitNumericEntity(t, s) {
    var n;
    if (this.consumed <= s) return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === ft.SEMI) this.consumed += 1;
    else if (this.decodeMode === mr.Strict) return 0;
    return this.emitCodePoint((function(i) {
      var o;
      return i >= 55296 && i <= 57343 || i > 1114111 ? 65533 : (o = tv.get(i)) !== null && o !== void 0 ? o : i;
    })(this.result), this.consumed), this.errors && (t !== ft.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(t, s) {
    const { decodeTree: n } = this;
    let i = n[this.treeIndex], o = (i & zr.VALUE_LENGTH) >> 14;
    for (; s < t.length; s++, this.excess++) {
      const c = t.charCodeAt(s);
      if (this.treeIndex = nv(n, i, this.treeIndex + Math.max(1, o), c), this.treeIndex < 0) return this.result === 0 || this.decodeMode === mr.Attribute && (o === 0 || sv(c)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = n[this.treeIndex], o = (i & zr.VALUE_LENGTH) >> 14, o !== 0) {
        if (c === ft.SEMI) return this.emitNamedEntityData(this.treeIndex, o, this.consumed + this.excess);
        this.decodeMode !== mr.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: s, decodeTree: n } = this, i = (n[s] & zr.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(s, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(t, s, n) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(s === 1 ? i[t] & ~zr.VALUE_LENGTH : i[t + 1], n), s === 3 && this.emitCodePoint(i[t + 2], n), n;
  }
  end() {
    var t;
    switch (this.state) {
      case ut.NamedEntity:
        return this.result === 0 || this.decodeMode === mr.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity();
      case ut.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case ut.NumericHex:
        return this.emitNumericEntity(0, 3);
      case ut.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case ut.EntityStart:
        return 0;
    }
  }
}
function ry(e) {
  let t = "";
  const s = new ty(e, (n) => t += Vl(n));
  return function(n, i) {
    let o = 0, c = 0;
    for (; (c = n.indexOf("&", c)) >= 0; ) {
      t += n.slice(o, c), s.startEntity(i);
      const p = s.write(n, c + 1);
      if (p < 0) {
        o = c + s.end();
        break;
      }
      o = c + p, c = p === 0 ? o + 1 : o;
    }
    const l = t + n.slice(o);
    return t = "", l;
  };
}
function nv(e, t, s, n) {
  const i = (t & zr.BRANCH_LENGTH) >> 7, o = t & zr.JUMP_TABLE;
  if (i === 0) return o !== 0 && n === o ? s : -1;
  if (o) {
    const p = n - o;
    return p < 0 || p >= i ? -1 : e[s + p] - 1;
  }
  let c = s, l = c + i - 1;
  for (; c <= l; ) {
    const p = c + l >>> 1, d = e[p];
    if (d < n) c = p + 1;
    else {
      if (!(d > n)) return e[p + i];
      l = p - 1;
    }
  }
  return -1;
}
const iv = ry(ey);
ry(ev);
const c1 = new Uint8Array([123, 123]), l1 = new Uint8Array([125, 125]);
function p1(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function qt(e) {
  return e === 32 || e === 10 || e === 9 || e === 12 || e === 13;
}
function Ur(e) {
  return e === 47 || e === 62 || qt(e);
}
function Co(e) {
  const t = new Uint8Array(e.length);
  for (let s = 0; s < e.length; s++) t[s] = e.charCodeAt(s);
  return t;
}
const bt = { Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]), CdataEnd: new Uint8Array([93, 93, 62]), CommentEnd: new Uint8Array([45, 45, 62]), ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]), StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]), TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]), TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97]) }, ov = { COMPILER_IS_ON_ELEMENT: { message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".', link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html" }, COMPILER_V_BIND_SYNC: { message: (e) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e}.sync\` should be changed to \`v-model:${e}\`.`, link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html" }, COMPILER_V_BIND_OBJECT_ORDER: { message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.', link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html" }, COMPILER_V_ON_NATIVE: { message: ".native modifier for v-on has been removed as is no longer necessary.", link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html" }, COMPILER_V_IF_V_FOR_PRECEDENCE: { message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.", link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html" }, COMPILER_NATIVE_TEMPLATE: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." }, COMPILER_INLINE_TEMPLATE: { message: '"inline-template" has been removed in Vue 3.', link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html" }, COMPILER_FILTERS: { message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.', link: "https://v3-migration.vuejs.org/breaking-changes/filters.html" } };
function zl(e, { compatConfig: t }) {
  const s = t && t[e];
  return e === "MODE" ? s || 3 : s;
}
function h1(e, t, s, ...n) {
  if (zl(e, t) === "suppress-warning") return;
  const { message: i, link: o } = ov[e], c = `(deprecation ${e}) ${typeof i == "function" ? i(...n) : i}${o ? `
  Details: ${o}` : ""}`, l = new SyntaxError(c);
  l.code = e, s && (l.loc = s), t.onWarn(l);
}
function Kp(e) {
  throw e;
}
function sy(e) {
  console.warn(`[Vue warn] ${e.message}`);
}
function $e(e, t, s, n) {
  const i = (s || Jp)[e] + (n || ""), o = new SyntaxError(String(i));
  return o.code = e, o.loc = t, o;
}
const Jp = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '<!--' in comment.", 17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`, 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 20: "Unexpected null character.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 26: "Legal directive name was expected.", 28: "v-if/v-else-if is missing expression.", 29: "v-if/else branches must use unique keys.", 30: "v-else/v-else-if has no adjacent v-if or v-else-if.", 31: "v-for is missing expression.", 32: "v-for has invalid expression.", 33: "<template v-for> key should be placed on the <template> tag.", 34: "v-bind is missing expression.", 52: "v-bind with same-name shorthand only allows static argument.", 35: "v-on is missing expression.", 36: "Unexpected custom directive on <slot> outlet.", 37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 38: "Duplicate slot names found. ", 39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 40: "v-slot can only be used on components or <template> tags.", 41: "v-model is missing expression.", 42: "v-model value must be a valid JavaScript member expression.", 43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`, 45: "Error parsing JavaScript expression: ", 46: "<KeepAlive> expects exactly one child component.", 51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.", 47: '"prefixIdentifiers" option is not supported in this build of compiler.', 48: "ES module mode is not supported in this build of compiler.", 49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 50: '"scopeId" option is only supported in module mode.', 53: "" };
function xa(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function ba(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var s = function n() {
      var i = !1;
      try {
        i = this instanceof n;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    s.prototype = t.prototype;
  } else s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(s, n, i.get ? i : { enumerable: !0, get: function() {
      return e[n];
    } });
  }), s;
}
var u1, js = {};
function av() {
  if (u1) return js;
  function e(P, r) {
    if (P == null) return {};
    var a = {};
    for (var u in P) if ({}.hasOwnProperty.call(P, u)) {
      if (r.indexOf(u) !== -1) continue;
      a[u] = P[u];
    }
    return a;
  }
  u1 = 1, Object.defineProperty(js, "__esModule", { value: !0 });
  class t {
    constructor(r, a, u) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = r, this.column = a, this.index = u;
    }
  }
  class s {
    constructor(r, a) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = r, this.end = a;
    }
  }
  function n(P, r) {
    const { line: a, column: u, index: T } = P;
    return new t(a, u + r, T + r);
  }
  const i = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var o = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: i }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: i } };
  const c = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, l = (P) => P.type === "UpdateExpression" ? c.UpdateExpression[`${P.prefix}`] : c[P.type];
  var p = { AccessorIsGenerator: ({ kind: P }) => `A ${P}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: P }) => `Missing initializer in ${P} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: P }) => `\`${P}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: P, exportName: r }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${P}' as '${r}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: P }) => `'${P === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: P }) => `Unsyntactic ${P === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.", ImportBindingIsString: ({ importName: P }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${P}" as foo }\`?`, ImportCallArity: "`import()` requires exactly one or two arguments.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: P }) => `Expected number in radix ${P}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: P }) => `Escape sequence in keyword ${P}.`, InvalidIdentifier: ({ identifierName: P }) => `Invalid identifier ${P}.`, InvalidLhs: ({ ancestor: P }) => `Invalid left-hand side in ${l(P)}.`, InvalidLhsBinding: ({ ancestor: P }) => `Binding invalid left-hand side in ${l(P)}.`, InvalidLhsOptionalChaining: ({ ancestor: P }) => `Invalid optional chaining in the left-hand side of ${l(P)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: P }) => `Unexpected character '${P}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: P }) => `Private name #${P} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: P }) => `Label '${P}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: P }) => `This experimental syntax requires enabling the parser plugin: ${P.map((r) => JSON.stringify(r)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: P }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${P.map((r) => JSON.stringify(r)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: P }) => `Duplicate key "${P}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: P }) => `An export name cannot include a lone surrogate, found '\\u${P.toString(16)}'.`, ModuleExportUndefined: ({ localName: P }) => `Export '${P}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: P }) => `Private names are only allowed in property accesses (\`obj.#${P}\`) or in \`in\` expressions (\`#${P} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: P }) => `Duplicate private name #${P}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: P }) => `Unexpected keyword '${P}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: P }) => `Unexpected reserved word '${P}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: P, unexpected: r }) => `Unexpected token${r ? ` '${r}'.` : ""}${P ? `, expected "${P}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.", UnexpectedVoidPattern: "Unexpected void binding.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: P, onlyValidPropertyName: r }) => `The only valid meta property for ${P} is ${P}.${r}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: P }) => `Identifier '${P}' has already been declared.`, VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.", VoidPatternInitializer: "A void binding may not have an initializer.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, d = { ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.", ParseExpressionExpectsEOF: ({ unexpected: P }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(P)}\`.` };
  const g = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var f = Object.assign({ PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: P }) => `Invalid topic token ${P}. In order to use ${P} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${P}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: P }) => `Hack-style pipe body cannot be an unparenthesized ${l({ type: P })}; please wrap it in parentheses.` }, { PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' });
  const x = ["message"];
  function m(P, r, a) {
    Object.defineProperty(P, r, { enumerable: !1, configurable: !0, value: a });
  }
  function y({ toMessage: P, code: r, reasonCode: a, syntaxPlugin: u }) {
    const T = a === "MissingPlugin" || a === "MissingOneOfPlugins";
    {
      const S = { AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter", AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter", SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter", SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType" };
      S[a] && (a = S[a]);
    }
    return function S(_, I) {
      const R = new SyntaxError();
      return R.code = r, R.reasonCode = a, R.loc = _, R.pos = _.index, R.syntaxPlugin = u, T && (R.missingPlugin = I.missingPlugin), m(R, "clone", function(M = {}) {
        var K;
        const { line: ne, column: ve, index: de } = (K = M.loc) != null ? K : _;
        return S(new t(ne, ve, de), Object.assign({}, I, M.details));
      }), m(R, "details", I), Object.defineProperty(R, "message", { configurable: !0, get() {
        const M = `${P(I)} (${_.line}:${_.column})`;
        return this.message = M, M;
      }, set(M) {
        Object.defineProperty(this, "message", { value: M, writable: !0 });
      } }), R;
    };
  }
  function v(P, r) {
    if (Array.isArray(P)) return (u) => v(u, P[0]);
    const a = {};
    for (const u of Object.keys(P)) {
      const T = P[u], S = typeof T == "string" ? { message: () => T } : typeof T == "function" ? { message: T } : T, { message: _ } = S, I = e(S, x), R = typeof _ == "string" ? () => _ : _;
      a[u] = y(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: u, toMessage: R }, r ? { syntaxPlugin: r } : {}, I));
    }
    return a;
  }
  const b = Object.assign({}, v(o), v(p), v({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: P }) => `Assigning to '${P}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: P }) => `Binding '${P}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), v(d), v`pipelineOperator`(f)), { defineProperty: E } = Object, w = (P, r) => {
    P && E(P, r, { enumerable: !1, value: P[r] });
  };
  function C(P) {
    return w(P.loc.start, "index"), w(P.loc.end, "index"), P;
  }
  class A {
    constructor(r, a) {
      this.token = void 0, this.preserveSpace = void 0, this.token = r, this.preserveSpace = !!a;
    }
  }
  const O = { brace: new A("{"), j_oTag: new A("<tag"), j_cTag: new A("</tag"), j_expr: new A("<tag>...</tag>", !0) };
  O.template = new A("`", !0);
  const D = !0, N = !0, j = !0, U = !0, X = !0;
  class W {
    constructor(r, a = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = r, this.keyword = a.keyword, this.beforeExpr = !!a.beforeExpr, this.startsExpr = !!a.startsExpr, this.rightAssociative = !!a.rightAssociative, this.isLoop = !!a.isLoop, this.isAssign = !!a.isAssign, this.prefix = !!a.prefix, this.postfix = !!a.postfix, this.binop = a.binop != null ? a.binop : null, this.updateContext = null;
    }
  }
  const H = /* @__PURE__ */ new Map();
  function F(P, r = {}) {
    r.keyword = P;
    const a = $(P, r);
    return H.set(P, a), a;
  }
  function q(P, r) {
    return $(P, { beforeExpr: D, binop: r });
  }
  let G = -1;
  const ee = [], ce = [], Te = [], Q = [], pe = [], J = [];
  function $(P, r = {}) {
    var a, u, T, S;
    return ++G, ce.push(P), Te.push((a = r.binop) != null ? a : -1), Q.push((u = r.beforeExpr) != null && u), pe.push((T = r.startsExpr) != null && T), J.push((S = r.prefix) != null && S), ee.push(new W(P, r)), G;
  }
  function oe(P, r = {}) {
    var a, u, T, S;
    return ++G, H.set(P, G), ce.push(P), Te.push((a = r.binop) != null ? a : -1), Q.push((u = r.beforeExpr) != null && u), pe.push((T = r.startsExpr) != null && T), J.push((S = r.prefix) != null && S), ee.push(new W("name", r)), G;
  }
  const Y = { bracketL: $("[", { beforeExpr: D, startsExpr: N }), bracketHashL: $("#[", { beforeExpr: D, startsExpr: N }), bracketBarL: $("[|", { beforeExpr: D, startsExpr: N }), bracketR: $("]"), bracketBarR: $("|]"), braceL: $("{", { beforeExpr: D, startsExpr: N }), braceBarL: $("{|", { beforeExpr: D, startsExpr: N }), braceHashL: $("#{", { beforeExpr: D, startsExpr: N }), braceR: $("}"), braceBarR: $("|}"), parenL: $("(", { beforeExpr: D, startsExpr: N }), parenR: $(")"), comma: $(",", { beforeExpr: D }), semi: $(";", { beforeExpr: D }), colon: $(":", { beforeExpr: D }), doubleColon: $("::", { beforeExpr: D }), dot: $("."), question: $("?", { beforeExpr: D }), questionDot: $("?."), arrow: $("=>", { beforeExpr: D }), template: $("template"), ellipsis: $("...", { beforeExpr: D }), backQuote: $("`", { startsExpr: N }), dollarBraceL: $("${", { beforeExpr: D, startsExpr: N }), templateTail: $("...`", { startsExpr: N }), templateNonTail: $("...${", { beforeExpr: D, startsExpr: N }), at: $("@"), hash: $("#", { startsExpr: N }), interpreterDirective: $("#!..."), eq: $("=", { beforeExpr: D, isAssign: U }), assign: $("_=", { beforeExpr: D, isAssign: U }), slashAssign: $("_=", { beforeExpr: D, isAssign: U }), xorAssign: $("_=", { beforeExpr: D, isAssign: U }), moduloAssign: $("_=", { beforeExpr: D, isAssign: U }), incDec: $("++/--", { prefix: X, postfix: !0, startsExpr: N }), bang: $("!", { beforeExpr: D, prefix: X, startsExpr: N }), tilde: $("~", { beforeExpr: D, prefix: X, startsExpr: N }), doubleCaret: $("^^", { startsExpr: N }), doubleAt: $("@@", { startsExpr: N }), pipeline: q("|>", 0), nullishCoalescing: q("??", 1), logicalOR: q("||", 1), logicalAND: q("&&", 2), bitwiseOR: q("|", 3), bitwiseXOR: q("^", 4), bitwiseAND: q("&", 5), equality: q("==/!=/===/!==", 6), lt: q("</>/<=/>=", 7), gt: q("</>/<=/>=", 7), relational: q("</>/<=/>=", 7), bitShift: q("<</>>/>>>", 8), bitShiftL: q("<</>>/>>>", 8), bitShiftR: q("<</>>/>>>", 8), plusMin: $("+/-", { beforeExpr: D, binop: 9, prefix: X, startsExpr: N }), modulo: $("%", { binop: 10, startsExpr: N }), star: $("*", { binop: 10 }), slash: q("/", 10), exponent: $("**", { beforeExpr: D, binop: 11, rightAssociative: !0 }), _in: F("in", { beforeExpr: D, binop: 7 }), _instanceof: F("instanceof", { beforeExpr: D, binop: 7 }), _break: F("break"), _case: F("case", { beforeExpr: D }), _catch: F("catch"), _continue: F("continue"), _debugger: F("debugger"), _default: F("default", { beforeExpr: D }), _else: F("else", { beforeExpr: D }), _finally: F("finally"), _function: F("function", { startsExpr: N }), _if: F("if"), _return: F("return", { beforeExpr: D }), _switch: F("switch"), _throw: F("throw", { beforeExpr: D, prefix: X, startsExpr: N }), _try: F("try"), _var: F("var"), _const: F("const"), _with: F("with"), _new: F("new", { beforeExpr: D, startsExpr: N }), _this: F("this", { startsExpr: N }), _super: F("super", { startsExpr: N }), _class: F("class", { startsExpr: N }), _extends: F("extends", { beforeExpr: D }), _export: F("export"), _import: F("import", { startsExpr: N }), _null: F("null", { startsExpr: N }), _true: F("true", { startsExpr: N }), _false: F("false", { startsExpr: N }), _typeof: F("typeof", { beforeExpr: D, prefix: X, startsExpr: N }), _void: F("void", { beforeExpr: D, prefix: X, startsExpr: N }), _delete: F("delete", { beforeExpr: D, prefix: X, startsExpr: N }), _do: F("do", { isLoop: j, beforeExpr: D }), _for: F("for", { isLoop: j }), _while: F("while", { isLoop: j }), _as: oe("as", { startsExpr: N }), _assert: oe("assert", { startsExpr: N }), _async: oe("async", { startsExpr: N }), _await: oe("await", { startsExpr: N }), _defer: oe("defer", { startsExpr: N }), _from: oe("from", { startsExpr: N }), _get: oe("get", { startsExpr: N }), _let: oe("let", { startsExpr: N }), _meta: oe("meta", { startsExpr: N }), _of: oe("of", { startsExpr: N }), _sent: oe("sent", { startsExpr: N }), _set: oe("set", { startsExpr: N }), _source: oe("source", { startsExpr: N }), _static: oe("static", { startsExpr: N }), _using: oe("using", { startsExpr: N }), _yield: oe("yield", { startsExpr: N }), _asserts: oe("asserts", { startsExpr: N }), _checks: oe("checks", { startsExpr: N }), _exports: oe("exports", { startsExpr: N }), _global: oe("global", { startsExpr: N }), _implements: oe("implements", { startsExpr: N }), _intrinsic: oe("intrinsic", { startsExpr: N }), _infer: oe("infer", { startsExpr: N }), _is: oe("is", { startsExpr: N }), _mixins: oe("mixins", { startsExpr: N }), _proto: oe("proto", { startsExpr: N }), _require: oe("require", { startsExpr: N }), _satisfies: oe("satisfies", { startsExpr: N }), _keyof: oe("keyof", { startsExpr: N }), _readonly: oe("readonly", { startsExpr: N }), _unique: oe("unique", { startsExpr: N }), _abstract: oe("abstract", { startsExpr: N }), _declare: oe("declare", { startsExpr: N }), _enum: oe("enum", { startsExpr: N }), _module: oe("module", { startsExpr: N }), _namespace: oe("namespace", { startsExpr: N }), _interface: oe("interface", { startsExpr: N }), _type: oe("type", { startsExpr: N }), _opaque: oe("opaque", { startsExpr: N }), name: $("name", { startsExpr: N }), placeholder: $("%%", { startsExpr: N }), string: $("string", { startsExpr: N }), num: $("num", { startsExpr: N }), bigint: $("bigint", { startsExpr: N }), decimal: $("decimal", { startsExpr: N }), regexp: $("regexp", { startsExpr: N }), privateName: $("#name", { startsExpr: N }), eof: $("eof"), jsxName: $("jsxName"), jsxText: $("jsxText", { beforeExpr: D }), jsxTagStart: $("jsxTagStart", { startsExpr: N }), jsxTagEnd: $("jsxTagEnd") };
  function se(P) {
    return P >= 93 && P <= 133;
  }
  function z(P) {
    return P >= 58 && P <= 133;
  }
  function ie(P) {
    return P >= 58 && P <= 137;
  }
  function ae(P) {
    return pe[P];
  }
  function ge(P) {
    return P >= 129 && P <= 131;
  }
  function Ee(P) {
    return P >= 58 && P <= 92;
  }
  function fe(P) {
    return P === 34;
  }
  function me(P) {
    return ce[P];
  }
  function Oe(P) {
    return Te[P];
  }
  function qe(P) {
    return P >= 24 && P <= 25;
  }
  function Me(P) {
    return ee[P];
  }
  ee[8].updateContext = (P) => {
    P.pop();
  }, ee[5].updateContext = ee[7].updateContext = ee[23].updateContext = (P) => {
    P.push(O.brace);
  }, ee[22].updateContext = (P) => {
    P[P.length - 1] === O.template ? P.pop() : P.push(O.template);
  }, ee[143].updateContext = (P) => {
    P.push(O.j_expr, O.j_oTag);
  };
  let at = "ÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Í¿Î†Îˆ-ÎŠÎŒÎ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô¯Ô±-Õ–Õ™Õ -Öˆ×-×ª×¯-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯İ-Ş¥Ş±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¡ -à¡ªà¡°-à¢‡à¢‰-à¢à¢ -à£‰à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¦€à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§à§œà§à§Ÿ-à§¡à§°à§±à§¼à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©à©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à«¹à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®-à®à®’-à®•à®™à®šà®œà®à®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°-à°à°’-à°¨à°ª-à°¹à°½à±˜-à±šà±à± à±¡à²€à²…-à²Œà²-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³à³à³ à³¡à³±à³²à´„-à´Œà´-à´à´’-à´ºà´½àµàµ”-àµ–àµŸ-àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº†-àºŠàºŒ-àº£àº¥àº§-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚á‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášá€-áá -áµá¸-á½á-á™¬á™¯-á™¿áš-áššáš -á›ªá›®-á›¸áœ€-áœ‘áœŸ-áœ±á€-á‘á -á¬á®-á°á€-á³áŸ—áŸœá  -á¡¸á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤á¥-á¥­á¥°-á¥´á¦€-á¦«á¦°-á§‰á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­Œá®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á²€-á²Šá²-á²ºá²½-á²¿á³©-á³¬á³®-á³³á³µá³¶á³ºá´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„˜-â„â„¤â„¦â„¨â„ª-â„¹â„¼-â„¿â……-â…‰â…â… -â†ˆâ°€-â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·â·-â·–â·˜-â·ã€…-ã€‡ã€¡-ã€©ã€±-ã€µã€¸-ã€¼ã-ã‚–ã‚›-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„¯ã„±-ã†ã† -ã†¿ã‡°-ã‡¿ã€-ä¶¿ä¸€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êšêš -ê›¯êœ—-êœŸêœ¢-êˆê‹-êŸêŸêŸ‘êŸ“êŸ•-êŸœêŸ²-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê£½ê£¾ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê§ -ê§¤ê§¦-ê§¯ê§º-ê§¾ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºê©¾-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬ê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¬°-ê­šê­œ-ê­©ê­°-ê¯¢ê°€-í£í°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ", St = "Â·Ì€-Í¯Î‡Òƒ-Ò‡Ö‘-Ö½Ö¿××‚×„×…×‡Ø-ØšÙ‹-Ù©Ù°Û–-ÛœÛŸ-Û¤Û§Û¨Ûª-Û­Û°-Û¹Ü‘Ü°-İŠŞ¦-Ş°ß€-ß‰ß«-ß³ß½à –-à ™à ›-à £à ¥-à §à ©-à ­à¡™-à¡›à¢—-à¢Ÿà£Š-à£¡à££-à¤ƒà¤º-à¤¼à¤¾-à¥à¥‘-à¥—à¥¢à¥£à¥¦-à¥¯à¦-à¦ƒà¦¼à¦¾-à§„à§‡à§ˆà§‹-à§à§—à§¢à§£à§¦-à§¯à§¾à¨-à¨ƒà¨¼à¨¾-à©‚à©‡à©ˆà©‹-à©à©‘à©¦-à©±à©µàª-àªƒàª¼àª¾-à«…à«‡-à«‰à«‹-à«à«¢à«£à«¦-à«¯à«º-à«¿à¬-à¬ƒà¬¼à¬¾-à­„à­‡à­ˆà­‹-à­à­•-à­—à­¢à­£à­¦-à­¯à®‚à®¾-à¯‚à¯†-à¯ˆà¯Š-à¯à¯—à¯¦-à¯¯à°€-à°„à°¼à°¾-à±„à±†-à±ˆà±Š-à±à±•à±–à±¢à±£à±¦-à±¯à²-à²ƒà²¼à²¾-à³„à³†-à³ˆà³Š-à³à³•à³–à³¢à³£à³¦-à³¯à³³à´€-à´ƒà´»à´¼à´¾-àµ„àµ†-àµˆàµŠ-àµàµ—àµ¢àµ£àµ¦-àµ¯à¶-à¶ƒà·Šà·-à·”à·–à·˜-à·Ÿà·¦-à·¯à·²à·³à¸±à¸´-à¸ºà¹‡-à¹à¹-à¹™àº±àº´-àº¼à»ˆ-à»à»-à»™à¼˜à¼™à¼ -à¼©à¼µà¼·à¼¹à¼¾à¼¿à½±-à¾„à¾†à¾‡à¾-à¾—à¾™-à¾¼à¿†á€«-á€¾á€-á‰á–-á™á-á á¢-á¤á§-á­á±-á´á‚‚-á‚á‚-á‚á-áŸá©-á±áœ’-áœ•áœ²-áœ´á’á“á²á³á´-áŸ“áŸáŸ -áŸ©á ‹-á á -á ™á¢©á¤ -á¤«á¤°-á¤»á¥†-á¥á§-á§šá¨—-á¨›á©•-á©á© -á©¼á©¿-áª‰áª-áª™áª°-áª½áª¿-á«á¬€-á¬„á¬´-á­„á­-á­™á­«-á­³á®€-á®‚á®¡-á®­á®°-á®¹á¯¦-á¯³á°¤-á°·á±€-á±‰á±-á±™á³-á³’á³”-á³¨á³­á³´á³·-á³¹á·€-á·¿â€Œâ€â€¿â€â”âƒ-âƒœâƒ¡âƒ¥-âƒ°â³¯-â³±âµ¿â· -â·¿ã€ª-ã€¯ã‚™ã‚šãƒ»ê˜ -ê˜©ê™¯ê™´-ê™½êšêšŸê›°ê›±ê ‚ê †ê ‹ê £-ê §ê ¬ê¢€ê¢ê¢´-ê£…ê£-ê£™ê£ -ê£±ê£¿-ê¤‰ê¤¦-ê¤­ê¥‡-ê¥“ê¦€-ê¦ƒê¦³-ê§€ê§-ê§™ê§¥ê§°-ê§¹ê¨©-ê¨¶ê©ƒê©Œê©ê©-ê©™ê©»-ê©½êª°êª²-êª´êª·êª¸êª¾êª¿ê«ê««-ê«¯ê«µê«¶ê¯£-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ï¬ï¸€-ï¸ï¸ -ï¸¯ï¸³ï¸´ï¹-ï¹ï¼-ï¼™ï¼¿ï½¥";
  const Zt = new RegExp("[" + at + "]"), hr = new RegExp("[" + at + St + "]");
  at = St = null;
  const os = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Tn = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Dr(P, r) {
    let a = 65536;
    for (let u = 0, T = r.length; u < T; u += 2) {
      if (a += r[u], a > P) return !1;
      if (a += r[u + 1], a >= P) return !0;
    }
    return !1;
  }
  function er(P) {
    return P < 65 ? P === 36 : P <= 90 || (P < 97 ? P === 95 : P <= 122 || (P <= 65535 ? P >= 170 && Zt.test(String.fromCharCode(P)) : Dr(P, os)));
  }
  function Fr(P) {
    return P < 48 ? P === 36 : P < 58 || !(P < 65) && (P <= 90 || (P < 97 ? P === 95 : P <= 122 || (P <= 65535 ? P >= 170 && hr.test(String.fromCharCode(P)) : Dr(P, os) || Dr(P, Tn))));
  }
  const Ka = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Ja = ["eval", "arguments"], q0 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), V0 = new Set(Ka), H0 = new Set(Ja);
  function Mu(P, r) {
    return r && P === "await" || P === "enum";
  }
  function Du(P, r) {
    return Mu(P, r) || V0.has(P);
  }
  function Fu(P) {
    return H0.has(P);
  }
  function ju(P, r) {
    return Du(P, r) || Fu(P);
  }
  const z0 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  class Ya {
    constructor(r) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = r;
    }
  }
  class Qa {
    constructor(r, a) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = r, this.inModule = a;
    }
    get inTopLevel() {
      return (1 & this.currentScope().flags) > 0;
    }
    get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
    }
    get allowNewTarget() {
      return (512 & this.currentThisScopeFlags()) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const r = this.currentThisScopeFlags();
      return (64 & r) > 0 && !(2 & r);
    }
    get inStaticBlock() {
      for (let r = this.scopeStack.length - 1; ; r--) {
        const { flags: a } = this.scopeStack[r];
        if (128 & a) return !0;
        if (1731 & a) return !1;
      }
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
    }
    get inBareCaseStatement() {
      return (256 & this.currentScope().flags) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(r) {
      return new Ya(r);
    }
    enter(r) {
      this.scopeStack.push(this.createScope(r));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(r) {
      return !!(130 & r.flags || !this.parser.inModule && 1 & r.flags);
    }
    declareName(r, a, u) {
      let T = this.currentScope();
      if (8 & a || 16 & a) {
        this.checkRedeclarationInScope(T, r, a, u);
        let S = T.names.get(r) || 0;
        16 & a ? S |= 4 : (T.firstLexicalName || (T.firstLexicalName = r), S |= 2), T.names.set(r, S), 8 & a && this.maybeExportDefined(T, r);
      } else if (4 & a) for (let S = this.scopeStack.length - 1; S >= 0 && (T = this.scopeStack[S], this.checkRedeclarationInScope(T, r, a, u), T.names.set(r, 1 | (T.names.get(r) || 0)), this.maybeExportDefined(T, r), !(1667 & T.flags)); --S) ;
      this.parser.inModule && 1 & T.flags && this.undefinedExports.delete(r);
    }
    maybeExportDefined(r, a) {
      this.parser.inModule && 1 & r.flags && this.undefinedExports.delete(a);
    }
    checkRedeclarationInScope(r, a, u, T) {
      this.isRedeclaredInScope(r, a, u) && this.parser.raise(b.VarRedeclaration, T, { identifierName: a });
    }
    isRedeclaredInScope(r, a, u) {
      if (!(1 & u)) return !1;
      if (8 & u) return r.names.has(a);
      const T = r.names.get(a);
      return 16 & u ? (2 & T) > 0 || !this.treatFunctionsAsVarInScope(r) && (1 & T) > 0 : (2 & T) > 0 && !(8 & r.flags && r.firstLexicalName === a) || !this.treatFunctionsAsVarInScope(r) && (4 & T) > 0;
    }
    checkLocalExport(r) {
      const { name: a } = r;
      this.scopeStack[0].names.has(a) || this.undefinedExports.set(a, r.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let r = this.scopeStack.length - 1; ; r--) {
        const { flags: a } = this.scopeStack[r];
        if (1667 & a) return a;
      }
    }
    currentThisScopeFlags() {
      for (let r = this.scopeStack.length - 1; ; r--) {
        const { flags: a } = this.scopeStack[r];
        if (1731 & a && !(4 & a)) return a;
      }
    }
  }
  class W0 extends Ya {
    constructor(...r) {
      super(...r), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class G0 extends Qa {
    createScope(r) {
      return new W0(r);
    }
    declareName(r, a, u) {
      const T = this.currentScope();
      if (2048 & a) return this.checkRedeclarationInScope(T, r, a, u), this.maybeExportDefined(T, r), void T.declareFunctions.add(r);
      super.declareName(r, a, u);
    }
    isRedeclaredInScope(r, a, u) {
      if (super.isRedeclaredInScope(r, a, u)) return !0;
      if (2048 & u && !r.declareFunctions.has(a)) {
        const T = r.names.get(a);
        return (4 & T) > 0 || (2 & T) > 0;
      }
      return !1;
    }
    checkLocalExport(r) {
      this.scopeStack[0].declareFunctions.has(r.name) || super.checkLocalExport(r);
    }
  }
  const X0 = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Se = v`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: P }) => `Cannot overwrite reserved type ${P}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: P, enumName: r }) => `Boolean enum members need to be initialized. Use either \`${P} = true,\` or \`${P} = false,\` in enum \`${r}\`.`, EnumDuplicateMemberName: ({ memberName: P, enumName: r }) => `Enum member names need to be unique, but the name \`${P}\` has already been used before in enum \`${r}\`.`, EnumInconsistentMemberValues: ({ enumName: P }) => `Enum \`${P}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: P, enumName: r }) => `Enum type \`${P}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: P }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${P}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: P, memberName: r, explicitType: a }) => `Enum \`${P}\` has type \`${a}\`, so the initializer of \`${r}\` needs to be a ${a} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: P, memberName: r }) => `Symbol enum members cannot be initialized. Use \`${r},\` in enum \`${P}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: P, memberName: r }) => `The enum member initializer for \`${r}\` needs to be a literal (either a boolean, number, or string) in enum \`${P}\`.`, EnumInvalidMemberName: ({ enumName: P, memberName: r, suggestion: a }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${r}\`, consider using \`${a}\`, in enum \`${P}\`.`, EnumNumberMemberNotInitialized: ({ enumName: P, memberName: r }) => `Number enum members need to be initialized, e.g. \`${r} = 1\` in enum \`${P}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: P }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${P}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: P }) => `Unexpected reserved type ${P}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: P, suggestion: r }) => `\`declare export ${P}\` is not supported. Use \`${r}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function Bu(P) {
    return P.importKind === "type" || P.importKind === "typeof";
  }
  const K0 = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, J0 = /\*?\s*@((?:no)?flow)\b/, Y0 = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "Â ", iexcl: "Â¡", cent: "Â¢", pound: "Â£", curren: "Â¤", yen: "Â¥", brvbar: "Â¦", sect: "Â§", uml: "Â¨", copy: "Â©", ordf: "Âª", laquo: "Â«", not: "Â¬", shy: "Â­", reg: "Â®", macr: "Â¯", deg: "Â°", plusmn: "Â±", sup2: "Â²", sup3: "Â³", acute: "Â´", micro: "Âµ", para: "Â¶", middot: "Â·", cedil: "Â¸", sup1: "Â¹", ordm: "Âº", raquo: "Â»", frac14: "Â¼", frac12: "Â½", frac34: "Â¾", iquest: "Â¿", Agrave: "Ã€", Aacute: "Ã", Acirc: "Ã‚", Atilde: "Ãƒ", Auml: "Ã„", Aring: "Ã…", AElig: "Ã†", Ccedil: "Ã‡", Egrave: "Ãˆ", Eacute: "Ã‰", Ecirc: "ÃŠ", Euml: "Ã‹", Igrave: "ÃŒ", Iacute: "Ã", Icirc: "Ã", Iuml: "Ã", ETH: "Ã", Ntilde: "Ã‘", Ograve: "Ã’", Oacute: "Ã“", Ocirc: "Ã”", Otilde: "Ã•", Ouml: "Ã–", times: "Ã—", Oslash: "Ã˜", Ugrave: "Ã™", Uacute: "Ãš", Ucirc: "Ã›", Uuml: "Ãœ", Yacute: "Ã", THORN: "Ã", szlig: "ÃŸ", agrave: "Ã ", aacute: "Ã¡", acirc: "Ã¢", atilde: "Ã£", auml: "Ã¤", aring: "Ã¥", aelig: "Ã¦", ccedil: "Ã§", egrave: "Ã¨", eacute: "Ã©", ecirc: "Ãª", euml: "Ã«", igrave: "Ã¬", iacute: "Ã­", icirc: "Ã®", iuml: "Ã¯", eth: "Ã°", ntilde: "Ã±", ograve: "Ã²", oacute: "Ã³", ocirc: "Ã´", otilde: "Ãµ", ouml: "Ã¶", divide: "Ã·", oslash: "Ã¸", ugrave: "Ã¹", uacute: "Ãº", ucirc: "Ã»", uuml: "Ã¼", yacute: "Ã½", thorn: "Ã¾", yuml: "Ã¿", OElig: "Å’", oelig: "Å“", Scaron: "Å ", scaron: "Å¡", Yuml: "Å¸", fnof: "Æ’", circ: "Ë†", tilde: "Ëœ", Alpha: "Î‘", Beta: "Î’", Gamma: "Î“", Delta: "Î”", Epsilon: "Î•", Zeta: "Î–", Eta: "Î—", Theta: "Î˜", Iota: "Î™", Kappa: "Îš", Lambda: "Î›", Mu: "Îœ", Nu: "Î", Xi: "Î", Omicron: "ÎŸ", Pi: "Î ", Rho: "Î¡", Sigma: "Î£", Tau: "Î¤", Upsilon: "Î¥", Phi: "Î¦", Chi: "Î§", Psi: "Î¨", Omega: "Î©", alpha: "Î±", beta: "Î²", gamma: "Î³", delta: "Î´", epsilon: "Îµ", zeta: "Î¶", eta: "Î·", theta: "Î¸", iota: "Î¹", kappa: "Îº", lambda: "Î»", mu: "Î¼", nu: "Î½", xi: "Î¾", omicron: "Î¿", pi: "Ï€", rho: "Ï", sigmaf: "Ï‚", sigma: "Ïƒ", tau: "Ï„", upsilon: "Ï…", phi: "Ï†", chi: "Ï‡", psi: "Ïˆ", omega: "Ï‰", thetasym: "Ï‘", upsih: "Ï’", piv: "Ï–", ensp: "â€‚", emsp: "â€ƒ", thinsp: "â€‰", zwnj: "â€Œ", zwj: "â€", lrm: "â€", rlm: "â€", ndash: "â€“", mdash: "â€”", lsquo: "â€˜", rsquo: "â€™", sbquo: "â€š", ldquo: "â€œ", rdquo: "â€", bdquo: "â€", dagger: "â€ ", Dagger: "â€¡", bull: "â€¢", hellip: "â€¦", permil: "â€°", prime: "â€²", Prime: "â€³", lsaquo: "â€¹", rsaquo: "â€º", oline: "â€¾", frasl: "â„", euro: "â‚¬", image: "â„‘", weierp: "â„˜", real: "â„œ", trade: "â„¢", alefsym: "â„µ", larr: "â†", uarr: "â†‘", rarr: "â†’", darr: "â†“", harr: "â†”", crarr: "â†µ", lArr: "â‡", uArr: "â‡‘", rArr: "â‡’", dArr: "â‡“", hArr: "â‡”", forall: "âˆ€", part: "âˆ‚", exist: "âˆƒ", empty: "âˆ…", nabla: "âˆ‡", isin: "âˆˆ", notin: "âˆ‰", ni: "âˆ‹", prod: "âˆ", sum: "âˆ‘", minus: "âˆ’", lowast: "âˆ—", radic: "âˆš", prop: "âˆ", infin: "âˆ", ang: "âˆ ", and: "âˆ§", or: "âˆ¨", cap: "âˆ©", cup: "âˆª", int: "âˆ«", there4: "âˆ´", sim: "âˆ¼", cong: "â‰…", asymp: "â‰ˆ", ne: "â‰ ", equiv: "â‰¡", le: "â‰¤", ge: "â‰¥", sub: "âŠ‚", sup: "âŠƒ", nsub: "âŠ„", sube: "âŠ†", supe: "âŠ‡", oplus: "âŠ•", otimes: "âŠ—", perp: "âŠ¥", sdot: "â‹…", lceil: "âŒˆ", rceil: "âŒ‰", lfloor: "âŒŠ", rfloor: "âŒ‹", lang: "âŒ©", rang: "âŒª", loz: "â—Š", spades: "â™ ", clubs: "â™£", hearts: "â™¥", diams: "â™¦" }, Ai = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, "g");
  function Ds(P) {
    switch (P) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  function Uu(P, r, a) {
    for (let u = r; u < a; u++) if (Ds(P.charCodeAt(u))) return !0;
    return !1;
  }
  const Za = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ec = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function Q0(P) {
    switch (P) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  const as = v`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: P }) => `Expected corresponding JSX closing tag for <${P}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: P, HTMLEntity: r }) => `Unexpected token \`${P}\`. Did you mean \`${r}\` or \`{'${P}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function jr(P) {
    return !!P && (P.type === "JSXOpeningFragment" || P.type === "JSXClosingFragment");
  }
  function Fs(P) {
    if (P.type === "JSXIdentifier") return P.name;
    if (P.type === "JSXNamespacedName") return P.namespace.name + ":" + P.name.name;
    if (P.type === "JSXMemberExpression") return Fs(P.object) + "." + Fs(P.property);
    throw new Error("Node had unexpected type: " + P.type);
  }
  class Z0 extends Ya {
    constructor(...r) {
      super(...r), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class eT extends Qa {
    constructor(...r) {
      super(...r), this.importsStack = [];
    }
    createScope(r) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Z0(r);
    }
    enter(r) {
      r === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(r);
    }
    exit() {
      const r = super.exit();
      return r === 1024 && this.importsStack.pop(), r;
    }
    hasImport(r, a) {
      const u = this.importsStack.length;
      if (this.importsStack[u - 1].has(r)) return !0;
      if (!a && u > 1) {
        for (let T = 0; T < u - 1; T++) if (this.importsStack[T].has(r)) return !0;
      }
      return !1;
    }
    declareName(r, a, u) {
      if (4096 & a) return this.hasImport(r, !0) && this.parser.raise(b.VarRedeclaration, u, { identifierName: r }), void this.importsStack[this.importsStack.length - 1].add(r);
      const T = this.currentScope();
      let S = T.tsNames.get(r) || 0;
      if (1024 & a) return this.maybeExportDefined(T, r), void T.tsNames.set(r, 16 | S);
      super.declareName(r, a, u), 2 & a && (1 & a || (this.checkRedeclarationInScope(T, r, a, u), this.maybeExportDefined(T, r)), S |= 1), 256 & a && (S |= 2), 512 & a && (S |= 4), 128 & a && (S |= 8), S && T.tsNames.set(r, S);
    }
    isRedeclaredInScope(r, a, u) {
      const T = r.tsNames.get(a);
      return (2 & T) > 0 ? 256 & u ? !!(512 & u) != (4 & T) > 0 : !0 : 128 & u && (8 & T) > 0 ? !!(2 & r.names.get(a)) && !!(1 & u) : !!(2 & u && (1 & T) > 0) || super.isRedeclaredInScope(r, a, u);
    }
    checkLocalExport(r) {
      const { name: a } = r;
      if (!this.hasImport(a)) {
        for (let u = this.scopeStack.length - 1; u >= 0; u--) {
          const T = this.scopeStack[u].tsNames.get(a);
          if ((1 & T) > 0 || (16 & T) > 0) return;
        }
        super.checkLocalExport(r);
      }
    }
  }
  class tT {
    constructor() {
      this.stacks = [];
    }
    enter(r) {
      this.stacks.push(r);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
    get hasIn() {
      return (8 & this.currentFlags()) > 0;
    }
  }
  function Ci(P, r) {
    return (P ? 2 : 0) | (r ? 1 : 0);
  }
  class rT {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(r) {
      return r + this.startIndex;
    }
    offsetToSourcePos(r) {
      return r - this.startIndex;
    }
    hasPlugin(r) {
      if (typeof r == "string") return this.plugins.has(r);
      {
        const [a, u] = r;
        if (!this.hasPlugin(a)) return !1;
        const T = this.plugins.get(a);
        for (const S of Object.keys(u)) if (T?.[S] !== u[S]) return !1;
        return !0;
      }
    }
    getPluginOption(r, a) {
      var u;
      return (u = this.plugins.get(r)) == null ? void 0 : u[a];
    }
  }
  function $u(P, r) {
    P.trailingComments === void 0 ? P.trailingComments = r : P.trailingComments.unshift(...r);
  }
  function vn(P, r) {
    P.innerComments === void 0 ? P.innerComments = r : P.innerComments.unshift(...r);
  }
  function cs(P, r, a) {
    let u = null, T = r.length;
    for (; u === null && T > 0; ) u = r[--T];
    u === null || u.start > a.start ? vn(P, a.comments) : $u(u, a.comments);
  }
  class sT extends rT {
    addComment(r) {
      this.filename && (r.loc.filename = this.filename);
      const { commentsLen: a } = this.state;
      this.comments.length !== a && (this.comments.length = a), this.comments.push(r), this.state.commentsLen++;
    }
    processComment(r) {
      const { commentStack: a } = this.state, u = a.length;
      if (u === 0) return;
      let T = u - 1;
      const S = a[T];
      S.start === r.end && (S.leadingNode = r, T--);
      const { start: _ } = r;
      for (; T >= 0; T--) {
        const I = a[T], R = I.end;
        if (!(R > _)) {
          R === _ && (I.trailingNode = r);
          break;
        }
        I.containingNode = r, this.finalizeComment(I), a.splice(T, 1);
      }
    }
    finalizeComment(r) {
      var a;
      const { comments: u } = r;
      if (r.leadingNode !== null || r.trailingNode !== null) r.leadingNode !== null && $u(r.leadingNode, u), r.trailingNode !== null && (function(T, S) {
        T.leadingComments === void 0 ? T.leadingComments = S : T.leadingComments.unshift(...S);
      })(r.trailingNode, u);
      else {
        const { containingNode: T, start: S } = r;
        if (this.input.charCodeAt(this.offsetToSourcePos(S) - 1) === 44) switch (T.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            cs(T, T.properties, r);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            cs(T, T.arguments, r);
            break;
          case "ImportExpression":
            cs(T, [T.source, (a = T.options) != null ? a : null], r);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            cs(T, T.params, r);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            cs(T, T.elements, r);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            cs(T, T.specifiers, r);
            break;
          case "TSEnumDeclaration":
          case "TSEnumBody":
            cs(T, T.members, r);
            break;
          default:
            vn(T, u);
        }
        else vn(T, u);
      }
    }
    finalizeRemainingComments() {
      const { commentStack: r } = this.state;
      for (let a = r.length - 1; a >= 0; a--) this.finalizeComment(r[a]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(r) {
      const { commentStack: a } = this.state, { length: u } = a;
      if (u === 0) return;
      const T = a[u - 1];
      T.leadingNode === r && (T.leadingNode = null);
    }
    takeSurroundingComments(r, a, u) {
      const { commentStack: T } = this.state, S = T.length;
      if (S === 0) return;
      let _ = S - 1;
      for (; _ >= 0; _--) {
        const I = T[_], R = I.end;
        if (I.start === u) I.leadingNode = r;
        else if (R === a) I.trailingNode = r;
        else if (R < a) break;
      }
    }
  }
  class tc {
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [O.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (1 & this.flags) > 0;
    }
    set strict(r) {
      r ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: r, sourceType: a, startIndex: u, startLine: T, startColumn: S }) {
      this.strict = r !== !1 && (r === !0 || a === "module"), this.startIndex = u, this.curLine = T, this.lineStart = -S, this.startLoc = this.endLoc = new t(T, S, u);
    }
    get maybeInArrowParameters() {
      return (2 & this.flags) > 0;
    }
    set maybeInArrowParameters(r) {
      r ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (4 & this.flags) > 0;
    }
    set inType(r) {
      r ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (8 & this.flags) > 0;
    }
    set noAnonFunctionType(r) {
      r ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (16 & this.flags) > 0;
    }
    set hasFlowComment(r) {
      r ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (32 & this.flags) > 0;
    }
    set isAmbientContext(r) {
      r ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (64 & this.flags) > 0;
    }
    set inAbstractClass(r) {
      r ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (128 & this.flags) > 0;
    }
    set inDisallowConditionalTypesContext(r) {
      r ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (256 & this.flags) > 0;
    }
    set soloAwait(r) {
      r ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (512 & this.flags) > 0;
    }
    set inFSharpPipelineDirectBody(r) {
      r ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (1024 & this.flags) > 0;
    }
    set canStartJSXElement(r) {
      r ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (2048 & this.flags) > 0;
    }
    set containsEsc(r) {
      r ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (4096 & this.flags) > 0;
    }
    set hasTopLevelAwait(r) {
      r ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new t(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      const r = new tc();
      return r.flags = this.flags, r.startIndex = this.startIndex, r.curLine = this.curLine, r.lineStart = this.lineStart, r.startLoc = this.startLoc, r.endLoc = this.endLoc, r.errors = this.errors.slice(), r.potentialArrowAt = this.potentialArrowAt, r.noArrowAt = this.noArrowAt.slice(), r.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), r.topicContext = this.topicContext, r.labels = this.labels.slice(), r.commentsLen = this.commentsLen, r.commentStack = this.commentStack.slice(), r.pos = this.pos, r.type = this.type, r.value = this.value, r.start = this.start, r.end = this.end, r.lastTokEndLoc = this.lastTokEndLoc, r.lastTokStartLoc = this.lastTokStartLoc, r.context = this.context.slice(), r.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, r.strictErrors = this.strictErrors, r.tokensLength = this.tokensLength, r;
    }
  }
  var nT = function(P) {
    return P >= 48 && P <= 57;
  };
  const qu = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ii = { bin: (P) => P === 48 || P === 49, oct: (P) => P >= 48 && P <= 55, dec: (P) => P >= 48 && P <= 57, hex: (P) => P >= 48 && P <= 57 || P >= 65 && P <= 70 || P >= 97 && P <= 102 };
  function Vu(P, r, a, u, T, S) {
    const _ = a, I = u, R = T;
    let M = "", K = null, ne = a;
    const { length: ve } = r;
    for (; ; ) {
      if (a >= ve) {
        S.unterminated(_, I, R), M += r.slice(ne, a);
        break;
      }
      const de = r.charCodeAt(a);
      if (iT(P, de, r, a)) {
        M += r.slice(ne, a);
        break;
      }
      if (de === 92) {
        M += r.slice(ne, a);
        const Pe = oT(r, a, u, T, P === "template", S);
        Pe.ch !== null || K ? M += Pe.ch : K = { pos: a, lineStart: u, curLine: T }, { pos: a, lineStart: u, curLine: T } = Pe, ne = a;
      } else de === 8232 || de === 8233 ? (++T, u = ++a) : de === 10 || de === 13 ? P === "template" ? (M += r.slice(ne, a) + `
`, ++a, de === 13 && r.charCodeAt(a) === 10 && ++a, ++T, ne = u = a) : S.unterminated(_, I, R) : ++a;
    }
    return { pos: a, str: M, firstInvalidLoc: K, lineStart: u, curLine: T, containsInvalid: !!K };
  }
  function iT(P, r, a, u) {
    return P === "template" ? r === 96 || r === 36 && a.charCodeAt(u + 1) === 123 : r === (P === "double" ? 34 : 39);
  }
  function oT(P, r, a, u, T, S) {
    const _ = !T;
    r++;
    const I = (M) => ({ pos: r, ch: M, lineStart: a, curLine: u }), R = P.charCodeAt(r++);
    switch (R) {
      case 110:
        return I(`
`);
      case 114:
        return I("\r");
      case 120: {
        let M;
        return { code: M, pos: r } = rc(P, r, a, u, 2, !1, _, S), I(M === null ? null : String.fromCharCode(M));
      }
      case 117: {
        let M;
        return { code: M, pos: r } = zu(P, r, a, u, _, S), I(M === null ? null : String.fromCodePoint(M));
      }
      case 116:
        return I("	");
      case 98:
        return I("\b");
      case 118:
        return I("\v");
      case 102:
        return I("\f");
      case 13:
        P.charCodeAt(r) === 10 && ++r;
      case 10:
        a = r, ++u;
      case 8232:
      case 8233:
        return I("");
      case 56:
      case 57:
        if (T) return I(null);
        S.strictNumericEscape(r - 1, a, u);
      default:
        if (R >= 48 && R <= 55) {
          const M = r - 1;
          let K = /^[0-7]+/.exec(P.slice(M, r + 2))[0], ne = parseInt(K, 8);
          ne > 255 && (K = K.slice(0, -1), ne = parseInt(K, 8)), r += K.length - 1;
          const ve = P.charCodeAt(r);
          if (K !== "0" || ve === 56 || ve === 57) {
            if (T) return I(null);
            S.strictNumericEscape(M, a, u);
          }
          return I(String.fromCharCode(ne));
        }
        return I(String.fromCharCode(R));
    }
  }
  function rc(P, r, a, u, T, S, _, I) {
    const R = r;
    let M;
    return { n: M, pos: r } = Hu(P, r, a, u, 16, T, S, !1, I, !_), M === null && (_ ? I.invalidEscapeSequence(R, a, u) : r = R - 1), { code: M, pos: r };
  }
  function Hu(P, r, a, u, T, S, _, I, R, M) {
    const K = r, ne = T === 16 ? qu.hex : qu.decBinOct, ve = T === 16 ? Ii.hex : T === 10 ? Ii.dec : T === 8 ? Ii.oct : Ii.bin;
    let de = !1, Pe = 0;
    for (let He = 0, ct = S ?? 1 / 0; He < ct; ++He) {
      const Re = P.charCodeAt(r);
      let nt;
      if (Re === 95 && I !== "bail") {
        const En = P.charCodeAt(r - 1), oc = P.charCodeAt(r + 1);
        if (I) {
          if (Number.isNaN(oc) || !ve(oc) || ne.has(En) || ne.has(oc)) {
            if (M) return { n: null, pos: r };
            R.unexpectedNumericSeparator(r, a, u);
          }
        } else {
          if (M) return { n: null, pos: r };
          R.numericSeparatorInEscapeSequence(r, a, u);
        }
        ++r;
        continue;
      }
      if (nt = Re >= 97 ? Re - 97 + 10 : Re >= 65 ? Re - 65 + 10 : nT(Re) ? Re - 48 : 1 / 0, nt >= T) {
        if (nt <= 9 && M) return { n: null, pos: r };
        if (nt <= 9 && R.invalidDigit(r, a, u, T)) nt = 0;
        else {
          if (!_) break;
          nt = 0, de = !0;
        }
      }
      ++r, Pe = Pe * T + nt;
    }
    return r === K || S != null && r - K !== S || de ? { n: null, pos: r } : { n: Pe, pos: r };
  }
  function zu(P, r, a, u, T, S) {
    let _;
    if (P.charCodeAt(r) === 123) {
      if (++r, { code: _, pos: r } = rc(P, r, a, u, P.indexOf("}", r) - r, !0, T, S), ++r, _ !== null && _ > 1114111) {
        if (!T) return { code: null, pos: r };
        S.invalidCodePoint(r, a, u);
      }
    } else ({ code: _, pos: r } = rc(P, r, a, u, 4, !1, T, S));
    return { code: _, pos: r };
  }
  function kn(P, r, a) {
    return new t(a, P - r, P);
  }
  const aT = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Br {
    constructor(r) {
      const a = r.startIndex || 0;
      this.type = r.type, this.value = r.value, this.start = a + r.start, this.end = a + r.end, this.loc = new s(r.startLoc, r.endLoc);
    }
  }
  class cT extends sT {
    constructor(r, a) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (u, T, S, _) => !!(2048 & this.optionFlags) && (this.raise(b.InvalidDigit, kn(u, T, S), { radix: _ }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(b.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(b.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(b.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(b.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (u, T, S) => {
        this.recordStrictModeErrors(b.StrictNumericEscape, kn(u, T, S));
      }, unterminated: (u, T, S) => {
        throw this.raise(b.UnterminatedString, kn(u - 1, T, S));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(b.StrictNumericEscape), unterminated: (u, T, S) => {
        throw this.raise(b.UnterminatedTemplate, kn(u, T, S));
      } }), this.state = new tc(), this.state.init(r), this.input = a, this.length = a.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(r) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(r), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), 256 & this.optionFlags && this.pushToken(new Br(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(r) {
      return !!this.match(r) && (this.next(), !0);
    }
    match(r) {
      return this.state.type === r;
    }
    createLookaheadState(r) {
      return { pos: r.pos, value: null, type: r.type, start: r.start, end: r.end, context: [this.curContext()], inType: r.inType, startLoc: r.startLoc, lastTokEndLoc: r.lastTokEndLoc, curLine: r.curLine, lineStart: r.lineStart, curPosition: r.curPosition };
    }
    lookahead() {
      const r = this.state;
      this.state = this.createLookaheadState(r), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const a = this.state;
      return this.state = r, a;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(r) {
      return Za.lastIndex = r, Za.test(this.input) ? Za.lastIndex : r;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(r) {
      return this.input.charCodeAt(this.nextTokenStartSince(r));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(r) {
      return ec.lastIndex = r, ec.test(this.input) ? ec.lastIndex : r;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(r) {
      let a = this.input.charCodeAt(r);
      if ((64512 & a) == 55296 && ++r < this.input.length) {
        const u = this.input.charCodeAt(r);
        (64512 & u) == 56320 && (a = 65536 + ((1023 & a) << 10) + (1023 & u));
      }
      return a;
    }
    setStrict(r) {
      this.state.strict = r, r && (this.state.strictErrors.forEach(([a, u]) => this.raise(a, u)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(r) {
      let a;
      this.isLookahead || (a = this.state.curPosition());
      const u = this.state.pos, T = this.input.indexOf(r, u + 2);
      if (T === -1) throw this.raise(b.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = T + r.length, Ai.lastIndex = u + 2; Ai.test(this.input) && Ai.lastIndex <= T; ) ++this.state.curLine, this.state.lineStart = Ai.lastIndex;
      if (this.isLookahead) return;
      const S = { type: "CommentBlock", value: this.input.slice(u + 2, T), start: this.sourceToOffsetPos(u), end: this.sourceToOffsetPos(T + r.length), loc: new s(a, this.state.curPosition()) };
      return 256 & this.optionFlags && this.pushToken(S), S;
    }
    skipLineComment(r) {
      const a = this.state.pos;
      let u;
      this.isLookahead || (u = this.state.curPosition());
      let T = this.input.charCodeAt(this.state.pos += r);
      if (this.state.pos < this.length) for (; !Ds(T) && ++this.state.pos < this.length; ) T = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const S = this.state.pos, _ = { type: "CommentLine", value: this.input.slice(a + r, S), start: this.sourceToOffsetPos(a), end: this.sourceToOffsetPos(S), loc: new s(u, this.state.curPosition()) };
      return 256 & this.optionFlags && this.pushToken(_), _;
    }
    skipSpace() {
      const r = this.state.pos, a = 4096 & this.optionFlags ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        const u = this.input.charCodeAt(this.state.pos);
        switch (u) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const T = this.skipBlockComment("*/");
                T !== void 0 && (this.addComment(T), a?.push(T));
                break;
              }
              case 47: {
                const T = this.skipLineComment(2);
                T !== void 0 && (this.addComment(T), a?.push(T));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Q0(u)) ++this.state.pos;
            else if (u === 45 && !this.inModule && 8192 & this.optionFlags) {
              const T = this.state.pos;
              if (this.input.charCodeAt(T + 1) !== 45 || this.input.charCodeAt(T + 2) !== 62 || !(r === 0 || this.state.lineStart > r)) break e;
              {
                const S = this.skipLineComment(3);
                S !== void 0 && (this.addComment(S), a?.push(S));
              }
            } else {
              if (u !== 60 || this.inModule || !(8192 & this.optionFlags)) break e;
              {
                const T = this.state.pos;
                if (this.input.charCodeAt(T + 1) !== 33 || this.input.charCodeAt(T + 2) !== 45 || this.input.charCodeAt(T + 3) !== 45) break e;
                {
                  const S = this.skipLineComment(4);
                  S !== void 0 && (this.addComment(S), a?.push(S));
                }
              }
            }
        }
      }
      if (a?.length > 0) {
        const u = this.state.pos, T = { start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(u), comments: a, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(T);
      }
    }
    finishToken(r, a) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const u = this.state.type;
      this.state.type = r, this.state.value = a, this.isLookahead || this.updateContext(u);
    }
    replaceToken(r) {
      this.state.type = r, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) return;
      const r = this.state.pos + 1, a = this.codePointAtPos(r);
      if (a >= 48 && a <= 57) throw this.raise(b.UnexpectedDigitAfterHash, this.state.curPosition());
      if (a === 123 || a === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(a === 123 ? b.RecordExpressionHashIncorrectStartSyntaxType : b.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, a === 123 ? this.finishToken(7) : this.finishToken(1);
      } else er(a) ? (++this.state.pos, this.finishToken(139, this.readWord1(a))) : a === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const r = this.input.charCodeAt(this.state.pos + 1);
      r >= 48 && r <= 57 ? this.readNumber(!0) : r === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r !== 33) return !1;
      const a = this.state.pos;
      for (this.state.pos += 1; !Ds(r) && ++this.state.pos < this.length; ) r = this.input.charCodeAt(this.state.pos);
      const u = this.input.slice(a + 2, this.state.pos);
      return this.finishToken(28, u), !0;
    }
    readToken_mult_modulo(r) {
      let a = r === 42 ? 55 : 54, u = 1, T = this.input.charCodeAt(this.state.pos + 1);
      r === 42 && T === 42 && (u++, T = this.input.charCodeAt(this.state.pos + 2), a = 57), T !== 61 || this.state.inType || (u++, a = r === 37 ? 33 : 30), this.finishOp(a, u);
    }
    readToken_pipe_amp(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      if (a !== r) {
        if (r === 124) {
          if (a === 62) return void this.finishOp(39, 2);
          if (this.hasPlugin("recordAndTuple") && a === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(9);
          }
          if (this.hasPlugin("recordAndTuple") && a === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(4);
          }
        }
        a !== 61 ? this.finishOp(r === 124 ? 43 : 45, 1) : this.finishOp(30, 2);
      } else this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(r === 124 ? 41 : 42, 2);
    }
    readToken_caret() {
      const r = this.input.charCodeAt(this.state.pos + 1);
      r !== 61 || this.state.inType ? r === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      a !== r ? a === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
    }
    readToken_lt() {
      const { pos: r } = this.state, a = this.input.charCodeAt(r + 1);
      if (a === 60) return this.input.charCodeAt(r + 2) === 61 ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
      a !== 61 ? this.finishOp(47, 1) : this.finishOp(49, 2);
    }
    readToken_gt() {
      const { pos: r } = this.state, a = this.input.charCodeAt(r + 1);
      if (a === 62) {
        const u = this.input.charCodeAt(r + 2) === 62 ? 3 : 2;
        return this.input.charCodeAt(r + u) === 61 ? void this.finishOp(30, u + 1) : void this.finishOp(52, u);
      }
      a !== 61 ? this.finishOp(48, 1) : this.finishOp(49, 2);
    }
    readToken_eq_excl(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      if (a !== 61) return r === 61 && a === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(r === 61 ? 29 : 35, 1);
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    }
    readToken_question() {
      const r = this.input.charCodeAt(this.state.pos + 1), a = this.input.charCodeAt(this.state.pos + 2);
      r === 63 ? a === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : r !== 46 || a >= 48 && a <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
    }
    getTokenFromCode(r) {
      switch (r) {
        case 46:
          return void this.readToken_dot();
        case 40:
          return ++this.state.pos, void this.finishToken(10);
        case 41:
          return ++this.state.pos, void this.finishToken(11);
        case 59:
          return ++this.state.pos, void this.finishToken(13);
        case 44:
          return ++this.state.pos, void this.finishToken(12);
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          return ++this.state.pos, void this.finishToken(3);
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          return ++this.state.pos, void this.finishToken(8);
        case 58:
          return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
        case 63:
          return void this.readToken_question();
        case 96:
          return void this.readTemplateToken();
        case 48: {
          const a = this.input.charCodeAt(this.state.pos + 1);
          if (a === 120 || a === 88) return void this.readRadixNumber(16);
          if (a === 111 || a === 79) return void this.readRadixNumber(8);
          if (a === 98 || a === 66) return void this.readRadixNumber(2);
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return void this.readNumber(!1);
        case 34:
        case 39:
          return void this.readString(r);
        case 47:
          return void this.readToken_slash();
        case 37:
        case 42:
          return void this.readToken_mult_modulo(r);
        case 124:
        case 38:
          return void this.readToken_pipe_amp(r);
        case 94:
          return void this.readToken_caret();
        case 43:
        case 45:
          return void this.readToken_plus_min(r);
        case 60:
          return void this.readToken_lt();
        case 62:
          return void this.readToken_gt();
        case 61:
        case 33:
          return void this.readToken_eq_excl(r);
        case 126:
          return void this.finishOp(36, 1);
        case 64:
          return void this.readToken_atSign();
        case 35:
          return void this.readToken_numberSign();
        case 92:
          return void this.readWord();
        default:
          if (er(r)) return void this.readWord(r);
      }
      throw this.raise(b.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(r) });
    }
    finishOp(r, a) {
      const u = this.input.slice(this.state.pos, this.state.pos + a);
      this.state.pos += a, this.finishToken(r, u);
    }
    readRegexp() {
      const r = this.state.startLoc, a = this.state.start + 1;
      let u, T, { pos: S } = this.state;
      for (; ; ++S) {
        if (S >= this.length) throw this.raise(b.UnterminatedRegExp, n(r, 1));
        const M = this.input.charCodeAt(S);
        if (Ds(M)) throw this.raise(b.UnterminatedRegExp, n(r, 1));
        if (u) u = !1;
        else {
          if (M === 91) T = !0;
          else if (M === 93 && T) T = !1;
          else if (M === 47 && !T) break;
          u = M === 92;
        }
      }
      const _ = this.input.slice(a, S);
      ++S;
      let I = "";
      const R = () => n(r, S + 2 - a);
      for (; S < this.length; ) {
        const M = this.codePointAtPos(S), K = String.fromCharCode(M);
        if (aT.has(M)) M === 118 ? I.includes("u") && this.raise(b.IncompatibleRegExpUVFlags, R()) : M === 117 && I.includes("v") && this.raise(b.IncompatibleRegExpUVFlags, R()), I.includes(K) && this.raise(b.DuplicateRegExpFlags, R());
        else {
          if (!Fr(M) && M !== 92) break;
          this.raise(b.MalformedRegExpFlags, R());
        }
        ++S, I += K;
      }
      this.state.pos = S, this.finishToken(138, { pattern: _, flags: I });
    }
    readInt(r, a, u = !1, T = !0) {
      const { n: S, pos: _ } = Hu(this.input, this.state.pos, this.state.lineStart, this.state.curLine, r, a, u, T, this.errorHandlers_readInt, !1);
      return this.state.pos = _, S;
    }
    readRadixNumber(r) {
      const a = this.state.pos, u = this.state.curPosition();
      let T = !1;
      this.state.pos += 2;
      const S = this.readInt(r);
      S == null && this.raise(b.InvalidDigit, n(u, 2), { radix: r });
      const _ = this.input.charCodeAt(this.state.pos);
      if (_ === 110) ++this.state.pos, T = !0;
      else if (_ === 109) throw this.raise(b.InvalidDecimal, u);
      if (er(this.codePointAtPos(this.state.pos))) throw this.raise(b.NumberIdentifier, this.state.curPosition());
      if (T) {
        const I = this.input.slice(a, this.state.pos).replace(/[_n]/g, "");
        return void this.finishToken(136, I);
      }
      this.finishToken(135, S);
    }
    readNumber(r) {
      const a = this.state.pos, u = this.state.curPosition();
      let T = !1, S = !1, _ = !1, I = !1;
      r || this.readInt(10) !== null || this.raise(b.InvalidNumber, this.state.curPosition());
      const R = this.state.pos - a >= 2 && this.input.charCodeAt(a) === 48;
      if (R) {
        const de = this.input.slice(a, this.state.pos);
        if (this.recordStrictModeErrors(b.StrictOctalLiteral, u), !this.state.strict) {
          const Pe = de.indexOf("_");
          Pe > 0 && this.raise(b.ZeroDigitNumericSeparator, n(u, Pe));
        }
        I = R && !/[89]/.test(de);
      }
      let M = this.input.charCodeAt(this.state.pos);
      if (M !== 46 || I || (++this.state.pos, this.readInt(10), T = !0, M = this.input.charCodeAt(this.state.pos)), M !== 69 && M !== 101 || I || (M = this.input.charCodeAt(++this.state.pos), M !== 43 && M !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(b.InvalidOrMissingExponent, u), T = !0, _ = !0, M = this.input.charCodeAt(this.state.pos)), M === 110 && ((T || R) && this.raise(b.InvalidBigIntLiteral, u), ++this.state.pos, S = !0), M === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (_ || R) && this.raise(b.InvalidDecimal, u), ++this.state.pos;
        var K = !0;
      }
      if (er(this.codePointAtPos(this.state.pos))) throw this.raise(b.NumberIdentifier, this.state.curPosition());
      const ne = this.input.slice(a, this.state.pos).replace(/[_mn]/g, "");
      if (S) return void this.finishToken(136, ne);
      if (K) return void this.finishToken(137, ne);
      const ve = I ? parseInt(ne, 8) : parseFloat(ne);
      this.finishToken(135, ve);
    }
    readCodePoint(r) {
      const { code: a, pos: u } = zu(this.input, this.state.pos, this.state.lineStart, this.state.curLine, r, this.errorHandlers_readCodePoint);
      return this.state.pos = u, a;
    }
    readString(r) {
      const { str: a, pos: u, curLine: T, lineStart: S } = Vu(r === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = u + 1, this.state.lineStart = S, this.state.curLine = T, this.finishToken(134, a);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const r = this.input[this.state.pos], { str: a, firstInvalidLoc: u, pos: T, curLine: S, lineStart: _ } = Vu("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = T + 1, this.state.lineStart = _, this.state.curLine = S, u && (this.state.firstInvalidTemplateEscapePos = new t(u.curLine, u.pos - u.lineStart, this.sourceToOffsetPos(u.pos))), this.input.codePointAt(T) === 96 ? this.finishToken(24, u ? null : r + a + "`") : (this.state.pos++, this.finishToken(25, u ? null : r + a + "${"));
    }
    recordStrictModeErrors(r, a) {
      const u = a.index;
      this.state.strict && !this.state.strictErrors.has(u) ? this.raise(r, a) : this.state.strictErrors.set(u, [r, a]);
    }
    readWord1(r) {
      this.state.containsEsc = !1;
      let a = "";
      const u = this.state.pos;
      let T = this.state.pos;
      for (r !== void 0 && (this.state.pos += r <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const S = this.codePointAtPos(this.state.pos);
        if (Fr(S)) this.state.pos += S <= 65535 ? 1 : 2;
        else {
          if (S !== 92) break;
          {
            this.state.containsEsc = !0, a += this.input.slice(T, this.state.pos);
            const _ = this.state.curPosition(), I = this.state.pos === u ? er : Fr;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(b.MissingUnicodeEscape, this.state.curPosition()), T = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const R = this.readCodePoint(!0);
            R !== null && (I(R) || this.raise(b.EscapedCharNotAnIdentifier, _), a += String.fromCodePoint(R)), T = this.state.pos;
          }
        }
      }
      return a + this.input.slice(T, this.state.pos);
    }
    readWord(r) {
      const a = this.readWord1(r), u = H.get(a);
      u !== void 0 ? this.finishToken(u, me(u)) : this.finishToken(132, a);
    }
    checkKeywordEscapes() {
      const { type: r } = this.state;
      Ee(r) && this.state.containsEsc && this.raise(b.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: me(r) });
    }
    raise(r, a, u = {}) {
      const T = r(a instanceof t ? a : a.loc.start, u);
      if (!(2048 & this.optionFlags)) throw T;
      return this.isLookahead || this.state.errors.push(T), T;
    }
    raiseOverwrite(r, a, u = {}) {
      const T = a instanceof t ? a : a.loc.start, S = T.index, _ = this.state.errors;
      for (let I = _.length - 1; I >= 0; I--) {
        const R = _[I];
        if (R.loc.index === S) return _[I] = r(T, u);
        if (R.loc.index < S) break;
      }
      return this.raise(r, a, u);
    }
    updateContext(r) {
    }
    unexpected(r, a) {
      throw this.raise(b.UnexpectedToken, r ?? this.state.startLoc, { expected: a ? me(a) : null });
    }
    expectPlugin(r, a) {
      if (this.hasPlugin(r)) return !0;
      throw this.raise(b.MissingPlugin, a ?? this.state.startLoc, { missingPlugin: [r] });
    }
    expectOnePlugin(r) {
      if (!r.some((a) => this.hasPlugin(a))) throw this.raise(b.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: r });
    }
    errorBuilder(r) {
      return (a, u, T) => {
        this.raise(r, kn(a, u, T));
      };
    }
  }
  class lT {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class pT {
    constructor(r) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = r;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new lT());
    }
    exit() {
      const r = this.stack.pop(), a = this.current();
      for (const [u, T] of Array.from(r.undefinedPrivateNames)) a ? a.undefinedPrivateNames.has(u) || a.undefinedPrivateNames.set(u, T) : this.parser.raise(b.InvalidPrivateFieldResolution, T, { identifierName: u });
    }
    declarePrivateName(r, a, u) {
      const { privateNames: T, loneAccessors: S, undefinedPrivateNames: _ } = this.current();
      let I = T.has(r);
      if (3 & a) {
        const R = I && S.get(r);
        R ? (I = (3 & R) === (3 & a) || (4 & R) !== (4 & a), I || S.delete(r)) : I || S.set(r, a);
      }
      I && this.parser.raise(b.PrivateNameRedeclaration, u, { identifierName: r }), T.add(r), _.delete(r);
    }
    usePrivateName(r, a) {
      let u;
      for (u of this.stack) if (u.privateNames.has(r)) return;
      u ? u.undefinedPrivateNames.set(r, a) : this.parser.raise(b.InvalidPrivateFieldResolution, a, { identifierName: r });
    }
  }
  class Ni {
    constructor(r = 0) {
      this.type = r;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class Wu extends Ni {
    constructor(r) {
      super(r), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(r, a) {
      const u = a.index;
      this.declarationErrors.set(u, [r, a]);
    }
    clearDeclarationError(r) {
      this.declarationErrors.delete(r);
    }
    iterateErrors(r) {
      this.declarationErrors.forEach(r);
    }
  }
  class hT {
    constructor(r) {
      this.parser = void 0, this.stack = [new Ni()], this.parser = r;
    }
    enter(r) {
      this.stack.push(r);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(r, a) {
      const u = a.loc.start, { stack: T } = this;
      let S = T.length - 1, _ = T[S];
      for (; !_.isCertainlyParameterDeclaration(); ) {
        if (!_.canBeArrowParameterDeclaration()) return;
        _.recordDeclarationError(r, u), _ = T[--S];
      }
      this.parser.raise(r, u);
    }
    recordArrowParameterBindingError(r, a) {
      const { stack: u } = this, T = u[u.length - 1], S = a.loc.start;
      if (T.isCertainlyParameterDeclaration()) this.parser.raise(r, S);
      else {
        if (!T.canBeArrowParameterDeclaration()) return;
        T.recordDeclarationError(r, S);
      }
    }
    recordAsyncArrowParametersError(r) {
      const { stack: a } = this;
      let u = a.length - 1, T = a[u];
      for (; T.canBeArrowParameterDeclaration(); ) T.type === 2 && T.recordDeclarationError(b.AwaitBindingIdentifier, r), T = a[--u];
    }
    validateAsPattern() {
      const { stack: r } = this, a = r[r.length - 1];
      a.canBeArrowParameterDeclaration() && a.iterateErrors(([u, T]) => {
        this.parser.raise(u, T);
        let S = r.length - 2, _ = r[S];
        for (; _.canBeArrowParameterDeclaration(); ) _.clearDeclarationError(T.index), _ = r[--S];
      });
    }
  }
  function Gu() {
    return new Ni();
  }
  class uT extends cT {
    addExtra(r, a, u, T = !0) {
      if (!r) return;
      let { extra: S } = r;
      S == null && (S = {}, r.extra = S), T ? S[a] = u : Object.defineProperty(S, a, { enumerable: T, value: u });
    }
    isContextual(r) {
      return this.state.type === r && !this.state.containsEsc;
    }
    isUnparsedContextual(r, a) {
      if (this.input.startsWith(a, r)) {
        const u = this.input.charCodeAt(r + a.length);
        return !(Fr(u) || (64512 & u) == 55296);
      }
      return !1;
    }
    isLookaheadContextual(r) {
      const a = this.nextTokenStart();
      return this.isUnparsedContextual(a, r);
    }
    eatContextual(r) {
      return !!this.isContextual(r) && (this.next(), !0);
    }
    expectContextual(r, a) {
      if (!this.eatContextual(r)) {
        if (a != null) throw this.raise(a, this.state.startLoc);
        this.unexpected(null, r);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Uu(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return Uu(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(r = !0) {
      (r ? this.isLineTerminator() : this.eat(13)) || this.raise(b.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(r, a) {
      this.eat(r) || this.unexpected(a, r);
    }
    tryParse(r, a = this.state.clone()) {
      const u = { node: null };
      try {
        const T = r((S = null) => {
          throw u.node = S, u;
        });
        if (this.state.errors.length > a.errors.length) {
          const S = this.state;
          return this.state = a, this.state.tokensLength = S.tokensLength, { node: T, error: S.errors[a.errors.length], thrown: !1, aborted: !1, failState: S };
        }
        return { node: T, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (T) {
        const S = this.state;
        if (this.state = a, T instanceof SyntaxError) return { node: null, error: T, thrown: !0, aborted: !1, failState: S };
        if (T === u) return { node: u.node, error: null, thrown: !1, aborted: !0, failState: S };
        throw T;
      }
    }
    checkExpressionErrors(r, a) {
      if (!r) return !1;
      const { shorthandAssignLoc: u, doubleProtoLoc: T, privateKeyLoc: S, optionalParametersLoc: _, voidPatternLoc: I } = r;
      if (!a) return !!(u || T || _ || S || I);
      u != null && this.raise(b.InvalidCoverInitializedName, u), T != null && this.raise(b.DuplicateProto, T), S != null && this.raise(b.UnexpectedPrivateField, S), _ != null && this.unexpected(_), I != null && this.raise(b.InvalidCoverDiscardElement, I);
    }
    isLiteralPropertyName() {
      return ie(this.state.type);
    }
    isPrivateName(r) {
      return r.type === "PrivateName";
    }
    getPrivateNameSV(r) {
      return r.id.name;
    }
    hasPropertyAsPrivateName(r) {
      return (r.type === "MemberExpression" || r.type === "OptionalMemberExpression") && this.isPrivateName(r.property);
    }
    isObjectProperty(r) {
      return r.type === "ObjectProperty";
    }
    isObjectMethod(r) {
      return r.type === "ObjectMethod";
    }
    initializeScopes(r = this.options.sourceType === "module") {
      const a = this.state.labels;
      this.state.labels = [];
      const u = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const T = this.inModule;
      this.inModule = r;
      const S = this.scope, _ = this.getScopeHandler();
      this.scope = new _(this, r);
      const I = this.prodParam;
      this.prodParam = new tT();
      const R = this.classScope;
      this.classScope = new pT(this);
      const M = this.expressionScope;
      return this.expressionScope = new hT(this), () => {
        this.state.labels = a, this.exportedIdentifiers = u, this.inModule = T, this.scope = S, this.prodParam = I, this.classScope = R, this.expressionScope = M;
      };
    }
    enterInitialScopes() {
      let r = 0;
      (this.inModule || 1 & this.optionFlags) && (r |= 2), 32 & this.optionFlags && (r |= 1);
      const a = !this.inModule && this.options.sourceType === "commonjs";
      (a || 2 & this.optionFlags) && (r |= 4), this.prodParam.enter(r);
      let u = a ? 514 : 1;
      4 & this.optionFlags && (u |= 512), this.scope.enter(u);
    }
    checkDestructuringPrivate(r) {
      const { privateKeyLoc: a } = r;
      a !== null && this.expectPlugin("destructuringPrivate", a);
    }
  }
  class Oi {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc = null;
    }
  }
  class Li {
    constructor(r, a, u) {
      this.type = "", this.start = a, this.end = 0, this.loc = new s(u), 128 & r?.optionFlags && (this.range = [a, 0]), r != null && r.filename && (this.loc.filename = r.filename);
    }
  }
  const sc = Li.prototype;
  sc.__clone = function() {
    const P = new Li(void 0, this.start, this.loc.start), r = Object.keys(this);
    for (let a = 0, u = r.length; a < u; a++) {
      const T = r[a];
      T !== "leadingComments" && T !== "trailingComments" && T !== "innerComments" && (P[T] = this[T]);
    }
    return P;
  };
  class dT extends uT {
    startNode() {
      const r = this.state.startLoc;
      return new Li(this, r.index, r);
    }
    startNodeAt(r) {
      return new Li(this, r.index, r);
    }
    startNodeAtNode(r) {
      return this.startNodeAt(r.loc.start);
    }
    finishNode(r, a) {
      return this.finishNodeAt(r, a, this.state.lastTokEndLoc);
    }
    finishNodeAt(r, a, u) {
      return r.type = a, r.end = u.index, r.loc.end = u, 128 & this.optionFlags && (r.range[1] = u.index), 4096 & this.optionFlags && this.processComment(r), r;
    }
    resetStartLocation(r, a) {
      r.start = a.index, r.loc.start = a, 128 & this.optionFlags && (r.range[0] = a.index);
    }
    resetEndLocation(r, a = this.state.lastTokEndLoc) {
      r.end = a.index, r.loc.end = a, 128 & this.optionFlags && (r.range[1] = a.index);
    }
    resetStartLocationFromNode(r, a) {
      this.resetStartLocation(r, a.loc.start);
    }
    castNodeTo(r, a) {
      return r.type = a, r;
    }
    cloneIdentifier(r) {
      const { type: a, start: u, end: T, loc: S, range: _, name: I } = r, R = Object.create(sc);
      return R.type = a, R.start = u, R.end = T, R.loc = S, R.range = _, R.name = I, r.extra && (R.extra = r.extra), R;
    }
    cloneStringLiteral(r) {
      const { type: a, start: u, end: T, loc: S, range: _, extra: I } = r, R = Object.create(sc);
      return R.type = a, R.start = u, R.end = T, R.loc = S, R.range = _, R.extra = I, R.value = r.value, R;
    }
  }
  const Xu = (P) => P.type === "ParenthesizedExpression" ? Xu(P.expression) : P;
  class fT extends dT {
    toAssignable(r, a = !1) {
      var u, T;
      let S;
      switch ((r.type === "ParenthesizedExpression" || (u = r.extra) != null && u.parenthesized) && (S = Xu(r), a ? S.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(b.InvalidParenthesizedAssignment, r) : S.type === "MemberExpression" || this.isOptionalMemberExpression(S) || this.raise(b.InvalidParenthesizedAssignment, r) : this.raise(b.InvalidParenthesizedAssignment, r)), r.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(r, "ObjectPattern");
          for (let I = 0, R = r.properties.length, M = R - 1; I < R; I++) {
            var _;
            const K = r.properties[I], ne = I === M;
            this.toAssignableObjectExpressionProp(K, ne, a), ne && K.type === "RestElement" && (_ = r.extra) != null && _.trailingCommaLoc && this.raise(b.RestTrailingComma, r.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const { key: I, value: R } = r;
          this.isPrivateName(I) && this.classScope.usePrivateName(this.getPrivateNameSV(I), I.loc.start), this.toAssignable(R, a);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          this.castNodeTo(r, "ArrayPattern"), this.toAssignableList(r.elements, (T = r.extra) == null ? void 0 : T.trailingCommaLoc, a);
          break;
        case "AssignmentExpression":
          r.operator !== "=" && this.raise(b.MissingEqInAssignment, r.left.loc.end), this.castNodeTo(r, "AssignmentPattern"), delete r.operator, r.left.type === "VoidPattern" && this.raise(b.VoidPatternInitializer, r.left), this.toAssignable(r.left, a);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(S, a);
      }
    }
    toAssignableObjectExpressionProp(r, a, u) {
      if (r.type === "ObjectMethod") this.raise(r.kind === "get" || r.kind === "set" ? b.PatternHasAccessor : b.PatternHasMethod, r.key);
      else if (r.type === "SpreadElement") {
        this.castNodeTo(r, "RestElement");
        const T = r.argument;
        this.checkToRestConversion(T, !1), this.toAssignable(T, u), a || this.raise(b.RestTrailingComma, r);
      } else this.toAssignable(r, u);
    }
    toAssignableList(r, a, u) {
      const T = r.length - 1;
      for (let S = 0; S <= T; S++) {
        const _ = r[S];
        _ && (this.toAssignableListItem(r, S, u), _.type === "RestElement" && (S < T ? this.raise(b.RestTrailingComma, _) : a && this.raise(b.RestTrailingComma, a)));
      }
    }
    toAssignableListItem(r, a, u) {
      const T = r[a];
      if (T.type === "SpreadElement") {
        this.castNodeTo(T, "RestElement");
        const S = T.argument;
        this.checkToRestConversion(S, !0), this.toAssignable(S, u);
      } else this.toAssignable(T, u);
    }
    isAssignable(r, a) {
      switch (r.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return !0;
        case "ObjectExpression": {
          const u = r.properties.length - 1;
          return r.properties.every((T, S) => T.type !== "ObjectMethod" && (S === u || T.type !== "SpreadElement") && this.isAssignable(T));
        }
        case "ObjectProperty":
          return this.isAssignable(r.value);
        case "SpreadElement":
          return this.isAssignable(r.argument);
        case "ArrayExpression":
          return r.elements.every((u) => u === null || this.isAssignable(u));
        case "AssignmentExpression":
          return r.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(r.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !a;
        default:
          return !1;
      }
    }
    toReferencedList(r, a) {
      return r;
    }
    toReferencedListDeep(r, a) {
      this.toReferencedList(r, a);
      for (const u of r) u?.type === "ArrayExpression" && this.toReferencedListDeep(u.elements);
    }
    parseSpread(r) {
      const a = this.startNode();
      return this.next(), a.argument = this.parseMaybeAssignAllowIn(r, void 0), this.finishNode(a, "SpreadElement");
    }
    parseRestBinding() {
      const r = this.startNode();
      this.next();
      const a = this.parseBindingAtom();
      return a.type === "VoidPattern" && this.raise(b.UnexpectedVoidPattern, a), r.argument = a, this.finishNode(r, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const r = this.startNode();
          return this.next(), r.elements = this.parseBindingList(3, 93, 1), this.finishNode(r, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    }
    parseBindingList(r, a, u) {
      const T = 1 & u, S = [];
      let _ = !0;
      for (; !this.eat(r); ) if (_ ? _ = !1 : this.expect(12), T && this.match(12)) S.push(null);
      else {
        if (this.eat(r)) break;
        if (this.match(21)) {
          let I = this.parseRestBinding();
          if ((this.hasPlugin("flow") || 2 & u) && (I = this.parseFunctionParamType(I)), S.push(I), !this.checkCommaAfterRest(a)) {
            this.expect(r);
            break;
          }
        } else {
          const I = [];
          if (2 & u) for (this.match(26) && this.hasPlugin("decorators") && this.raise(b.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) I.push(this.parseDecorator());
          S.push(this.parseBindingElement(u, I));
        }
      }
      return S;
    }
    parseBindingRestProperty(r) {
      return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (r.argument = this.parseVoidPattern(null), this.raise(b.UnexpectedVoidPattern, r.argument)) : r.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r, "RestElement");
    }
    parseBindingProperty() {
      const { type: r, startLoc: a } = this.state;
      if (r === 21) return this.parseBindingRestProperty(this.startNode());
      const u = this.startNode();
      return r === 139 ? (this.expectPlugin("destructuringPrivate", a), this.classScope.usePrivateName(this.state.value, a), u.key = this.parsePrivateName()) : this.parsePropertyName(u), u.method = !1, this.parseObjPropValue(u, a, !1, !1, !0, !1);
    }
    parseBindingElement(r, a) {
      const u = this.parseMaybeDefault();
      return (this.hasPlugin("flow") || 2 & r) && this.parseFunctionParamType(u), a.length && (u.decorators = a, this.resetStartLocationFromNode(u, a[0])), this.parseMaybeDefault(u.loc.start, u);
    }
    parseFunctionParamType(r) {
      return r;
    }
    parseMaybeDefault(r, a) {
      if (r != null || (r = this.state.startLoc), a = a ?? this.parseBindingAtom(), !this.eat(29)) return a;
      const u = this.startNodeAt(r);
      return a.type === "VoidPattern" && this.raise(b.VoidPatternInitializer, a), u.left = a, u.right = this.parseMaybeAssignAllowIn(), this.finishNode(u, "AssignmentPattern");
    }
    isValidLVal(r, a, u) {
      switch (r) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return !0;
      }
      return !1;
    }
    isOptionalMemberExpression(r) {
      return r.type === "OptionalMemberExpression";
    }
    checkLVal(r, a, u = 64, T = !1, S = !1, _ = !1) {
      var I;
      const R = r.type;
      if (this.isObjectMethod(r)) return;
      const M = this.isOptionalMemberExpression(r);
      if (M || R === "MemberExpression") return M && (this.expectPlugin("optionalChainingAssign", r.loc.start), a.type !== "AssignmentExpression" && this.raise(b.InvalidLhsOptionalChaining, r, { ancestor: a })), void (u !== 64 && this.raise(b.InvalidPropertyBindingPattern, r));
      if (R === "Identifier") {
        this.checkIdentifier(r, u, S);
        const { name: He } = r;
        return void (T && (T.has(He) ? this.raise(b.ParamDupe, r) : T.add(He)));
      }
      R === "VoidPattern" && a.type === "CatchClause" && this.raise(b.VoidPatternCatchClauseParam, r);
      const K = this.isValidLVal(R, !(_ || (I = r.extra) != null && I.parenthesized) && a.type === "AssignmentExpression", u);
      if (K === !0) return;
      if (K === !1) {
        const He = u === 64 ? b.InvalidLhs : b.InvalidLhsBinding;
        return void this.raise(He, r, { ancestor: a });
      }
      let ne, ve;
      typeof K == "string" ? (ne = K, ve = R === "ParenthesizedExpression") : [ne, ve] = K;
      const de = R === "ArrayPattern" || R === "ObjectPattern" ? { type: R } : a, Pe = r[ne];
      if (Array.isArray(Pe)) for (const He of Pe) He && this.checkLVal(He, de, u, T, S, ve);
      else Pe && this.checkLVal(Pe, de, u, T, S, ve);
    }
    checkIdentifier(r, a, u = !1) {
      this.state.strict && (u ? ju(r.name, this.inModule) : Fu(r.name)) && (a === 64 ? this.raise(b.StrictEvalArguments, r, { referenceName: r.name }) : this.raise(b.StrictEvalArgumentsBinding, r, { bindingName: r.name })), 8192 & a && r.name === "let" && this.raise(b.LetInLexicalBinding, r), 64 & a || this.declareNameFromIdentifier(r, a);
    }
    declareNameFromIdentifier(r, a) {
      this.scope.declareName(r.name, a, r.loc.start);
    }
    checkToRestConversion(r, a) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(r.expression, a);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (a) break;
        default:
          this.raise(b.InvalidRestAssignmentPattern, r);
      }
    }
    checkCommaAfterRest(r) {
      return !!this.match(12) && (this.raise(this.lookaheadCharCode() === r ? b.RestTrailingComma : b.ElementAfterRest, this.state.startLoc), !0);
    }
  }
  function Ku(P) {
    if (!P) throw new Error("Assert fail");
  }
  const ye = v`typescript`({ AbstractMethodHasImplementation: ({ methodName: P }) => `Method '${P}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: P }) => `Property '${P}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: P }) => `'declare' is not allowed in ${P}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: P }) => `Accessibility modifier already seen: '${P}'.`, DuplicateModifier: ({ modifier: P }) => `Duplicate modifier: '${P}'.`, EmptyHeritageClauseType: ({ token: P }) => `'${P}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: P }) => `'${P[0]}' modifier cannot be used with '${P[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: P }) => `Index signatures cannot have an accessibility modifier ('${P}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidHeritageClauseType: ({ token: P }) => `'${P}' list can only include identifiers or qualified-names with optional type arguments.`, InvalidModifierOnAwaitUsingDeclaration: (P) => `'${P}' modifier cannot appear on an await using declaration.`, InvalidModifierOnTypeMember: ({ modifier: P }) => `'${P}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: P }) => `'${P}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: P }) => `'${P}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifierOnUsingDeclaration: (P) => `'${P}' modifier cannot appear on a using declaration.`, InvalidModifiersOrder: ({ orderedModifiers: P }) => `'${P[0]}' modifier must precede '${P[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: P }) => `Private elements cannot have an accessibility modifier ('${P}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: P }) => `Single type parameter ${P} should have a trailing comma. Example usage: <${P},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: P }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${P}.`, UsingDeclarationInAmbientContext: (P) => `'${P}' declarations are not allowed in ambient contexts.` });
  function Ju(P) {
    return P === "private" || P === "public" || P === "protected";
  }
  function mT(P) {
    return P === "in" || P === "out";
  }
  function gT(P) {
    if (P.type !== "MemberExpression") return !1;
    const { computed: r, property: a } = P;
    return (!r || a.type === "StringLiteral" || !(a.type !== "TemplateLiteral" || a.expressions.length > 0)) && Qu(P.object);
  }
  function yT(P, r) {
    var a;
    const { type: u } = P;
    if ((a = P.extra) != null && a.parenthesized) return !1;
    if (r) {
      if (u === "Literal") {
        const { value: T } = P;
        if (typeof T == "string" || typeof T == "boolean") return !0;
      }
    } else if (u === "StringLiteral" || u === "BooleanLiteral") return !0;
    return !(!Yu(P, r) && !(function(T, S) {
      if (T.type === "UnaryExpression") {
        const { operator: _, argument: I } = T;
        if (_ === "-" && Yu(I, S)) return !0;
      }
      return !1;
    })(P, r)) || u === "TemplateLiteral" && P.expressions.length === 0 || !!gT(P);
  }
  function Yu(P, r) {
    return r ? P.type === "Literal" && (typeof P.value == "number" || "bigint" in P) : P.type === "NumericLiteral" || P.type === "BigIntLiteral";
  }
  function Qu(P) {
    return P.type === "Identifier" || P.type === "MemberExpression" && !P.computed && Qu(P.object);
  }
  const Zu = v`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), e1 = ["minimal", "fsharp", "hack", "smart"], t1 = ["^^", "@@", "^", "%", "#"], r1 = { estree: (P) => class extends P {
    parse() {
      const r = C(super.parse());
      return 256 & this.optionFlags && (r.tokens = r.tokens.map(C)), r;
    }
    parseRegExpLiteral({ pattern: r, flags: a }) {
      let u = null;
      try {
        u = new RegExp(r, a);
      } catch {
      }
      const T = this.estreeParseLiteral(u);
      return T.regex = { pattern: r, flags: a }, T;
    }
    parseBigIntLiteral(r) {
      let a;
      try {
        a = BigInt(r);
      } catch {
        a = null;
      }
      const u = this.estreeParseLiteral(a);
      return u.bigint = String(u.value || r), u;
    }
    parseDecimalLiteral(r) {
      const a = this.estreeParseLiteral(null);
      return a.decimal = String(a.value || r), a;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    estreeParseChainExpression(r, a) {
      const u = this.startNodeAtNode(r);
      return u.expression = r, this.finishNodeAt(u, "ChainExpression", a);
    }
    directiveToStmt(r) {
      const a = r.value;
      delete r.value, this.castNodeTo(a, "Literal"), a.raw = a.extra.raw, a.value = a.extra.expressionValue;
      const u = this.castNodeTo(r, "ExpressionStatement");
      return u.expression = a, u.directive = a.extra.rawValue, delete a.extra, u;
    }
    fillOptionalPropertiesForTSESLint(r) {
    }
    cloneEstreeStringLiteral(r) {
      const { start: a, end: u, loc: T, range: S, raw: _, value: I } = r, R = Object.create(r.constructor.prototype);
      return R.type = "Literal", R.start = a, R.end = u, R.loc = T, R.range = S, R.raw = _, R.value = I, R;
    }
    initFunction(r, a) {
      super.initFunction(r, a), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var a;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((a = r.expression.extra) != null && a.parenthesized);
    }
    parseBlockBody(r, a, u, T, S) {
      super.parseBlockBody(r, a, u, T, S);
      const _ = r.directives.map((I) => this.directiveToStmt(I));
      r.body = _.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      const r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      const a = super.getPrivateNameSV(r);
      return delete r.id, r.name = a, this.castNodeTo(r, "PrivateIdentifier");
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, a) {
      const u = super.parseLiteral(r, a);
      return u.raw = u.extra.raw, delete u.extra, u;
    }
    parseFunctionBody(r, a, u = !1) {
      super.parseFunctionBody(r, a, u), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, a, u, T, S, _, I = !1) {
      let R = this.startNode();
      R.kind = r.kind, R = super.parseMethod(R, a, u, T, S, _, I), delete R.kind;
      const { typeParameters: M } = r;
      M && (delete r.typeParameters, R.typeParameters = M, this.resetStartLocationFromNode(R, M));
      const K = this.castNodeTo(R, "FunctionExpression");
      return r.value = K, _ === "ClassPrivateMethod" && (r.computed = !1), _ === "ObjectMethod" ? (r.kind === "method" && (r.kind = "init"), r.shorthand = !1, this.finishNode(r, "Property")) : this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      const a = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(a, "PropertyDefinition"), a;
    }
    parseClassPrivateProperty(...r) {
      const a = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(a, "PropertyDefinition"), a.computed = !1), a;
    }
    parseClassAccessorProperty(r) {
      const a = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (a.abstract && this.hasPlugin("typescript") ? (delete a.abstract, this.castNodeTo(a, "TSAbstractAccessorProperty")) : this.castNodeTo(a, "AccessorProperty")), a;
    }
    parseObjectProperty(r, a, u, T) {
      const S = super.parseObjectProperty(r, a, u, T);
      return S && (S.kind = "init", this.castNodeTo(S, "Property")), S;
    }
    finishObjectProperty(r) {
      return r.kind = "init", this.finishNode(r, "Property");
    }
    isValidLVal(r, a, u) {
      return r === "Property" ? "value" : super.isValidLVal(r, a, u);
    }
    isAssignable(r, a) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, a) : super.isAssignable(r, a);
    }
    toAssignable(r, a = !1) {
      if (r != null && this.isObjectProperty(r)) {
        const { key: u, value: T } = r;
        this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(T, a);
      } else super.toAssignable(r, a);
    }
    toAssignableObjectExpressionProp(r, a, u) {
      r.type !== "Property" || r.kind !== "get" && r.kind !== "set" ? r.type === "Property" && r.method ? this.raise(b.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, a, u) : this.raise(b.PatternHasAccessor, r.key);
    }
    finishCallExpression(r, a) {
      const u = super.finishCallExpression(r, a);
      var T, S;
      return u.callee.type === "Import" ? (this.castNodeTo(u, "ImportExpression"), u.source = u.arguments[0], u.options = (T = u.arguments[1]) != null ? T : null, u.attributes = (S = u.arguments[1]) != null ? S : null, delete u.arguments, delete u.callee) : u.type === "OptionalCallExpression" ? this.castNodeTo(u, "CallExpression") : u.optional = !1, u;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, a) {
      const u = this.state.lastTokStartLoc, T = super.parseExport(r, a);
      switch (T.type) {
        case "ExportAllDeclaration":
          T.exported = null;
          break;
        case "ExportNamedDeclaration":
          T.specifiers.length === 1 && T.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(T, "ExportAllDeclaration"), T.exported = T.specifiers[0].exported, delete T.specifiers);
        case "ExportDefaultDeclaration": {
          var S;
          const { declaration: _ } = T;
          _?.type === "ClassDeclaration" && ((S = _.decorators) == null ? void 0 : S.length) > 0 && _.start === T.start && this.resetStartLocation(T, u);
        }
      }
      return T;
    }
    stopParseSubscript(r, a) {
      const u = super.stopParseSubscript(r, a);
      return a.optionalChainMember ? this.estreeParseChainExpression(u, r.loc.end) : u;
    }
    parseMember(r, a, u, T, S) {
      const _ = super.parseMember(r, a, u, T, S);
      return _.type === "OptionalMemberExpression" ? this.castNodeTo(_, "MemberExpression") : _.optional = !1, _;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    castNodeTo(r, a) {
      const u = super.castNodeTo(r, a);
      return this.fillOptionalPropertiesForTSESLint(u), u;
    }
    cloneIdentifier(r) {
      const a = super.cloneIdentifier(r);
      return this.fillOptionalPropertiesForTSESLint(a), a;
    }
    cloneStringLiteral(r) {
      return r.type === "Literal" ? this.cloneEstreeStringLiteral(r) : super.cloneStringLiteral(r);
    }
    finishNodeAt(r, a, u) {
      return C(super.finishNodeAt(r, a, u));
    }
    finishNode(r, a) {
      const u = super.finishNode(r, a);
      return this.fillOptionalPropertiesForTSESLint(u), u;
    }
    resetStartLocation(r, a) {
      super.resetStartLocation(r, a), C(r);
    }
    resetEndLocation(r, a = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, a), C(r);
    }
  }, jsx: (P) => class extends P {
    jsxReadToken() {
      let r = "", a = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(as.UnterminatedJsxContent, this.state.startLoc);
        const u = this.input.charCodeAt(this.state.pos);
        switch (u) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? void (u === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(u)) : (r += this.input.slice(a, this.state.pos), void this.finishToken(142, r));
          case 38:
            r += this.input.slice(a, this.state.pos), r += this.jsxReadEntity(), a = this.state.pos;
            break;
          default:
            Ds(u) ? (r += this.input.slice(a, this.state.pos), r += this.jsxReadNewLine(!0), a = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      const a = this.input.charCodeAt(this.state.pos);
      let u;
      return ++this.state.pos, a === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, u = r ? `
` : `\r
`) : u = String.fromCharCode(a), ++this.state.curLine, this.state.lineStart = this.state.pos, u;
    }
    jsxReadString(r) {
      let a = "", u = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(b.UnterminatedString, this.state.startLoc);
        const T = this.input.charCodeAt(this.state.pos);
        if (T === r) break;
        T === 38 ? (a += this.input.slice(u, this.state.pos), a += this.jsxReadEntity(), u = this.state.pos) : Ds(T) ? (a += this.input.slice(u, this.state.pos), a += this.jsxReadNewLine(!1), u = this.state.pos) : ++this.state.pos;
      }
      a += this.input.slice(u, this.state.pos++), this.finishToken(134, a);
    }
    jsxReadEntity() {
      const r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let a = 10;
        this.codePointAtPos(this.state.pos) === 120 && (a = 16, ++this.state.pos);
        const u = this.readInt(a, void 0, !1, "bail");
        if (u !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(u);
      } else {
        let a = 0, u = !1;
        for (; a++ < 10 && this.state.pos < this.length && !(u = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
        if (u) {
          const T = this.input.slice(r, this.state.pos), S = Y0[T];
          if (++this.state.pos, S) return S;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r;
      const a = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Fr(r) || r === 45);
      this.finishToken(141, this.input.slice(a, this.state.pos));
    }
    jsxParseIdentifier() {
      const r = this.startNode();
      return this.match(141) ? r.name = this.state.value : Ee(this.state.type) ? r.name = me(this.state.type) : this.unexpected(), this.next(), this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const r = this.state.startLoc, a = this.jsxParseIdentifier();
      if (!this.eat(14)) return a;
      const u = this.startNodeAt(r);
      return u.namespace = a, u.name = this.jsxParseIdentifier(), this.finishNode(u, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const r = this.state.startLoc;
      let a = this.jsxParseNamespacedName();
      if (a.type === "JSXNamespacedName") return a;
      for (; this.eat(16); ) {
        const u = this.startNodeAt(r);
        u.object = a, u.property = this.jsxParseIdentifier(), a = this.finishNode(u, "JSXMemberExpression");
      }
      return a;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(O.brace), this.next(), r = this.jsxParseExpressionContainer(r, O.j_oTag), r.expression.type === "JSXEmptyExpression" && this.raise(as.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(as.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(O.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, a) {
      if (this.match(8)) r.expression = this.jsxParseEmptyExpression();
      else {
        const u = this.parseExpression();
        r.expression = u;
      }
      return this.setContext(a), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const r = this.startNode();
      return this.match(5) ? (this.setContext(O.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(O.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(), r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      const a = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(a, "JSXOpeningFragment") : (a.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(a));
    }
    jsxParseOpeningElementAfterName(r) {
      const a = [];
      for (; !this.match(56) && !this.match(144); ) a.push(this.jsxParseAttribute());
      return r.attributes = a, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      const a = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(a, "JSXClosingFragment") : (a.name = this.jsxParseElementName(), this.expect(144), this.finishNode(a, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      const a = this.startNodeAt(r), u = [], T = this.jsxParseOpeningElementAt(r);
      let S = null;
      if (!T.selfClosing) {
        e: for (; ; ) switch (this.state.type) {
          case 143:
            if (r = this.state.startLoc, this.next(), this.eat(56)) {
              S = this.jsxParseClosingElementAt(r);
              break e;
            }
            u.push(this.jsxParseElementAt(r));
            break;
          case 142:
            u.push(this.parseLiteral(this.state.value, "JSXText"));
            break;
          case 5: {
            const _ = this.startNode();
            this.setContext(O.brace), this.next(), this.match(21) ? u.push(this.jsxParseSpreadChild(_)) : u.push(this.jsxParseExpressionContainer(_, O.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
        jr(T) && !jr(S) && S !== null ? this.raise(as.MissingClosingTagFragment, S) : !jr(T) && jr(S) ? this.raise(as.MissingClosingTagElement, S, { openingTagName: Fs(T.name) }) : jr(T) || jr(S) || Fs(S.name) !== Fs(T.name) && this.raise(as.MissingClosingTagElement, S, { openingTagName: Fs(T.name) });
      }
      if (jr(T) ? (a.openingFragment = T, a.closingFragment = S) : (a.openingElement = T, a.closingElement = S), a.children = u, this.match(47)) throw this.raise(as.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return jr(T) ? this.finishNode(a, "JSXFragment") : this.finishNode(a, "JSXElement");
    }
    jsxParseElement() {
      const r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      const { context: a } = this.state;
      a[a.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      const a = this.curContext();
      if (a !== O.j_expr) {
        if (a === O.j_oTag || a === O.j_cTag) {
          if (er(r)) return void this.jsxReadWord();
          if (r === 62) return ++this.state.pos, void this.finishToken(144);
          if ((r === 34 || r === 39) && a === O.j_oTag) return void this.jsxReadString(r);
        }
        if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) return ++this.state.pos, void this.finishToken(143);
        super.getTokenFromCode(r);
      } else this.jsxReadToken();
    }
    updateContext(r) {
      const { context: a, type: u } = this.state;
      if (u === 56 && r === 143) a.splice(-2, 2, O.j_cTag), this.state.canStartJSXElement = !1;
      else if (u === 143) a.push(O.j_oTag);
      else if (u === 144) {
        const T = a[a.length - 1];
        T === O.j_oTag && r === 56 || T === O.j_cTag ? (a.pop(), this.state.canStartJSXElement = a[a.length - 1] === O.j_expr) : (this.setContext(O.j_expr), this.state.canStartJSXElement = !0);
      } else this.state.canStartJSXElement = Q[u];
    }
  }, flow: (P) => class extends P {
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return G0;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, a) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, a);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        const a = J0.exec(r.value);
        if (a) if (a[1] === "flow") this.flowPragma = "flow";
        else {
          if (a[1] !== "noflow") throw new Error("Unexpected flow pragma");
          this.flowPragma = "noflow";
        }
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      const a = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      const u = this.flowParseType();
      return this.state.inType = a, u;
    }
    flowParsePredicate() {
      const r = this.startNode(), a = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > a.index + 1 && this.raise(Se.UnexpectedSpaceBetweenModuloChecks, a), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let a = null, u = null;
      return this.match(54) ? (this.state.inType = r, u = this.flowParsePredicate()) : (a = this.flowParseType(), this.state.inType = r, this.match(54) && (u = this.flowParsePredicate())), [a, u];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      const a = r.id = this.parseIdentifier(), u = this.startNode(), T = this.startNode();
      this.match(47) ? u.typeParameters = this.flowParseTypeParameterDeclaration() : u.typeParameters = null, this.expect(10);
      const S = this.flowParseFunctionTypeParams();
      return u.params = S.params, u.rest = S.rest, u.this = S._this, this.expect(11), [u.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), T.typeAnnotation = this.finishNode(u, "FunctionTypeAnnotation"), a.typeAnnotation = this.finishNode(T, "TypeAnnotation"), this.resetEndLocation(a), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, a) {
      return this.match(80) ? this.flowParseDeclareClass(r) : this.match(68) ? this.flowParseDeclareFunction(r) : this.match(74) ? this.flowParseDeclareVariable(r) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(r) : (a && this.raise(Se.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(r)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(r) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(r) : this.isContextual(129) ? this.flowParseDeclareInterface(r) : this.match(82) ? this.flowParseDeclareExportDeclaration(r, a) : void this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(), this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      const a = r.body = this.startNode(), u = a.body = [];
      for (this.expect(5); !this.match(8); ) {
        let _ = this.startNode();
        this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(Se.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(_)) : (this.expectContextual(125, Se.UnsupportedStatementInDeclareModule), _ = this.flowParseDeclare(_, !0)), u.push(_);
      }
      this.scope.exit(), this.expect(8), this.finishNode(a, "BlockStatement");
      let T = null, S = !1;
      return u.forEach((_) => {
        (function(I) {
          return I.type === "DeclareExportAllDeclaration" || I.type === "DeclareExportDeclaration" && (!I.declaration || I.declaration.type !== "TypeAlias" && I.declaration.type !== "InterfaceDeclaration");
        })(_) ? (T === "CommonJS" && this.raise(Se.AmbiguousDeclareModuleKind, _), T = "ES") : _.type === "DeclareModuleExports" && (S && this.raise(Se.DuplicateDeclareModuleExports, _), T === "ES" && this.raise(Se.AmbiguousDeclareModuleKind, _), T = "CommonJS", S = !0);
      }), r.kind = T || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, a) {
      if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(), this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !a) {
        const u = this.state.value;
        throw this.raise(Se.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: u, suggestion: K0[u] });
      }
      return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? (r = this.parseExport(r, null)).type === "ExportNamedDeclaration" ? (r.default = !1, delete r.exportKind, this.castNodeTo(r, "DeclareExportDeclaration")) : this.castNodeTo(r, "DeclareExportAllDeclaration") : void this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      const a = this.flowParseTypeAlias(r);
      return this.castNodeTo(a, "DeclareTypeAlias"), a;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      const a = this.flowParseOpaqueType(r, !0);
      return this.castNodeTo(a, "DeclareOpaqueType"), a;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, a) {
      if (r.id = this.flowParseRestrictedIdentifier(!a, !0), this.scope.declareName(r.id.name, a ? 17 : 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81)) do
        r.extends.push(this.flowParseInterfaceExtends());
      while (!a && this.eat(12));
      if (a) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117)) do
          r.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
        if (this.eatContextual(113)) do
          r.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      r.body = this.flowParseObjectType({ allowStatic: a, allowExact: !1, allowSpread: !1, allowProto: a, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      const r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Se.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, a, u) {
      X0.has(r) && this.raise(u ? Se.AssignReservedType : Se.UnexpectedReservedType, a, { reservedType: r });
    }
    flowParseRestrictedIdentifier(r, a) {
      return this.checkReservedType(this.state.value, this.state.startLoc, a), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, a) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, a || (r.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      const a = this.state.startLoc, u = this.startNode(), T = this.flowParseVariance(), S = this.flowParseTypeAnnotatableIdentifier();
      return u.name = S.name, u.variance = T, u.bound = S.typeAnnotation, this.match(29) ? (this.eat(29), u.default = this.flowParseType()) : r && this.raise(Se.MissingTypeParamDefault, a), this.finishNode(u, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const r = this.state.inType, a = this.startNode();
      a.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let u = !1;
      do {
        const T = this.flowParseTypeParameter(u);
        a.params.push(T), T.default && (u = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(a, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() === O.brace) return r();
      {
        const a = this.state.context;
        this.state.context = [a[0]];
        try {
          return r();
        } finally {
          this.state.context = a;
        }
      }
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47) return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      const r = this.startNode(), a = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        const u = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); ) r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = u;
      }), this.state.inType = a, this.state.inType || this.curContext() !== O.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      const r = this.startNode(), a = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = a, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81)) do
        r.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
      return r.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, a, u) {
      return r.static = a, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) : (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = u, this.finishNode(r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, a) {
      return r.static = a, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method = !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(), this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, a) {
      const u = this.startNode();
      return r.static = a, r.value = this.flowParseObjectTypeMethodish(u), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: r, allowExact: a, allowSpread: u, allowProto: T, allowInexact: S }) {
      const _ = this.state.inType;
      this.state.inType = !0;
      const I = this.startNode();
      let R, M;
      I.callProperties = [], I.properties = [], I.indexers = [], I.internalSlots = [];
      let K = !1;
      for (a && this.match(6) ? (this.expect(6), R = 9, M = !0) : (this.expect(5), R = 8, M = !1), I.exact = M; !this.match(R); ) {
        let ve = !1, de = null, Pe = null;
        const He = this.startNode();
        if (T && this.isContextual(118)) {
          const Re = this.lookahead();
          Re.type !== 14 && Re.type !== 17 && (this.next(), de = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          const Re = this.lookahead();
          Re.type !== 14 && Re.type !== 17 && (this.next(), ve = !0);
        }
        const ct = this.flowParseVariance();
        if (this.eat(0)) de != null && this.unexpected(de), this.eat(0) ? (ct && this.unexpected(ct.loc.start), I.internalSlots.push(this.flowParseObjectTypeInternalSlot(He, ve))) : I.indexers.push(this.flowParseObjectTypeIndexer(He, ve, ct));
        else if (this.match(10) || this.match(47)) de != null && this.unexpected(de), ct && this.unexpected(ct.loc.start), I.callProperties.push(this.flowParseObjectTypeCallProperty(He, ve));
        else {
          let Re = "init";
          (this.isContextual(99) || this.isContextual(104)) && ie(this.lookahead().type) && (Re = this.state.value, this.next());
          const nt = this.flowParseObjectTypeProperty(He, ve, de, ct, Re, u, S ?? !M);
          nt === null ? (K = !0, Pe = this.state.lastTokStartLoc) : I.properties.push(nt);
        }
        this.flowObjectTypeSemicolon(), !Pe || this.match(8) || this.match(9) || this.raise(Se.UnexpectedExplicitInexactInObject, Pe);
      }
      this.expect(R), u && (I.inexact = K);
      const ne = this.finishNode(I, "ObjectTypeAnnotation");
      return this.state.inType = _, ne;
    }
    flowParseObjectTypeProperty(r, a, u, T, S, _, I) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (_ ? I || this.raise(Se.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(Se.InexactInsideNonObject, this.state.lastTokStartLoc), T && this.raise(Se.InexactVariance, T), null) : (_ || this.raise(Se.UnexpectedSpreadType, this.state.lastTokStartLoc), u != null && this.unexpected(u), T && this.raise(Se.SpreadVariance, T), r.argument = this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = a, r.proto = u != null, r.kind = S;
        let R = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, u != null && this.unexpected(u), T && this.unexpected(T.loc.start), r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), S !== "get" && S !== "set" || this.flowCheckGetterSetterParams(r), !_ && r.key.name === "constructor" && r.value.this && this.raise(Se.ThisParamBannedInConstructor, r.value.this)) : (S !== "init" && this.unexpected(), r.method = !1, this.eat(17) && (R = !0), r.value = this.flowParseTypeInitialiser(), r.variance = T), r.optional = R, this.finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      const a = r.kind === "get" ? 0 : 1, u = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Se.GetterMayNotHaveThisParam : Se.SetterMayNotHaveThisParam, r.value.this), u !== a && this.raise(r.kind === "get" ? b.BadGetterArity : b.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(b.BadSetterRestParameter, r);
    }
    flowObjectTypeSemicolon() {
      this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, a) {
      r != null || (r = this.state.startLoc);
      let u = a || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        const T = this.startNodeAt(r);
        T.qualification = u, T.id = this.flowParseRestrictedIdentifier(!0), u = this.finishNode(T, "QualifiedTypeIdentifier");
      }
      return u;
    }
    flowParseGenericType(r, a) {
      const u = this.startNodeAt(r);
      return u.typeParameters = null, u.id = this.flowParseQualifiedTypeIdentifier(r, a), this.match(47) && (u.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(u, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let a = null, u = !1, T = null;
      const S = this.startNode(), _ = this.lookahead(), I = this.state.type === 78;
      return _.type === 14 || _.type === 17 ? (I && !r && this.raise(Se.ThisParamMustBeFirst, S), a = this.parseIdentifier(I), this.eat(17) && (u = !0, I && this.raise(Se.ThisParamMayNotBeOptional, S)), T = this.flowParseTypeInitialiser()) : T = this.flowParseType(), S.name = a, S.optional = u, S.typeAnnotation = T, this.finishNode(S, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      const a = this.startNodeAt(r.loc.start);
      return a.name = null, a.optional = !1, a.typeAnnotation = r, this.finishNode(a, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let a = null, u = null;
      for (this.match(78) && (u = this.flowParseFunctionTypeParam(!0), u.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (a = this.flowParseFunctionTypeParam(!1)), { params: r, rest: a, _this: u };
    }
    flowIdentToTypeAnnotation(r, a, u) {
      switch (u.name) {
        case "any":
          return this.finishNode(a, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(a, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(a, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(a, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(a, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(a, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(a, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(u.name), this.flowParseGenericType(r, u);
      }
    }
    flowParsePrimaryType() {
      const r = this.state.startLoc, a = this.startNode();
      let u, T, S = !1;
      const _ = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, T = this.flowParseTupleType(), this.state.noAnonFunctionType = _, T;
        case 47: {
          const I = this.startNode();
          return I.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), u = this.flowParseFunctionTypeParams(), I.params = u.params, I.rest = u.rest, I.this = u._this, this.expect(11), this.expect(19), I.returnType = this.flowParseType(), this.finishNode(I, "FunctionTypeAnnotation");
        }
        case 10: {
          const I = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21)) if (se(this.state.type) || this.match(78)) {
            const R = this.lookahead().type;
            S = R !== 17 && R !== 14;
          } else S = !0;
          if (S) {
            if (this.state.noAnonFunctionType = !1, T = this.flowParseType(), this.state.noAnonFunctionType = _, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), T;
            this.eat(12);
          }
          return u = T ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(T)]) : this.flowParseFunctionTypeParams(), I.params = u.params, I.rest = u.rest, I.this = u._this, this.expect(11), this.expect(19), I.returnType = this.flowParseType(), I.typeParameters = null, this.finishNode(I, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return a.value = this.match(85), this.next(), this.finishNode(a, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", a);
            if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", a);
            throw this.raise(Se.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          return void this.unexpected();
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(a, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(a, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(a, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(a, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ee(this.state.type)) {
            const I = me(this.state.type);
            return this.next(), super.createIdentifier(a, I);
          }
          if (se(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, a, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const r = this.state.startLoc;
      let a = this.flowParsePrimaryType(), u = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const T = this.startNodeAt(r), S = this.eat(18);
        u = u || S, this.expect(0), !S && this.match(3) ? (T.elementType = a, this.next(), a = this.finishNode(T, "ArrayTypeAnnotation")) : (T.objectType = a, T.indexType = this.flowParseType(), this.expect(3), u ? (T.optional = S, a = this.finishNode(T, "OptionalIndexedAccessType")) : a = this.finishNode(T, "IndexedAccessType"));
      }
      return a;
    }
    flowParsePrefixType() {
      const r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const a = this.startNodeAt(r.loc.start);
        return a.params = [this.reinterpretTypeAsFunctionTypeParam(r)], a.rest = null, a.this = null, a.returnType = this.flowParseType(), a.typeParameters = null, this.finishNode(a, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      const r = this.startNode();
      this.eat(45);
      const a = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [a]; this.eat(45); ) r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? a : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const r = this.startNode();
      this.eat(43);
      const a = this.flowParseIntersectionType();
      for (r.types = [a]; this.eat(43); ) r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? a : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      const r = this.state.inType;
      this.state.inType = !0;
      const a = this.flowParseUnionType();
      return this.state.inType = r, a;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const r = this.state.startLoc, a = this.parseIdentifier();
        return this.flowParseGenericType(r, a);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      const a = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (a.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(a)), a;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(r, "Variance")) : r;
    }
    parseFunctionBody(r, a, u = !1) {
      a ? this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, u)) : super.parseFunctionBody(r, !1, u);
    }
    parseFunctionBodyAndFinish(r, a, u = !1) {
      if (this.match(14)) {
        const T = this.startNode();
        [T.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = T.typeAnnotation ? this.finishNode(T, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, a, u);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        if (z(this.lookahead().type)) {
          const u = this.startNode();
          return this.next(), this.flowParseInterface(u);
        }
      } else if (this.isContextual(126)) {
        const u = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(u);
      }
      const a = super.parseStatementLike(r);
      return this.flowPragma !== void 0 || this.isValidDirective(a) || (this.flowPragma = null), a;
    }
    parseExpressionStatement(r, a, u) {
      if (a.type === "Identifier") {
        if (a.name === "declare") {
          if (this.match(80) || se(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(r);
        } else if (se(this.state.type)) {
          if (a.name === "interface") return this.flowParseInterface(r);
          if (a.name === "type") return this.flowParseTypeAlias(r);
          if (a.name === "opaque") return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, a, u);
    }
    shouldParseExportDeclaration() {
      const { type: r } = this.state;
      return r === 126 || ge(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const { type: r } = this.state;
      return r === 126 || ge(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        const r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, a, u) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        const ne = this.lookaheadCharCode();
        if (ne === 44 || ne === 61 || ne === 58 || ne === 41) return this.setOptionalParametersError(u), r;
      }
      this.expect(17);
      const T = this.state.clone(), S = this.state.noArrowAt, _ = this.startNodeAt(a);
      let { consequent: I, failed: R } = this.tryParseConditionalConsequent(), [M, K] = this.getArrowLikeExpressions(I);
      if (R || K.length > 0) {
        const ne = [...S];
        if (K.length > 0) {
          this.state = T, this.state.noArrowAt = ne;
          for (let ve = 0; ve < K.length; ve++) ne.push(K[ve].start);
          ({ consequent: I, failed: R } = this.tryParseConditionalConsequent()), [M, K] = this.getArrowLikeExpressions(I);
        }
        R && M.length > 1 && this.raise(Se.AmbiguousConditionalArrow, T.startLoc), R && M.length === 1 && (this.state = T, ne.push(M[0].start), this.state.noArrowAt = ne, { consequent: I, failed: R } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(I, !0), this.state.noArrowAt = S, this.expect(14), _.test = r, _.consequent = I, _.alternate = this.forwardNoArrowParamsConversionAt(_, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(_, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const r = this.parseMaybeAssignAllowIn(), a = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: r, failed: a };
    }
    getArrowLikeExpressions(r, a) {
      const u = [r], T = [];
      for (; u.length !== 0; ) {
        const S = u.pop();
        S.type === "ArrowFunctionExpression" && S.body.type !== "BlockStatement" ? (S.typeParameters || !S.returnType ? this.finishArrowValidation(S) : T.push(S), u.push(S.body)) : S.type === "ConditionalExpression" && (u.push(S.consequent), u.push(S.alternate));
      }
      return a ? (T.forEach((S) => this.finishArrowValidation(S)), [T, []]) : (function(S, _) {
        const I = [], R = [];
        for (let M = 0; M < S.length; M++) (_(S[M], M, S) ? I : R).push(S[M]);
        return [I, R];
      })(T, (S) => S.params.every((_) => this.isAssignable(_, !0)));
    }
    finishArrowValidation(r) {
      var a;
      this.toAssignableList(r.params, (a = r.extra) == null ? void 0 : a.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(r, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, a) {
      let u;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), u = a(), this.state.noArrowParamsConversionAt.pop()) : u = a(), u;
    }
    parseParenItem(r, a) {
      const u = super.parseParenItem(r, a);
      if (this.eat(17) && (u.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        const T = this.startNodeAt(a);
        return T.expression = u, T.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(T, "TypeCastExpression");
      }
      return u;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind === "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        const a = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(a);
      }
      if (this.isContextual(131)) {
        r.exportKind = "type";
        const a = this.startNode();
        return this.next(), this.flowParseOpaqueType(a, !1);
      }
      if (this.isContextual(129)) {
        r.exportKind = "type";
        const a = this.startNode();
        return this.next(), this.flowParseInterface(a);
      }
      if (this.isContextual(126)) {
        r.exportKind = "value";
        const a = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(a);
      }
      return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return !!super.eatExportStar(r) || !(!this.isContextual(130) || this.lookahead().type !== 55) && (r.exportKind = "type", this.next(), this.next(), !0);
    }
    maybeParseExportNamespaceSpecifier(r) {
      const { startLoc: a } = this.state, u = super.maybeParseExportNamespaceSpecifier(r);
      return u && r.exportKind === "type" && this.unexpected(a), u;
    }
    parseClassId(r, a, u) {
      super.parseClassId(r, a, u), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, a, u) {
      const { startLoc: T } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, a)) return;
        a.declare = !0;
      }
      super.parseClassMember(r, a, u), a.declare && (a.type !== "ClassProperty" && a.type !== "ClassPrivateProperty" && a.type !== "PropertyDefinition" ? this.raise(Se.DeclareClassElement, T) : a.value && this.raise(Se.DeclareClassFieldInitializer, a.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      const r = super.readWord1(), a = "@@" + r;
      this.isIterator(r) && this.state.inType || this.raise(b.InvalidIdentifier, this.state.curPosition(), { identifierName: a }), this.finishToken(132, a);
    }
    getTokenFromCode(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && a === 124 ? this.finishOp(6, 2) : !this.state.inType || r !== 62 && r !== 60 ? this.state.inType && r === 63 ? a === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : (function(u, T, S) {
        return u === 64 && T === 64 && er(S);
      })(r, a, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r) : this.finishOp(r === 62 ? 48 : 47, 1);
    }
    isAssignable(r, a) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, a) : super.isAssignable(r, a);
    }
    toAssignable(r, a = !1) {
      a || r.type !== "AssignmentExpression" || r.left.type !== "TypeCastExpression" || (r.left = this.typeCastToParameter(r.left)), super.toAssignable(r, a);
    }
    toAssignableList(r, a, u) {
      for (let T = 0; T < r.length; T++) {
        const S = r[T];
        S?.type === "TypeCastExpression" && (r[T] = this.typeCastToParameter(S));
      }
      super.toAssignableList(r, a, u);
    }
    toReferencedList(r, a) {
      for (let T = 0; T < r.length; T++) {
        var u;
        const S = r[T];
        !S || S.type !== "TypeCastExpression" || (u = S.extra) != null && u.parenthesized || !(r.length > 1) && a || this.raise(Se.TypeCastInPattern, S.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, a, u, T) {
      const S = super.parseArrayLike(r, a, u, T);
      return a && !this.state.maybeInArrowParameters && this.toReferencedList(S.elements), S;
    }
    isValidLVal(r, a, u) {
      return r === "TypeCastExpression" || super.isValidLVal(r, a, u);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, a, u, T, S, _) {
      if (a.variance && this.unexpected(a.variance.loc.start), delete a.variance, this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(r, a, u, T, S, _), a.params && S) {
        const I = a.params;
        I.length > 0 && this.isThisParam(I[0]) && this.raise(Se.ThisParamBannedInConstructor, a);
      } else if (a.type === "MethodDefinition" && S && a.value.params) {
        const I = a.value.params;
        I.length > 0 && this.isThisParam(I[0]) && this.raise(Se.ThisParamBannedInConstructor, a);
      }
    }
    pushClassPrivateMethod(r, a, u, T) {
      a.variance && this.unexpected(a.variance.loc.start), delete a.variance, this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(r, a, u, T);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
        this.next();
        const a = r.implements = [];
        do {
          const u = this.startNode();
          u.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? u.typeParameters = this.flowParseTypeParameterInstantiation() : u.typeParameters = null, a.push(this.finishNode(u, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      const a = this.getObjectOrClassMethodParams(r);
      if (a.length > 0) {
        const u = a[0];
        this.isThisParam(u) && r.kind === "get" ? this.raise(Se.GetterMayNotHaveThisParam, u) : this.isThisParam(u) && this.raise(Se.SetterMayNotHaveThisParam, u);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, a, u, T, S, _, I) {
      let R;
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance, this.match(47) && !_ && (R = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const M = super.parseObjPropValue(r, a, u, T, S, _, I);
      return R && ((M.value || M).typeParameters = R), M;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Se.PatternIsOptional, r), this.isThisParam(r) && this.raise(Se.ThisParamMayNotBeOptional, r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Se.ThisParamAnnotationRequired, r), this.match(29) && this.isThisParam(r) && this.raise(Se.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, a) {
      const u = super.parseMaybeDefault(r, a);
      return u.type === "AssignmentPattern" && u.typeAnnotation && u.right.start < u.typeAnnotation.start && this.raise(Se.TypeBeforeInitializer, u.typeAnnotation), u;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Se.ImportReflectionHasImportType, r.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(r, a, u) {
      a.local = Bu(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(a, u));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        const a = this.lookaheadCharCode();
        return a === 123 || a === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, a, u, T) {
      if (super.applyImportPhase(r, a, u, T), a) {
        if (!u && this.match(65)) return;
        r.exportKind = u === "type" ? u : "value";
      } else u === "type" && this.match(55) && this.unexpected(), r.importKind = u === "type" || u === "typeof" ? u : "value";
    }
    parseImportSpecifier(r, a, u, T, S) {
      const _ = r.imported;
      let I = null;
      _.type === "Identifier" && (_.name === "type" ? I = "type" : _.name === "typeof" && (I = "typeof"));
      let R = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const K = this.parseIdentifier(!0);
        I === null || z(this.state.type) ? (r.imported = _, r.importKind = null, r.local = this.parseIdentifier()) : (r.imported = K, r.importKind = I, r.local = this.cloneIdentifier(K));
      } else {
        if (I !== null && z(this.state.type)) r.imported = this.parseIdentifier(!0), r.importKind = I;
        else {
          if (a) throw this.raise(b.ImportBindingIsString, r, { importName: _.value });
          r.imported = _, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (R = !0, r.local = this.cloneIdentifier(r.imported));
      }
      const M = Bu(r);
      return u && M && this.raise(Se.ImportTypeShorthandOnlyInPureImport, r), (u || M) && this.checkReservedType(r.local.name, r.local.loc.start, !0), !R || u || M || this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseFunctionParams(r, a) {
      const u = r.kind;
      u !== "get" && u !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(r, a);
    }
    parseVarId(r, a) {
      super.parseVarId(r, a), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, a) {
      if (this.match(14)) {
        const u = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = u;
      }
      return super.parseAsyncArrowFromCallExpression(r, a);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, a) {
      var u;
      let T, S = null;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (S = this.state.clone(), T = this.tryParse(() => super.parseMaybeAssign(r, a), S), !T.error) return T.node;
        const { context: R } = this.state, M = R[R.length - 1];
        M !== O.j_oTag && M !== O.j_expr || R.pop();
      }
      if ((u = T) != null && u.error || this.match(47)) {
        var _, I;
        let R;
        S = S || this.state.clone();
        const M = this.tryParse((ne) => {
          var ve;
          R = this.flowParseTypeParameterDeclaration();
          const de = this.forwardNoArrowParamsConversionAt(R, () => {
            const He = super.parseMaybeAssign(r, a);
            return this.resetStartLocationFromNode(He, R), He;
          });
          (ve = de.extra) != null && ve.parenthesized && ne();
          const Pe = this.maybeUnwrapTypeCastExpression(de);
          return Pe.type !== "ArrowFunctionExpression" && ne(), Pe.typeParameters = R, this.resetStartLocationFromNode(Pe, R), de;
        }, S);
        let K = null;
        if (M.node && this.maybeUnwrapTypeCastExpression(M.node).type === "ArrowFunctionExpression") {
          if (!M.error && !M.aborted) return M.node.async && this.raise(Se.UnexpectedTypeParameterBeforeAsyncArrowFunction, R), M.node;
          K = M.node;
        }
        if ((_ = T) != null && _.node) return this.state = T.failState, T.node;
        if (K) return this.state = M.failState, K;
        throw (I = T) != null && I.thrown ? T.error : M.thrown ? M.error : this.raise(Se.UnexpectedTokenAfterTypeParameter, R);
      }
      return super.parseMaybeAssign(r, a);
    }
    parseArrow(r) {
      if (this.match(14)) {
        const a = this.tryParse(() => {
          const u = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const T = this.startNode();
          return [T.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = u, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), T;
        });
        if (a.thrown) return null;
        a.error && (this.state = a.failState), r.returnType = a.node.typeAnnotation ? this.finishNode(a.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, a) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = a : super.setArrowFunctionParameters(r, a);
    }
    checkParams(r, a, u, T = !0) {
      if (!u || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start))) {
        for (let S = 0; S < r.params.length; S++) this.isThisParam(r.params[S]) && S > 0 && this.raise(Se.ThisParamMustBeFirst, r.params[S]);
        super.checkParams(r, a, u, T);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, a, u) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(a.index)) {
        this.next();
        const T = this.startNodeAt(a);
        T.callee = r, T.arguments = super.parseCallExpressionArguments(), r = this.finishNode(T, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        const T = this.state.clone(), S = this.tryParse((I) => this.parseAsyncArrowWithTypeParameters(a) || I(), T);
        if (!S.error && !S.aborted) return S.node;
        const _ = this.tryParse(() => super.parseSubscripts(r, a, u), T);
        if (_.node && !_.error) return _.node;
        if (S.node) return this.state = S.failState, S.node;
        if (_.node) return this.state = _.failState, _.node;
        throw S.error || _.error;
      }
      return super.parseSubscripts(r, a, u);
    }
    parseSubscript(r, a, u, T) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (T.optionalChainMember = !0, u) return T.stop = !0, r;
        this.next();
        const S = this.startNodeAt(a);
        return S.callee = r, S.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), S.arguments = this.parseCallExpressionArguments(), S.optional = !0, this.finishCallExpression(S, !0);
      }
      if (!u && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        const S = this.startNodeAt(a);
        S.callee = r;
        const _ = this.tryParse(() => (S.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), S.arguments = super.parseCallExpressionArguments(), T.optionalChainMember && (S.optional = !1), this.finishCallExpression(S, T.optionalChainMember)));
        if (_.node) return _.error && (this.state = _.failState), _.node;
      }
      return super.parseSubscript(r, a, u, T);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let a = null;
      this.shouldParseTypes() && this.match(47) && (a = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments = a;
    }
    parseAsyncArrowWithTypeParameters(r) {
      const a = this.startNodeAt(r);
      if (this.parseFunctionParams(a, !1), this.parseArrow(a)) return super.parseArrowExpression(a, void 0, !0);
    }
    readToken_mult_modulo(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && a === 47 && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      const a = this.input.charCodeAt(this.state.pos + 1);
      r !== 124 || a !== 125 ? super.readToken_pipe_amp(r) : this.finishOp(9, 2);
    }
    parseTopLevel(r, a) {
      const u = super.parseTopLevel(r, a);
      return this.state.hasFlowComment && this.raise(Se.UnterminatedFlowComment, this.state.curPosition()), u;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) throw this.raise(Se.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const r = this.skipFlowComment();
        return void (r && (this.state.pos += r, this.state.hasFlowComment = !0));
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const { pos: r } = this.state;
      let a = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + a)); ) a++;
      const u = this.input.charCodeAt(a + r), T = this.input.charCodeAt(a + r + 1);
      return u === 58 && T === 58 ? a + 2 : this.input.slice(a + r, a + r + 12) === "flow-include" ? a + 12 : u === 58 && T !== 58 && a;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(b.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, { enumName: a, memberName: u }) {
      this.raise(Se.EnumBooleanMemberNotInitialized, r, { memberName: u, enumName: a });
    }
    flowEnumErrorInvalidMemberInitializer(r, a) {
      return this.raise(a.explicitType ? a.explicitType === "symbol" ? Se.EnumInvalidMemberInitializerSymbolType : Se.EnumInvalidMemberInitializerPrimaryType : Se.EnumInvalidMemberInitializerUnknownType, r, a);
    }
    flowEnumErrorNumberMemberNotInitialized(r, a) {
      this.raise(Se.EnumNumberMemberNotInitialized, r, a);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, a) {
      this.raise(Se.EnumStringMemberInconsistentlyInitialized, r, a);
    }
    flowEnumMemberInit() {
      const r = this.state.startLoc, a = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          const u = this.parseNumericLiteral(this.state.value);
          return a() ? { type: "number", loc: u.loc.start, value: u } : { type: "invalid", loc: r };
        }
        case 134: {
          const u = this.parseStringLiteral(this.state.value);
          return a() ? { type: "string", loc: u.loc.start, value: u } : { type: "invalid", loc: r };
        }
        case 85:
        case 86: {
          const u = this.parseBooleanLiteral(this.match(85));
          return a() ? { type: "boolean", loc: u.loc.start, value: u } : { type: "invalid", loc: r };
        }
        default:
          return { type: "invalid", loc: r };
      }
    }
    flowEnumMemberRaw() {
      const r = this.state.startLoc;
      return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: r } };
    }
    flowEnumCheckExplicitTypeMismatch(r, a, u) {
      const { explicitType: T } = a;
      T !== null && T !== u && this.flowEnumErrorInvalidMemberInitializer(r, a);
    }
    flowEnumMembers({ enumName: r, explicitType: a }) {
      const u = /* @__PURE__ */ new Set(), T = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
      let S = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          S = !0;
          break;
        }
        const _ = this.startNode(), { id: I, init: R } = this.flowEnumMemberRaw(), M = I.name;
        if (M === "") continue;
        /^[a-z]/.test(M) && this.raise(Se.EnumInvalidMemberName, I, { memberName: M, suggestion: M[0].toUpperCase() + M.slice(1), enumName: r }), u.has(M) && this.raise(Se.EnumDuplicateMemberName, I, { memberName: M, enumName: r }), u.add(M);
        const K = { enumName: r, explicitType: a, memberName: M };
        switch (_.id = I, R.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(R.loc, K, "boolean"), _.init = R.value, T.booleanMembers.push(this.finishNode(_, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(R.loc, K, "number"), _.init = R.value, T.numberMembers.push(this.finishNode(_, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(R.loc, K, "string"), _.init = R.value, T.stringMembers.push(this.finishNode(_, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(R.loc, K);
          case "none":
            switch (a) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(R.loc, K);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(R.loc, K);
                break;
              default:
                T.defaultedMembers.push(this.finishNode(_, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: T, hasUnknownMembers: S };
    }
    flowEnumStringMembers(r, a, { enumName: u }) {
      if (r.length === 0) return a;
      if (a.length === 0) return r;
      if (a.length > r.length) {
        for (const T of r) this.flowEnumErrorStringMemberInconsistentlyInitialized(T, { enumName: u });
        return a;
      }
      for (const T of a) this.flowEnumErrorStringMemberInconsistentlyInitialized(T, { enumName: u });
      return r;
    }
    flowEnumParseExplicitType({ enumName: r }) {
      if (!this.eatContextual(102)) return null;
      if (!se(this.state.type)) throw this.raise(Se.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: r });
      const { value: a } = this.state;
      return this.next(), a !== "boolean" && a !== "number" && a !== "string" && a !== "symbol" && this.raise(Se.EnumInvalidExplicitType, this.state.startLoc, { enumName: r, invalidEnumType: a }), a;
    }
    flowEnumBody(r, a) {
      const u = a.name, T = a.loc.start, S = this.flowEnumParseExplicitType({ enumName: u });
      this.expect(5);
      const { members: _, hasUnknownMembers: I } = this.flowEnumMembers({ enumName: u, explicitType: S });
      switch (r.hasUnknownMembers = I, S) {
        case "boolean":
          return r.explicitType = !0, r.members = _.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = _.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(_.stringMembers, _.defaultedMembers, { enumName: u }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = _.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          const R = () => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody"));
          r.explicitType = !1;
          const M = _.booleanMembers.length, K = _.numberMembers.length, ne = _.stringMembers.length, ve = _.defaultedMembers.length;
          if (M || K || ne || ve) {
            if (M || K) {
              if (!K && !ne && M >= ve) {
                for (const de of _.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(de.loc.start, { enumName: u, memberName: de.id.name });
                return r.members = _.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
              }
              if (!M && !ne && K >= ve) {
                for (const de of _.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(de.loc.start, { enumName: u, memberName: de.id.name });
                return r.members = _.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
              }
              return this.raise(Se.EnumInconsistentMemberValues, T, { enumName: u }), R();
            }
            return r.members = this.flowEnumStringMembers(_.stringMembers, _.defaultedMembers, { enumName: u }), this.expect(8), this.finishNode(r, "EnumStringBody");
          }
          return R();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      const a = this.parseIdentifier();
      return r.id = a, r.body = this.flowEnumBody(this.startNode(), a), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      const r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        const a = this.input.charCodeAt(r + 1);
        return a !== 60 && a !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      const { type: r } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const { type: r } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, typescript: (P) => class extends P {
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ye.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: ye.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ye.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return eT;
    }
    tsIsIdentifier() {
      return se(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, a, u) {
      if (!se(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
      const T = this.state.value;
      if (r.includes(T)) {
        if (u && this.match(106) || a && this.tsIsStartOfStaticBlocks()) return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return T;
      }
    }
    tsParseModifiers({ allowedModifiers: r, disallowedModifiers: a, stopOnStartOfClassStaticBlock: u, errorTemplate: T = ye.InvalidModifierOnTypeMember }, S) {
      const _ = (R, M, K, ne) => {
        M === K && S[ne] && this.raise(ye.InvalidModifiersOrder, R, { orderedModifiers: [K, ne] });
      }, I = (R, M, K, ne) => {
        (S[K] && M === ne || S[ne] && M === K) && this.raise(ye.IncompatibleModifiers, R, { modifiers: [K, ne] });
      };
      for (; ; ) {
        const { startLoc: R } = this.state, M = this.tsParseModifier(r.concat(a ?? []), u, S.static);
        if (!M) break;
        Ju(M) ? S.accessibility ? this.raise(ye.DuplicateAccessibilityModifier, R, { modifier: M }) : (_(R, M, M, "override"), _(R, M, M, "static"), _(R, M, M, "readonly"), S.accessibility = M) : mT(M) ? (S[M] && this.raise(ye.DuplicateModifier, R, { modifier: M }), S[M] = !0, _(R, M, "in", "out")) : (hasOwnProperty.call(S, M) ? this.raise(ye.DuplicateModifier, R, { modifier: M }) : (_(R, M, "static", "readonly"), _(R, M, "static", "override"), _(R, M, "override", "readonly"), _(R, M, "abstract", "override"), I(R, M, "declare", "override"), I(R, M, "static", "abstract")), S[M] = !0), a != null && a.includes(M) && this.raise(T, R, { modifier: M });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, a) {
      const u = [];
      for (; !this.tsIsListTerminator(r); ) u.push(a());
      return u;
    }
    tsParseDelimitedList(r, a, u) {
      return (function(T) {
        if (T == null) throw new Error(`Unexpected ${T} value.`);
        return T;
      })(this.tsParseDelimitedListWorker(r, a, !0, u));
    }
    tsParseDelimitedListWorker(r, a, u, T) {
      const S = [];
      let _ = -1;
      for (; !this.tsIsListTerminator(r); ) {
        _ = -1;
        const I = a();
        if (I == null) return;
        if (S.push(I), !this.eat(12)) {
          if (this.tsIsListTerminator(r)) break;
          return void (u && this.expect(12));
        }
        _ = this.state.lastTokStartLoc.index;
      }
      return T && (T.value = _), S;
    }
    tsParseBracketedList(r, a, u, T, S) {
      T || (u ? this.expect(0) : this.expect(47));
      const _ = this.tsParseDelimitedList(r, a, S);
      return u ? this.expect(3) : this.expect(48), _;
    }
    tsParseImportType() {
      const r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(ye.UnsupportedImportTypeArgument, this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) ? r.options = this.tsParseImportTypeOptions() : r.options = null, this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
    }
    tsParseImportTypeOptions() {
      const r = this.startNode();
      this.expect(5);
      const a = this.startNode();
      return this.isContextual(76) ? (a.method = !1, a.key = this.parseIdentifier(!0), a.computed = !1, a.shorthand = !1) : this.unexpected(null, 76), this.expect(14), a.value = this.tsParseImportTypeWithPropertyValue(), r.properties = [this.finishObjectProperty(a)], this.eat(12), this.expect(8), this.finishNode(r, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      const r = this.startNode(), a = [];
      for (this.expect(5); !this.match(8); ) {
        const u = this.state.type;
        se(u) || u === 134 ? a.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
      }
      return r.properties = a, this.next(), this.finishNode(r, "ObjectExpression");
    }
    tsParseEntityName(r) {
      let a;
      if (1 & r && this.match(78)) if (2 & r) a = this.parseIdentifier(!0);
      else {
        const u = this.startNode();
        this.next(), a = this.finishNode(u, "ThisExpression");
      }
      else a = this.parseIdentifier(!!(1 & r));
      for (; this.eat(16); ) {
        const u = this.startNodeAtNode(a);
        u.left = a, u.right = this.parseIdentifier(!!(1 & r)), a = this.finishNode(u, "TSQualifiedName");
      }
      return a;
    }
    tsParseTypeReference() {
      const r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      const a = this.startNodeAtNode(r);
      return a.parameterName = r, a.typeAnnotation = this.tsParseTypeAnnotation(!1), a.asserts = !1, this.finishNode(a, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      const r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      const a = this.startNode();
      return r(a), a.name = this.tsParseTypeParameterName(), a.constraint = this.tsEatThenParseType(81), a.default = this.tsEatThenParseType(29), this.finishNode(a, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47)) return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      const a = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      const u = { value: -1 };
      return a.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, u), a.params.length === 0 && this.raise(ye.EmptyTypeParameters, a), u.value !== -1 && this.addExtra(a, "trailingComma", u.value), this.finishNode(a, "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, a) {
      const u = r === 19, T = "typeAnnotation";
      a.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), a.parameters = this.tsParseBindingListForSignature(), (u || this.match(r)) && (a[T] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      const r = super.parseBindingList(11, 41, 2);
      for (const a of r) {
        const { type: u } = a;
        u !== "AssignmentPattern" && u !== "TSParameterProperty" || this.raise(ye.UnsupportedSignatureParameterKind, a, { type: u });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      this.eat(12) || this.isLineTerminator() || this.expect(13);
    }
    tsParseSignatureMember(r, a) {
      return this.tsFillSignature(14, a), this.tsParseTypeMemberSemicolon(), this.finishNode(a, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), !!se(this.state.type) && (this.next(), this.match(14));
    }
    tsTryParseIndexSignature(r) {
      if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
      this.expect(0);
      const a = this.parseIdentifier();
      a.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(a), this.expect(3), r.parameters = [a];
      const u = this.tsTryParseTypeAnnotation();
      return u && (r.typeAnnotation = u), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, a) {
      if (this.eat(17) && (r.optional = !0), this.match(10) || this.match(47)) {
        a && this.raise(ye.ReadonlyForMethodSignature, r);
        const u = r;
        u.kind && this.match(47) && this.raise(ye.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, u), this.tsParseTypeMemberSemicolon();
        const T = "parameters", S = "typeAnnotation";
        if (u.kind === "get") u[T].length > 0 && (this.raise(b.BadGetterArity, this.state.curPosition()), this.isThisParam(u[T][0]) && this.raise(ye.AccessorCannotDeclareThisParameter, this.state.curPosition()));
        else if (u.kind === "set") {
          if (u[T].length !== 1) this.raise(b.BadSetterArity, this.state.curPosition());
          else {
            const _ = u[T][0];
            this.isThisParam(_) && this.raise(ye.AccessorCannotDeclareThisParameter, this.state.curPosition()), _.type === "Identifier" && _.optional && this.raise(ye.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), _.type === "RestElement" && this.raise(ye.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          u[S] && this.raise(ye.SetAccessorCannotHaveReturnType, u[S]);
        } else u.kind = "method";
        return this.finishNode(u, "TSMethodSignature");
      }
      {
        const u = r;
        a && (u.readonly = !0);
        const T = this.tsTryParseTypeAnnotation();
        return T && (u.typeAnnotation = T), this.tsParseTypeMemberSemicolon(), this.finishNode(u, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const r = this.startNode();
      if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        const u = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.createIdentifier(u, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, r), this.tsTryParseIndexSignature(r) || (super.parsePropertyName(r), r.computed || r.key.type !== "Identifier" || r.key.name !== "get" && r.key.name !== "set" || !this.tsTokenCanFollowModifier() || (r.kind = r.key.name, super.parsePropertyName(r), this.match(10) || this.match(47) || this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      const r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
    }
    tsParseMappedType() {
      const r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (r.readonly = !0), this.expect(0);
      {
        const a = this.startNode();
        a.name = this.tsParseTypeParameterName(), a.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(a, "TSTypeParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      const r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let a = !1;
      return r.elementTypes.forEach((u) => {
        const { type: T } = u;
        !a || T === "TSRestType" || T === "TSOptionalType" || T === "TSNamedTupleMember" && u.optional || this.raise(ye.OptionalTypeBeforeRequired, u), a || (a = T === "TSNamedTupleMember" && u.optional || T === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      const r = this.state.startLoc, a = this.eat(21), { startLoc: u } = this.state;
      let T, S, _, I;
      const R = z(this.state.type) ? this.lookaheadCharCode() : null;
      if (R === 58) T = !0, _ = !1, S = this.parseIdentifier(!0), this.expect(14), I = this.tsParseType();
      else if (R === 63) {
        _ = !0;
        const M = this.state.value, K = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (T = !0, S = this.createIdentifier(this.startNodeAt(u), M), this.expect(17), this.expect(14), I = this.tsParseType()) : (T = !1, I = K, this.expect(17));
      } else I = this.tsParseType(), _ = this.eat(17), T = this.eat(14);
      if (T) {
        let M;
        S ? (M = this.startNodeAt(u), M.optional = _, M.label = S, M.elementType = I, this.eat(17) && (M.optional = !0, this.raise(ye.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (M = this.startNodeAt(u), M.optional = _, this.raise(ye.InvalidTupleMemberLabel, I), M.label = I, M.elementType = this.tsParseType()), I = this.finishNode(M, "TSNamedTupleMember");
      } else if (_) {
        const M = this.startNodeAt(u);
        M.typeAnnotation = I, I = this.finishNode(M, "TSOptionalType");
      }
      if (a) {
        const M = this.startNodeAt(r);
        M.typeAnnotation = I, I = this.finishNode(M, "TSRestType");
      }
      return I;
    }
    tsParseParenthesizedType() {
      const r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, a) {
      const u = this.startNode();
      return r === "TSConstructorType" && (u.abstract = !!a, a && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, u)), this.finishNode(u, r);
    }
    tsParseLiteralTypeNode() {
      const r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        const r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const r = this.startNode(), a = this.lookahead();
            return a.type !== 135 && a.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const { type: r } = this.state;
          if (se(r) || r === 88 || r === 84) {
            const a = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : (function(u) {
              switch (u) {
                case "any":
                  return "TSAnyKeyword";
                case "boolean":
                  return "TSBooleanKeyword";
                case "bigint":
                  return "TSBigIntKeyword";
                case "never":
                  return "TSNeverKeyword";
                case "number":
                  return "TSNumberKeyword";
                case "object":
                  return "TSObjectKeyword";
                case "string":
                  return "TSStringKeyword";
                case "symbol":
                  return "TSSymbolKeyword";
                case "undefined":
                  return "TSUndefinedKeyword";
                case "unknown":
                  return "TSUnknownKeyword";
                default:
                  return;
              }
            })(this.state.value);
            if (a !== void 0 && this.lookaheadCharCode() !== 46) {
              const u = this.startNode();
              return this.next(), this.finishNode(u, a);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      const { startLoc: r } = this.state;
      let a = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
        const u = this.startNodeAt(r);
        u.elementType = a, this.expect(3), a = this.finishNode(u, "TSArrayType");
      } else {
        const u = this.startNodeAt(r);
        u.objectType = a, u.indexType = this.tsParseType(), this.expect(3), a = this.finishNode(u, "TSIndexedAccessType");
      }
      return a;
    }
    tsParseTypeOperator() {
      const r = this.startNode(), a = this.state.value;
      return this.next(), r.operator = a, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), a === "readonly" && this.tsCheckTypeAnnotationForReadOnly(r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ye.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      const r = this.startNode();
      this.expectContextual(115);
      const a = this.startNode();
      return a.name = this.tsParseTypeParameterName(), a.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter = this.finishNode(a, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      var r;
      return (r = this.state.type) >= 121 && r <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, a, u) {
      const T = this.startNode(), S = this.eat(u), _ = [];
      do
        _.push(a());
      while (this.eat(u));
      return _.length !== 1 || S ? (T.types = _, this.finishNode(T, r)) : _[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (se(this.state.type) || this.match(78)) return this.next(), !0;
      if (this.match(5)) {
        const { errors: r } = this.state, a = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === a;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const { errors: r } = this.state, a = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === a;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        const a = this.startNode();
        this.expect(r);
        const u = this.startNode(), T = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (T && this.match(78)) {
          let I = this.tsParseThisTypeOrThisTypePredicate();
          return I.type === "TSThisType" ? (u.parameterName = I, u.asserts = !0, u.typeAnnotation = null, I = this.finishNode(u, "TSTypePredicate")) : (this.resetStartLocationFromNode(I, u), I.asserts = !0), a.typeAnnotation = I, this.finishNode(a, "TSTypeAnnotation");
        }
        const S = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!S) return T ? (u.parameterName = this.parseIdentifier(), u.asserts = T, u.typeAnnotation = null, a.typeAnnotation = this.finishNode(u, "TSTypePredicate"), this.finishNode(a, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, a);
        const _ = this.tsParseTypeAnnotation(!1);
        return u.parameterName = S, u.typeAnnotation = _, u.asserts = T, a.typeAnnotation = this.finishNode(u, "TSTypePredicate"), this.finishNode(a, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109) return !1;
      const r = this.state.containsEsc;
      return this.next(), !(!se(this.state.type) && !this.match(78)) && (r && this.raise(b.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(r = !0, a = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), a.typeAnnotation = this.tsParseType();
      }), this.finishNode(a, "TSTypeAnnotation");
    }
    tsParseType() {
      Ku(this.state.inType);
      const r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return r;
      const a = this.startNodeAtNode(r);
      return a.checkType = r, a.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), a.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), a.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(a, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ye.ReservedTypeAssertion, this.state.startLoc);
      const r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      const a = this.state.startLoc, u = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          const T = this.startNode();
          return T.expression = this.tsParseEntityName(3), this.match(47) && (T.typeParameters = this.tsParseTypeArguments()), this.finishNode(T, "TSExpressionWithTypeArguments");
        }
      });
      return u.length || this.raise(ye.EmptyHeritageClauseType, a, { token: r }), u;
    }
    tsParseInterfaceDeclaration(r, a = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), a.declare && (r.declare = !0), se(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 130)) : (r.id = null, this.raise(ye.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      const u = this.startNode();
      return u.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(u, "TSInterfaceBody"), this.finishNode(r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
          const a = this.startNode();
          return this.next(), this.finishNode(a, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() === O.brace) return r();
      {
        const a = this.state.context;
        this.state.context = [a[0]];
        try {
          return r();
        } finally {
          this.state.context = a;
        }
      }
    }
    tsInType(r) {
      const a = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = a;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      const a = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = a;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      const a = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = a;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r)) return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, a = {}) {
      return a.const && (r.const = !0), a.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      const r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      const r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, a = !1) {
      if (r.id = this.parseIdentifier(), a || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        const u = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(u, !0), r.body = u;
      } else this.scope.enter(1024), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "module", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, a, u) {
      r.isExport = u || !1, r.id = a || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      const T = this.tsParseModuleReference();
      return r.importKind === "type" && T.type !== "TSExternalModuleReference" && this.raise(ye.ImportAliasHasImportType, T), r.moduleReference = T, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      const r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      const a = this.state.clone(), u = r();
      return this.state = a, u;
    }
    tsTryParseAndCatch(r) {
      const a = this.tryParse((u) => r() || u());
      if (!a.aborted && a.node) return a.error && (this.state = a.failState), a.node;
    }
    tsTryParse(r) {
      const a = this.state.clone(), u = r();
      if (u !== void 0 && u !== !1) return u;
      this.state = a;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator()) return;
      const a = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (a) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 100:
            if (this.state.containsEsc) return;
          case 75:
          case 74:
            return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(r, { const: !0, declare: !0 })) : (r.declare = !0, this.parseVarStatement(r, this.state.value, !0));
          case 107:
            if (this.isUsing()) return this.raise(ye.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.parseVarStatement(r, "using", !0);
            break;
          case 96:
            if (this.isAwaitUsing()) return this.raise(ye.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.next(), this.parseVarStatement(r, "await using", !0);
            break;
          case 129: {
            const u = this.tsParseInterfaceDeclaration(r, { declare: !0 });
            if (u) return u;
          }
          default:
            if (se(a)) return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, a, u) {
      switch (a.name) {
        case "declare": {
          const T = this.tsTryParseDeclare(r);
          return T && (T.declare = !0), T;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(1024), this.prodParam.enter(0);
            const T = r;
            return T.kind = "global", r.global = !0, T.id = a, T.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(T, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, a.name, !1, u);
      }
    }
    tsParseDeclaration(r, a, u, T) {
      switch (a) {
        case "abstract":
          if (this.tsCheckLineTerminator(u) && (this.match(80) || se(this.state.type))) return this.tsParseAbstractDeclaration(r, T);
          break;
        case "module":
          if (this.tsCheckLineTerminator(u)) {
            if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(r);
            if (se(this.state.type)) return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(u) && se(this.state.type)) return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(u) && se(this.state.type)) return this.tsParseTypeAliasDeclaration(r);
      }
    }
    tsCheckLineTerminator(r) {
      return r ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      const a = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const u = this.tsTryParseAndCatch(() => {
        const T = this.startNodeAt(r);
        return T.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(T), T.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), T;
      });
      return this.state.maybeInArrowParameters = a, u ? super.parseArrowExpression(u, null, !0) : void 0;
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(ye.EmptyTypeArguments, r) : this.state.inType || this.curContext() !== O.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return (r = this.state.type) >= 124 && r <= 130;
      var r;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, a) {
      const u = a.length ? a[0].loc.start : this.state.startLoc, T = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, T);
      const S = T.accessibility, _ = T.override, I = T.readonly;
      4 & r || !(S || I || _) || this.raise(ye.UnexpectedParameterModifier, u);
      const R = this.parseMaybeDefault();
      2 & r && this.parseFunctionParamType(R);
      const M = this.parseMaybeDefault(R.loc.start, R);
      if (S || I || _) {
        const K = this.startNodeAt(u);
        return a.length && (K.decorators = a), S && (K.accessibility = S), I && (K.readonly = I), _ && (K.override = _), M.type !== "Identifier" && M.type !== "AssignmentPattern" && this.raise(ye.UnsupportedParameterPropertyKind, K), K.parameter = M, this.finishNode(K, "TSParameterProperty");
      }
      return a.length && (R.decorators = a), M;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (const a of r.params) a.type !== "Identifier" && a.optional && !this.state.isAmbientContext && this.raise(ye.PatternIsOptional, a);
    }
    setArrowFunctionParameters(r, a, u) {
      super.setArrowFunctionParameters(r, a, u), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, a, u = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const T = a === "FunctionDeclaration" ? "TSDeclareFunction" : a === "ClassMethod" || a === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return T && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, T) : T === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ye.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, T, u) : (this.tsDisallowOptionalPattern(r), super.parseFunctionBodyAndFinish(r, a, u));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((a) => {
        a?.type === "TSTypeCastExpression" && this.raise(ye.UnexpectedTypeAnnotation, a.typeAnnotation);
      });
    }
    toReferencedList(r, a) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, a, u, T) {
      const S = super.parseArrayLike(r, a, u, T);
      return S.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(S.elements), S;
    }
    parseSubscript(r, a, u, T) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const _ = this.startNodeAt(a);
        return _.expression = r, this.finishNode(_, "TSNonNullExpression");
      }
      let S = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (u) return T.stop = !0, r;
        T.optionalChainMember = S = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let _;
        const I = this.tsTryParseAndCatch(() => {
          if (!u && this.atPossibleAsyncArrow(r)) {
            const ne = this.tsTryParseGenericAsyncArrowFunction(a);
            if (ne) return T.stop = !0, ne;
          }
          const R = this.tsParseTypeArgumentsInExpression();
          if (!R) return;
          if (S && !this.match(10)) return void (_ = this.state.curPosition());
          if (qe(this.state.type)) {
            const ne = super.parseTaggedTemplateExpression(r, a, T);
            return ne.typeParameters = R, ne;
          }
          if (!u && this.eat(10)) {
            const ne = this.startNodeAt(a);
            return ne.callee = r, ne.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(ne.arguments), ne.typeParameters = R, T.optionalChainMember && (ne.optional = S), this.finishCallExpression(ne, T.optionalChainMember);
          }
          const M = this.state.type;
          if (M === 48 || M === 52 || M !== 10 && ae(M) && !this.hasPrecedingLineBreak()) return;
          const K = this.startNodeAt(a);
          return K.expression = r, K.typeParameters = R, this.finishNode(K, "TSInstantiationExpression");
        });
        if (_ && this.unexpected(_, 10), I) return I.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ye.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), this.match(16) || this.match(18) || (I.expression = super.stopParseSubscript(r, T))), I;
      }
      return super.parseSubscript(r, a, u, T);
    }
    parseNewCallee(r) {
      var a;
      super.parseNewCallee(r);
      const { callee: u } = r;
      u.type !== "TSInstantiationExpression" || (a = u.extra) != null && a.parenthesized || (r.typeParameters = u.typeParameters, r.callee = u.expression);
    }
    parseExprOp(r, a, u) {
      let T;
      if (Oe(58) > u && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (T = this.isContextual(120)))) {
        const S = this.startNodeAt(a);
        return S.expression = r, S.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (T && this.raise(b.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(S, T ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(S, a, u);
      }
      return super.parseExprOp(r, a, u);
    }
    checkReservedWord(r, a, u, T) {
      this.state.isAmbientContext || super.checkReservedWord(r, a, u, T);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ye.ImportReflectionHasImportType, r.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        const a = this.lookaheadCharCode();
        return r ? a === 123 || a === 42 : a !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, a, u, T) {
      super.applyImportPhase(r, a, u, T), a ? r.exportKind = u === "type" ? "type" : "value" : r.importKind = u === "type" || u === "typeof" ? u : "value";
    }
    parseImport(r) {
      if (this.match(134)) return r.importKind = "value", super.parseImport(r);
      let a;
      if (se(this.state.type) && this.lookaheadCharCode() === 61) return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        const u = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(r, u);
        a = super.parseImportSpecifiersAndAfter(r, u);
      } else a = super.parseImport(r);
      return a.importKind === "type" && a.specifiers.length > 1 && a.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ye.TypeImportCannotSpecifyDefaultAndNamed, a), a;
    }
    parseExport(r, a) {
      if (this.match(83)) {
        const u = r;
        this.next();
        let T = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? T = this.parseMaybeImportPhase(u, !1) : u.importKind = "value", this.tsParseImportEqualsDeclaration(u, T, !0);
      }
      if (this.eat(29)) {
        const u = r;
        return u.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(u, "TSExportAssignment");
      }
      if (this.eatContextual(93)) {
        const u = r;
        return this.expectContextual(128), u.id = this.parseIdentifier(), this.semicolon(), this.finishNode(u, "TSNamespaceExportDeclaration");
      }
      return super.parseExport(r, a);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        const r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, a, u = !1) {
      const { isAmbientContext: T } = this.state, S = super.parseVarStatement(r, a, u || T);
      if (!T) return S;
      if (!r.declare && (a === "using" || a === "await using")) return this.raiseOverwrite(ye.UsingDeclarationInAmbientContext, r, a), S;
      for (const { id: _, init: I } of S.declarations) I && (a === "var" || a === "let" || _.typeAnnotation ? this.raise(ye.InitializerNotAllowedInAmbientContext, I) : yT(I, this.hasPlugin("estree")) || this.raise(ye.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, I));
      return S;
    }
    parseStatementContent(r, a) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const u = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(u, { const: !0 });
      }
      if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const u = this.tsParseInterfaceDeclaration(this.startNode());
        if (u) return u;
      }
      return super.parseStatementContent(r, a);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, a) {
      return a.some((u) => Ju(u) ? r.accessibility === u : !!r[u]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, a, u) {
      const T = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: T, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: ye.InvalidModifierOnTypeParameterPositions }, a);
      const S = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(a, T) && this.raise(ye.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(r, a)) : this.parseClassMemberWithIsStatic(r, a, u, !!a.static);
      };
      a.declare ? this.tsInAmbientContext(S) : S();
    }
    parseClassMemberWithIsStatic(r, a, u, T) {
      const S = this.tsTryParseIndexSignature(a);
      if (S) return r.body.push(S), a.abstract && this.raise(ye.IndexSignatureHasAbstract, a), a.accessibility && this.raise(ye.IndexSignatureHasAccessibility, a, { modifier: a.accessibility }), a.declare && this.raise(ye.IndexSignatureHasDeclare, a), void (a.override && this.raise(ye.IndexSignatureHasOverride, a));
      !this.state.inAbstractClass && a.abstract && this.raise(ye.NonAbstractClassHasAbstractMethod, a), a.override && (u.hadSuperClass || this.raise(ye.OverrideNotInSubClass, a)), super.parseClassMemberWithIsStatic(r, a, u, T);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(ye.ClassMethodHasReadonly, r), r.declare && this.match(10) && this.raise(ye.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, a, u) {
      return (a.type === "Identifier" ? this.tsParseExpressionStatement(r, a, u) : void 0) || super.parseExpressionStatement(r, a, u);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(r, a, u) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        const T = this.lookaheadCharCode();
        if (T === 44 || T === 61 || T === 58 || T === 41) return this.setOptionalParametersError(u), r;
      }
      return super.parseConditional(r, a, u);
    }
    parseParenItem(r, a) {
      const u = super.parseParenItem(r, a);
      if (this.eat(17) && (u.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        const T = this.startNodeAt(a);
        return T.expression = r, T.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(T, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      const a = this.state.startLoc, u = this.eatContextual(125);
      if (u && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(ye.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const T = se(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return T ? ((T.type === "TSInterfaceDeclaration" || T.type === "TSTypeAliasDeclaration" || u) && (r.exportKind = "type"), u && T.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(T, a), T.declare = !0), T) : null;
    }
    parseClassId(r, a, u, T) {
      if ((!a || u) && this.isContextual(113)) return;
      super.parseClassId(r, a, u, r.declare ? 1024 : 8331);
      const S = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      S && (r.typeParameters = S);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      const a = this.tsTryParseTypeAnnotation();
      a && (r.typeAnnotation = a);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && (!r.readonly || r.typeAnnotation) && this.match(29) && this.raise(ye.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        const { key: a } = r;
        this.raise(ye.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: a.type !== "Identifier" || r.computed ? `[${this.input.slice(this.offsetToSourcePos(a.start), this.offsetToSourcePos(a.end))}]` : a.name });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(ye.PrivateElementHasAbstract, r), r.accessibility && this.raise(ye.PrivateElementHasAccessibility, r, { modifier: r.accessibility }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(ye.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(r);
    }
    pushClassMethod(r, a, u, T, S, _) {
      const I = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      I && S && this.raise(ye.ConstructorHasTypeParameters, I);
      const { declare: R = !1, kind: M } = a;
      !R || M !== "get" && M !== "set" || this.raise(ye.DeclareAccessor, a, { kind: M }), I && (a.typeParameters = I), super.pushClassMethod(r, a, u, T, S, _);
    }
    pushClassPrivateMethod(r, a, u, T) {
      const S = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      S && (a.typeParameters = S), super.pushClassPrivateMethod(r, a, u, T);
    }
    declareClassPrivateMethodInScope(r, a) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && r.value.body == null || super.declareClassPrivateMethodInScope(r, a));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, a, u, T, S, _, I) {
      const R = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return R && (r.typeParameters = R), super.parseObjPropValue(r, a, u, T, S, _, I);
    }
    parseFunctionParams(r, a) {
      const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && (r.typeParameters = u), super.parseFunctionParams(r, a);
    }
    parseVarId(r, a) {
      super.parseVarId(r, a), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      const u = this.tsTryParseTypeAnnotation();
      u && (r.id.typeAnnotation = u, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, a) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, a);
    }
    parseMaybeAssign(r, a) {
      var u, T, S, _, I;
      let R, M, K, ne;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (R = this.state.clone(), M = this.tryParse(() => super.parseMaybeAssign(r, a), R), !M.error) return M.node;
        const { context: de } = this.state, Pe = de[de.length - 1];
        Pe !== O.j_oTag && Pe !== O.j_expr || de.pop();
      }
      if (!((u = M) != null && u.error || this.match(47))) return super.parseMaybeAssign(r, a);
      R && R !== this.state || (R = this.state.clone());
      const ve = this.tryParse((de) => {
        var Pe, He;
        ne = this.tsParseTypeParameters(this.tsParseConstModifier);
        const ct = super.parseMaybeAssign(r, a);
        return (ct.type !== "ArrowFunctionExpression" || (Pe = ct.extra) != null && Pe.parenthesized) && de(), ((He = ne) == null ? void 0 : He.params.length) !== 0 && this.resetStartLocationFromNode(ct, ne), ct.typeParameters = ne, ct;
      }, R);
      if (!ve.error && !ve.aborted) return ne && this.reportReservedArrowTypeParam(ne), ve.node;
      if (!M && (Ku(!this.hasPlugin("jsx")), K = this.tryParse(() => super.parseMaybeAssign(r, a), R), !K.error)) return K.node;
      if ((T = M) != null && T.node) return this.state = M.failState, M.node;
      if (ve.node) return this.state = ve.failState, ne && this.reportReservedArrowTypeParam(ne), ve.node;
      if ((S = K) != null && S.node) return this.state = K.failState, K.node;
      throw ((_ = M) == null ? void 0 : _.error) || ve.error || ((I = K) == null ? void 0 : I.error);
    }
    reportReservedArrowTypeParam(r) {
      var a;
      r.params.length !== 1 || r.params[0].constraint || (a = r.extra) != null && a.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(ye.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, a) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, a);
    }
    parseArrow(r) {
      if (this.match(14)) {
        const a = this.tryParse((u) => {
          const T = this.tsParseTypeOrTypePredicateAnnotation(14);
          return !this.canInsertSemicolon() && this.match(19) || u(), T;
        });
        if (a.aborted) return;
        a.thrown || (a.error && (this.state = a.failState), r.returnType = a.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      const a = this.tsTryParseTypeAnnotation();
      return a && (r.typeAnnotation = a), this.resetEndLocation(r), r;
    }
    isAssignable(r, a) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, a);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, a);
      }
    }
    toAssignable(r, a = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, a);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          a ? this.expressionScope.recordArrowParameterBindingError(ye.UnexpectedTypeCastInParameter, r) : this.raise(ye.UnexpectedTypeCastInParameter, r), this.toAssignable(r.expression, a);
          break;
        case "AssignmentExpression":
          a || r.left.type !== "TSTypeCastExpression" || (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, a);
      }
    }
    toAssignableParenthesizedExpression(r, a) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, a);
          break;
        default:
          super.toAssignable(r, a);
      }
    }
    checkToRestConversion(r, a) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, a);
      }
    }
    isValidLVal(r, a, u) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (u !== 64 || !a) && ["expression", !0];
        default:
          return super.isValidLVal(r, a, u);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, a) {
      if (this.match(47) || this.match(51)) {
        const u = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const T = super.parseMaybeDecoratorArguments(r, a);
          return T.typeParameters = u, T;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, a);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, a) {
      const u = super.parseMaybeDefault(r, a);
      return u.type === "AssignmentPattern" && u.typeAnnotation && u.right.start < u.typeAnnotation.start && this.raise(ye.TypeAnnotationAfterAssign, u.typeAnnotation), u;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) return void this.finishOp(48, 1);
        if (r === 60) return void this.finishOp(47, 1);
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      const { type: r } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const { type: r } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, a, u) {
      const T = r[a];
      T.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(T)), super.toAssignableListItem(r, a, u);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((a) => this.isAssignable(a, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        const a = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        a && (r.typeParameters = a);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      const a = super.getGetterSetterExpectedParamCount(r), u = this.getObjectOrClassMethodParams(r)[0];
      return u && this.isThisParam(u) ? a + 1 : a;
    }
    parseCatchClauseParam() {
      const r = super.parseCatchClauseParam(), a = this.tsTryParseTypeAnnotation();
      return a && (r.typeAnnotation = a, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      const { isAmbientContext: a, strict: u } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = a, this.state.strict = u;
      }
    }
    parseClass(r, a, u) {
      const T = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, a, u);
      } finally {
        this.state.inAbstractClass = T;
      }
    }
    tsParseAbstractDeclaration(r, a) {
      if (this.match(80)) return r.abstract = !0, this.maybeTakeDecorators(a, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) return r.abstract = !0, this.raise(ye.NonClassMethodPropertyHasAbstractModifier, r), this.tsParseInterfaceDeclaration(r);
      } else this.unexpected(null, 80);
    }
    parseMethod(r, a, u, T, S, _, I) {
      const R = super.parseMethod(r, a, u, T, S, _, I);
      if ((R.abstract || R.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? R.value : R).body) {
        const { key: M } = R;
        this.raise(ye.AbstractMethodHasImplementation, R, { methodName: M.type !== "Identifier" || R.computed ? `[${this.input.slice(this.offsetToSourcePos(M.start), this.offsetToSourcePos(M.end))}]` : M.name });
      }
      return R;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, a, u, T) {
      return !a && T ? (this.parseTypeOnlyImportExportSpecifier(r, !1, u), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value", super.parseExportSpecifier(r, a, u, T));
    }
    parseImportSpecifier(r, a, u, T, S) {
      return !a && T ? (this.parseTypeOnlyImportExportSpecifier(r, !0, u), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value", super.parseImportSpecifier(r, a, u, T, u ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, a, u) {
      const T = a ? "imported" : "local", S = a ? "local" : "exported";
      let _, I = r[T], R = !1, M = !0;
      const K = I.loc.start;
      if (this.isContextual(93)) {
        const ne = this.parseIdentifier();
        if (this.isContextual(93)) {
          const ve = this.parseIdentifier();
          z(this.state.type) ? (R = !0, I = ne, _ = a ? this.parseIdentifier() : this.parseModuleExportName(), M = !1) : (_ = ve, M = !1);
        } else z(this.state.type) ? (M = !1, _ = a ? this.parseIdentifier() : this.parseModuleExportName()) : (R = !0, I = ne);
      } else z(this.state.type) && (R = !0, a ? (I = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(I.name, I.loc.start, !0, !0)) : I = this.parseModuleExportName());
      R && u && this.raise(a ? ye.TypeModifierIsUsedInTypeImports : ye.TypeModifierIsUsedInTypeExports, K), r[T] = I, r[S] = _, r[a ? "importKind" : "exportKind"] = R ? "type" : "value", M && this.eatContextual(93) && (r[S] = a ? this.parseIdentifier() : this.parseModuleExportName()), r[S] || (r[S] = this.cloneIdentifier(r[T])), a && this.checkIdentifier(r[S], R ? 4098 : 4096);
    }
    fillOptionalPropertiesForTSESLint(r) {
      switch (r.type) {
        case "ExpressionStatement":
          return void (r.directive != null || (r.directive = void 0));
        case "RestElement":
          r.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          return r.decorators != null || (r.decorators = []), r.optional != null || (r.optional = !1), void (r.typeAnnotation != null || (r.typeAnnotation = void 0));
        case "TSParameterProperty":
          return r.accessibility != null || (r.accessibility = void 0), r.decorators != null || (r.decorators = []), r.override != null || (r.override = !1), r.readonly != null || (r.readonly = !1), void (r.static != null || (r.static = !1));
        case "TSEmptyBodyFunctionExpression":
          r.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          return r.declare != null || (r.declare = !1), r.returnType != null || (r.returnType = void 0), void (r.typeParameters != null || (r.typeParameters = void 0));
        case "Property":
          return void (r.optional != null || (r.optional = !1));
        case "TSMethodSignature":
        case "TSPropertySignature":
          r.optional != null || (r.optional = !1);
        case "TSIndexSignature":
          return r.accessibility != null || (r.accessibility = void 0), r.readonly != null || (r.readonly = !1), void (r.static != null || (r.static = !1));
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          r.declare != null || (r.declare = !1), r.definite != null || (r.definite = !1), r.readonly != null || (r.readonly = !1), r.typeAnnotation != null || (r.typeAnnotation = void 0);
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          return r.accessibility != null || (r.accessibility = void 0), r.decorators != null || (r.decorators = []), r.override != null || (r.override = !1), void (r.optional != null || (r.optional = !1));
        case "ClassExpression":
          r.id != null || (r.id = null);
        case "ClassDeclaration":
          return r.abstract != null || (r.abstract = !1), r.declare != null || (r.declare = !1), r.decorators != null || (r.decorators = []), r.implements != null || (r.implements = []), r.superTypeArguments != null || (r.superTypeArguments = void 0), void (r.typeParameters != null || (r.typeParameters = void 0));
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          return void (r.declare != null || (r.declare = !1));
        case "VariableDeclarator":
          return void (r.definite != null || (r.definite = !1));
        case "TSEnumDeclaration":
          return r.const != null || (r.const = !1), void (r.declare != null || (r.declare = !1));
        case "TSEnumMember":
          return void (r.computed != null || (r.computed = !1));
        case "TSImportType":
          return r.qualifier != null || (r.qualifier = null), void (r.options != null || (r.options = null));
        case "TSInterfaceDeclaration":
          return r.declare != null || (r.declare = !1), void (r.extends != null || (r.extends = []));
        case "TSMappedType":
          return r.optional != null || (r.optional = !1), void (r.readonly != null || (r.readonly = void 0));
        case "TSModuleDeclaration":
          return r.declare != null || (r.declare = !1), void (r.global != null || (r.global = r.kind === "global"));
        case "TSTypeParameter":
          return r.const != null || (r.const = !1), r.in != null || (r.in = !1), void (r.out != null || (r.out = !1));
      }
    }
  }, v8intrinsic: (P) => class extends P {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const r = this.state.startLoc, a = this.startNode();
        if (this.next(), se(this.state.type)) {
          const u = this.parseIdentifierName(), T = this.createIdentifier(a, u);
          if (this.castNodeTo(T, "V8IntrinsicIdentifier"), this.match(10)) return T;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, placeholders: (P) => class extends P {
    parsePlaceholder(r) {
      if (this.match(133)) {
        const a = this.startNode();
        return this.next(), this.assertNoSpace(), a.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(a, r);
      }
    }
    finishPlaceholder(r, a) {
      let u = r;
      return u.expectedNode && u.type || (u = this.finishNode(u, "Placeholder")), u.expectedNode = a, u;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, a, u, T) {
      r !== void 0 && super.checkReservedWord(r, a, u, T);
    }
    cloneIdentifier(r) {
      const a = super.cloneIdentifier(r);
      return a.type === "Placeholder" && (a.expectedNode = r.expectedNode), a;
    }
    cloneStringLiteral(r) {
      return r.type === "Placeholder" ? this.cloneIdentifier(r) : super.cloneStringLiteral(r);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, a, u) {
      return r === "Placeholder" || super.isValidLVal(r, a, u);
    }
    toAssignable(r, a) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, a);
    }
    chStartsBindingIdentifier(r, a) {
      if (super.chStartsBindingIdentifier(r, a)) return !0;
      const u = this.nextTokenStart();
      return this.input.charCodeAt(u) === 37 && this.input.charCodeAt(u + 1) === 37;
    }
    verifyBreakContinue(r, a) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, a);
    }
    parseExpressionStatement(r, a) {
      var u;
      if (a.type !== "Placeholder" || (u = a.extra) != null && u.parenthesized) return super.parseExpressionStatement(r, a);
      if (this.match(14)) {
        const S = r;
        return S.label = this.finishPlaceholder(a, "Identifier"), this.next(), S.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(S, "LabeledStatement");
      }
      this.semicolon();
      const T = r;
      return T.name = a.name, this.finishPlaceholder(T, "Statement");
    }
    parseBlock(r, a, u) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, a, u);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, a, u) {
      const T = a ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const S = this.state.strict, _ = this.parsePlaceholder("Identifier");
      if (_) {
        if (!(this.match(81) || this.match(133) || this.match(5))) {
          if (u || !a) return r.id = null, r.body = this.finishPlaceholder(_, "ClassBody"), this.finishNode(r, T);
          throw this.raise(Zu.ClassNameIsRequired, this.state.startLoc);
        }
        r.id = _;
      } else this.parseClassId(r, a, u);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, S), this.finishNode(r, T);
    }
    parseExport(r, a) {
      const u = this.parsePlaceholder("Identifier");
      if (!u) return super.parseExport(r, a);
      const T = r;
      if (!this.isContextual(98) && !this.match(12)) return T.specifiers = [], T.source = null, T.declaration = this.finishPlaceholder(u, "Declaration"), this.finishNode(T, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const S = this.startNode();
      return S.exported = u, T.specifiers = [this.finishNode(S, "ExportDefaultSpecifier")], super.parseExport(T, a);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(me(133), this.nextTokenStartSince(r + 4))) return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, a) {
      var u;
      return !((u = r.specifiers) == null || !u.length) || super.maybeParseExportDefaultSpecifier(r, a);
    }
    checkExport(r) {
      const { specifiers: a } = r;
      a != null && a.length && (r.specifiers = a.filter((u) => u.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = a;
    }
    parseImport(r) {
      const a = this.parsePlaceholder("Identifier");
      if (!a) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12)) return r.source = this.finishPlaceholder(a, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      const u = this.startNodeAtNode(a);
      return u.local = a, r.specifiers.push(this.finishNode(u, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Zu.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  } }, xT = Object.keys(r1);
  class bT extends fT {
    checkProto(r, a, u, T) {
      if (r.type === "SpreadElement" || this.isObjectMethod(r) || r.computed || r.shorthand) return u;
      const S = r.key;
      return (S.type === "Identifier" ? S.name : S.value) === "__proto__" ? a ? (this.raise(b.RecordNoProto, S), !0) : (u && (T ? T.doubleProtoLoc === null && (T.doubleProtoLoc = S.loc.start) : this.raise(b.DuplicateProto, S)), !0) : u;
    }
    shouldExitDescending(r, a) {
      return r.type === "ArrowFunctionExpression" && this.offsetToSourcePos(r.start) === a;
    }
    getExpression() {
      if (this.enterInitialScopes(), this.nextToken(), this.match(140)) throw this.raise(b.ParseExpressionEmptyInput, this.state.startLoc);
      const r = this.parseExpression();
      if (!this.match(140)) throw this.raise(b.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
      return this.finalizeRemainingComments(), r.comments = this.comments, r.errors = this.state.errors, 256 & this.optionFlags && (r.tokens = this.tokens), r;
    }
    parseExpression(r, a) {
      return r ? this.disallowInAnd(() => this.parseExpressionBase(a)) : this.allowInAnd(() => this.parseExpressionBase(a));
    }
    parseExpressionBase(r) {
      const a = this.state.startLoc, u = this.parseMaybeAssign(r);
      if (this.match(12)) {
        const T = this.startNodeAt(a);
        for (T.expressions = [u]; this.eat(12); ) T.expressions.push(this.parseMaybeAssign(r));
        return this.toReferencedList(T.expressions), this.finishNode(T, "SequenceExpression");
      }
      return u;
    }
    parseMaybeAssignDisallowIn(r, a) {
      return this.disallowInAnd(() => this.parseMaybeAssign(r, a));
    }
    parseMaybeAssignAllowIn(r, a) {
      return this.allowInAnd(() => this.parseMaybeAssign(r, a));
    }
    setOptionalParametersError(r) {
      r.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(r, a) {
      const u = this.state.startLoc, T = this.isContextual(108);
      if (T && this.prodParam.hasYield) {
        this.next();
        let M = this.parseYield(u);
        return a && (M = a.call(this, M, u)), M;
      }
      let S;
      r ? S = !1 : (r = new Oi(), S = !0);
      const { type: _ } = this.state;
      (_ === 10 || se(_)) && (this.state.potentialArrowAt = this.state.start);
      let I = this.parseMaybeConditional(r);
      if (a && (I = a.call(this, I, u)), (R = this.state.type) >= 29 && R <= 33) {
        const M = this.startNodeAt(u), K = this.state.value;
        if (M.operator = K, this.match(29)) {
          this.toAssignable(I, !0), M.left = I;
          const ne = u.index;
          r.doubleProtoLoc != null && r.doubleProtoLoc.index >= ne && (r.doubleProtoLoc = null), r.shorthandAssignLoc != null && r.shorthandAssignLoc.index >= ne && (r.shorthandAssignLoc = null), r.privateKeyLoc != null && r.privateKeyLoc.index >= ne && (this.checkDestructuringPrivate(r), r.privateKeyLoc = null), r.voidPatternLoc != null && r.voidPatternLoc.index >= ne && (r.voidPatternLoc = null);
        } else M.left = I;
        return this.next(), M.right = this.parseMaybeAssign(), this.checkLVal(I, this.finishNode(M, "AssignmentExpression")), M;
      }
      var R;
      if (S && this.checkExpressionErrors(r, !0), T) {
        const { type: M } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ae(M) : ae(M) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(b.YieldNotInGeneratorFunction, u), this.parseYield(u);
      }
      return I;
    }
    parseMaybeConditional(r) {
      const a = this.state.startLoc, u = this.state.potentialArrowAt, T = this.parseExprOps(r);
      return this.shouldExitDescending(T, u) ? T : this.parseConditional(T, a, r);
    }
    parseConditional(r, a, u) {
      if (this.eat(17)) {
        const T = this.startNodeAt(a);
        return T.test = r, T.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), T.alternate = this.parseMaybeAssign(), this.finishNode(T, "ConditionalExpression");
      }
      return r;
    }
    parseMaybeUnaryOrPrivate(r) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(r);
    }
    parseExprOps(r) {
      const a = this.state.startLoc, u = this.state.potentialArrowAt, T = this.parseMaybeUnaryOrPrivate(r);
      return this.shouldExitDescending(T, u) ? T : this.parseExprOp(T, a, -1);
    }
    parseExprOp(r, a, u) {
      if (this.isPrivateName(r)) {
        const _ = this.getPrivateNameSV(r);
        (u >= Oe(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(b.PrivateInExpectedIn, r, { identifierName: _ }), this.classScope.usePrivateName(_, r.loc.start);
      }
      const T = this.state.type;
      if ((S = T) >= 39 && S <= 59 && (this.prodParam.hasIn || !this.match(58))) {
        let _ = Oe(T);
        if (_ > u) {
          if (T === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return r;
            this.checkPipelineAtInfixOperator(r, a);
          }
          const I = this.startNodeAt(a);
          I.left = r, I.operator = this.state.value;
          const R = T === 41 || T === 42, M = T === 40;
          if (M && (_ = Oe(42)), this.next(), T === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(b.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          I.right = this.parseExprOpRightExpr(T, _);
          const K = this.finishNode(I, R || M ? "LogicalExpression" : "BinaryExpression"), ne = this.state.type;
          if (M && (ne === 41 || ne === 42) || R && ne === 40) throw this.raise(b.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(K, a, u);
        }
      }
      var S;
      return r;
    }
    parseExprOpRightExpr(r, a) {
      const u = this.state.startLoc;
      if (r === 39) {
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(a));
        }
        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") return this.withTopicBindingContext(() => {
          if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(b.PipeBodyIsTighter, this.state.startLoc);
          return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(r, a), u);
        });
      }
      return this.parseExprOpBaseRightExpr(r, a);
    }
    parseExprOpBaseRightExpr(r, a) {
      const u = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), u, r === 57 ? a - 1 : a);
    }
    parseHackPipeBody() {
      var r;
      const { startLoc: a } = this.state, u = this.parseMaybeAssign();
      return !g.has(u.type) || (r = u.extra) != null && r.parenthesized || this.raise(b.PipeUnparenthesizedBody, a, { type: u.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(b.PipeTopicUnused, a), u;
    }
    checkExponentialAfterUnary(r) {
      this.match(57) && this.raise(b.UnexpectedTokenUnaryExponentiation, r.argument);
    }
    parseMaybeUnary(r, a) {
      const u = this.state.startLoc, T = this.isContextual(96);
      if (T && this.recordAwaitIfAllowed()) {
        this.next();
        const M = this.parseAwait(u);
        return a || this.checkExponentialAfterUnary(M), M;
      }
      const S = this.match(34), _ = this.startNode();
      if (I = this.state.type, J[I]) {
        _.operator = this.state.value, _.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        const M = this.match(89);
        if (this.next(), _.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(r, !0), this.state.strict && M) {
          const K = _.argument;
          K.type === "Identifier" ? this.raise(b.StrictDelete, _) : this.hasPropertyAsPrivateName(K) && this.raise(b.DeletePrivateField, _);
        }
        if (!S) return a || this.checkExponentialAfterUnary(_), this.finishNode(_, "UnaryExpression");
      }
      var I;
      const R = this.parseUpdate(_, S, r);
      if (T) {
        const { type: M } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ae(M) : ae(M) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(b.AwaitNotInAsyncContext, u), this.parseAwait(u);
      }
      return R;
    }
    parseUpdate(r, a, u) {
      if (a) {
        const _ = r;
        return this.checkLVal(_.argument, this.finishNode(_, "UpdateExpression")), r;
      }
      const T = this.state.startLoc;
      let S = this.parseExprSubscripts(u);
      if (this.checkExpressionErrors(u, !1)) return S;
      for (; fe(this.state.type) && !this.canInsertSemicolon(); ) {
        const _ = this.startNodeAt(T);
        _.operator = this.state.value, _.prefix = !1, _.argument = S, this.next(), this.checkLVal(S, S = this.finishNode(_, "UpdateExpression"));
      }
      return S;
    }
    parseExprSubscripts(r) {
      const a = this.state.startLoc, u = this.state.potentialArrowAt, T = this.parseExprAtom(r);
      return this.shouldExitDescending(T, u) ? T : this.parseSubscripts(T, a);
    }
    parseSubscripts(r, a, u) {
      const T = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(r), stop: !1 };
      do
        r = this.parseSubscript(r, a, u, T), T.maybeAsyncArrow = !1;
      while (!T.stop);
      return r;
    }
    parseSubscript(r, a, u, T) {
      const { type: S } = this.state;
      if (!u && S === 15) return this.parseBind(r, a, u, T);
      if (qe(S)) return this.parseTaggedTemplateExpression(r, a, T);
      let _ = !1;
      if (S === 18) {
        if (u && (this.raise(b.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return this.stopParseSubscript(r, T);
        T.optionalChainMember = _ = !0, this.next();
      }
      if (!u && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(r, a, T, _);
      {
        const I = this.eat(0);
        return I || _ || this.eat(16) ? this.parseMember(r, a, T, I, _) : this.stopParseSubscript(r, T);
      }
    }
    stopParseSubscript(r, a) {
      return a.stop = !0, r;
    }
    parseMember(r, a, u, T, S) {
      const _ = this.startNodeAt(a);
      return _.object = r, _.computed = T, T ? (_.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (r.type === "Super" && this.raise(b.SuperPrivateField, a), this.classScope.usePrivateName(this.state.value, this.state.startLoc), _.property = this.parsePrivateName()) : _.property = this.parseIdentifier(!0), u.optionalChainMember ? (_.optional = S, this.finishNode(_, "OptionalMemberExpression")) : this.finishNode(_, "MemberExpression");
    }
    parseBind(r, a, u, T) {
      const S = this.startNodeAt(a);
      return S.object = r, this.next(), S.callee = this.parseNoCallExpr(), T.stop = !0, this.parseSubscripts(this.finishNode(S, "BindExpression"), a, u);
    }
    parseCoverCallAndAsyncArrowHead(r, a, u, T) {
      const S = this.state.maybeInArrowParameters;
      let _ = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const I = this.startNodeAt(a);
      I.callee = r;
      const { maybeAsyncArrow: R, optionalChainMember: M } = u;
      R && (this.expressionScope.enter(new Wu(2)), _ = new Oi()), M && (I.optional = T), I.arguments = T ? this.parseCallExpressionArguments() : this.parseCallExpressionArguments(r.type !== "Super", I, _);
      let K = this.finishCallExpression(I, M);
      return R && this.shouldParseAsyncArrow() && !T ? (u.stop = !0, this.checkDestructuringPrivate(_), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), K = this.parseAsyncArrowFromCallExpression(this.startNodeAt(a), K)) : (R && (this.checkExpressionErrors(_, !0), this.expressionScope.exit()), this.toReferencedArguments(K)), this.state.maybeInArrowParameters = S, K;
    }
    toReferencedArguments(r, a) {
      this.toReferencedListDeep(r.arguments, a);
    }
    parseTaggedTemplateExpression(r, a, u) {
      const T = this.startNodeAt(a);
      return T.tag = r, T.quasi = this.parseTemplate(!0), u.optionalChainMember && this.raise(b.OptionalChainingNoTemplate, a), this.finishNode(T, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(r) {
      return r.type === "Identifier" && r.name === "async" && this.state.lastTokEndLoc.index === r.end && !this.canInsertSemicolon() && r.end - r.start === 5 && this.offsetToSourcePos(r.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(r, a) {
      if (r.callee.type === "Import") if (r.arguments.length === 0 || r.arguments.length > 2) this.raise(b.ImportCallArity, r);
      else for (const u of r.arguments) u.type === "SpreadElement" && this.raise(b.ImportCallSpreadArgument, u);
      return this.finishNode(r, a ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(r, a, u) {
      const T = [];
      let S = !0;
      const _ = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
        if (S) S = !1;
        else if (this.expect(12), this.match(11)) {
          a && this.addTrailingCommaExtraToNode(a), this.next();
          break;
        }
        T.push(this.parseExprListItem(11, !1, u, r));
      }
      return this.state.inFSharpPipelineDirectBody = _, T;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(r, a) {
      var u;
      return this.resetPreviousNodeTrailingComments(a), this.expect(19), this.parseArrowExpression(r, a.arguments, !0, (u = a.extra) == null ? void 0 : u.trailingCommaLoc), a.innerComments && vn(r, a.innerComments), a.callee.trailingComments && vn(r, a.callee.trailingComments), r;
    }
    parseNoCallExpr() {
      const r = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), r, !0);
    }
    parseExprAtom(r) {
      let a, u = null;
      const { type: T } = this.state;
      switch (T) {
        case 79:
          return this.parseSuper();
        case 83:
          return a = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(a) : this.match(10) ? 512 & this.optionFlags ? this.parseImportCall(a) : this.finishNode(a, "Import") : (this.raise(b.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(a, "Import"));
        case 78:
          return a = this.startNode(), this.next(), this.finishNode(a, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const S = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(S);
        }
        case 0:
          return this.parseArrayLike(3, !0, !1, r);
        case 5:
          return this.parseObjectLike(8, !1, !1, r);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          u = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(u, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          a = this.startNode(), this.next(), a.object = null;
          const S = a.callee = this.parseNoCallExpr();
          if (S.type === "MemberExpression") return this.finishNode(a, "BindExpression");
          throw this.raise(b.UnsupportedBind, S);
        }
        case 139:
          return this.raise(b.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const S = this.getPluginOption("pipelineOperator", "proposal");
          if (S) return this.parseTopicReference(S);
          this.unexpected();
          break;
        }
        case 47: {
          const S = this.input.codePointAt(this.nextTokenStart());
          er(S) || S === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (T === 137) return this.parseDecimalLiteral(this.state.value);
          if (T === 2 || T === 1) return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
          if (T === 6 || T === 7) return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
          if (se(T)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
            const S = this.state.potentialArrowAt === this.state.start, _ = this.state.containsEsc, I = this.parseIdentifier();
            if (!_ && I.name === "async" && !this.canInsertSemicolon()) {
              const { type: R } = this.state;
              if (R === 68) return this.resetPreviousNodeTrailingComments(I), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(I));
              if (se(R)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(I)) : I;
              if (R === 90) return this.resetPreviousNodeTrailingComments(I), this.parseDo(this.startNodeAtNode(I), !0);
            }
            return S && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(I), [I], !1)) : I;
          }
          this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(r, a) {
      const u = this.getPluginOption("pipelineOperator", "proposal");
      if (u) return this.state.type = r, this.state.value = a, this.state.pos--, this.state.end--, this.state.endLoc = n(this.state.endLoc, -1), this.parseTopicReference(u);
      this.unexpected();
    }
    parseTopicReference(r) {
      const a = this.startNode(), u = this.state.startLoc, T = this.state.type;
      return this.next(), this.finishTopicReference(a, u, r, T);
    }
    finishTopicReference(r, a, u, T) {
      if (this.testTopicReferenceConfiguration(u, a, T)) return u === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(b.PipeTopicUnbound, a), this.registerTopicReference(), this.finishNode(r, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(b.PrimaryTopicNotAllowed, a), this.registerTopicReference(), this.finishNode(r, "PipelinePrimaryTopicReference"));
      throw this.raise(b.PipeTopicUnconfiguredToken, a, { token: me(T) });
    }
    testTopicReferenceConfiguration(r, a, u) {
      switch (r) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: me(u) }]);
        case "smart":
          return u === 27;
        default:
          throw this.raise(b.PipeTopicRequiresHackPipes, a);
      }
    }
    parseAsyncArrowUnaryFunction(r) {
      this.prodParam.enter(Ci(!0, this.prodParam.hasYield));
      const a = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(b.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(r, a, !0);
    }
    parseDo(r, a) {
      this.expectPlugin("doExpressions"), a && this.expectPlugin("asyncDoExpressions"), r.async = a, this.next();
      const u = this.state.labels;
      return this.state.labels = [], a ? (this.prodParam.enter(2), r.body = this.parseBlock(), this.prodParam.exit()) : r.body = this.parseBlock(), this.state.labels = u, this.finishNode(r, "DoExpression");
    }
    parseSuper() {
      const r = this.startNode();
      return this.next(), !this.match(10) || this.scope.allowDirectSuper || 16 & this.optionFlags ? this.scope.allowSuper || 16 & this.optionFlags || this.raise(b.UnexpectedSuper, r) : this.raise(b.SuperNotAllowed, r), this.match(10) || this.match(0) || this.match(16) || this.raise(b.UnsupportedSuper, r), this.finishNode(r, "Super");
    }
    parsePrivateName() {
      const r = this.startNode(), a = this.startNodeAt(n(this.state.startLoc, 1)), u = this.state.value;
      return this.next(), r.id = this.createIdentifier(a, u), this.finishNode(r, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const r = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const a = this.createIdentifier(this.startNodeAtNode(r), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(r, a, "sent");
      }
      return this.parseFunction(r);
    }
    parseMetaProperty(r, a, u) {
      r.meta = a;
      const T = this.state.containsEsc;
      return r.property = this.parseIdentifier(!0), (r.property.name !== u || T) && this.raise(b.UnsupportedMetaProperty, r.property, { target: a.name, onlyValidPropertyName: u }), this.finishNode(r, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(r) {
      if (this.next(), this.isContextual(105) || this.isContextual(97)) {
        const a = this.isContextual(105);
        return this.expectPlugin(a ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), r.phase = a ? "source" : "defer", this.parseImportCall(r);
      }
      {
        const a = this.createIdentifierAt(this.startNodeAtNode(r), "import", this.state.lastTokStartLoc);
        return this.isContextual(101) && (this.inModule || this.raise(b.ImportMetaOutsideModule, a), this.sawUnambiguousESM = !0), this.parseMetaProperty(r, a, "meta");
      }
    }
    parseLiteralAtNode(r, a, u) {
      return this.addExtra(u, "rawValue", r), this.addExtra(u, "raw", this.input.slice(this.offsetToSourcePos(u.start), this.state.end)), u.value = r, this.next(), this.finishNode(u, a);
    }
    parseLiteral(r, a) {
      const u = this.startNode();
      return this.parseLiteralAtNode(r, a, u);
    }
    parseStringLiteral(r) {
      return this.parseLiteral(r, "StringLiteral");
    }
    parseNumericLiteral(r) {
      return this.parseLiteral(r, "NumericLiteral");
    }
    parseBigIntLiteral(r) {
      return this.parseLiteral(r, "BigIntLiteral");
    }
    parseDecimalLiteral(r) {
      return this.parseLiteral(r, "DecimalLiteral");
    }
    parseRegExpLiteral(r) {
      const a = this.startNode();
      return this.addExtra(a, "raw", this.input.slice(this.offsetToSourcePos(a.start), this.state.end)), a.pattern = r.pattern, a.flags = r.flags, this.next(), this.finishNode(a, "RegExpLiteral");
    }
    parseBooleanLiteral(r) {
      const a = this.startNode();
      return a.value = r, this.next(), this.finishNode(a, "BooleanLiteral");
    }
    parseNullLiteral() {
      const r = this.startNode();
      return this.next(), this.finishNode(r, "NullLiteral");
    }
    parseParenAndDistinguishExpression(r) {
      const a = this.state.startLoc;
      let u;
      this.next(), this.expressionScope.enter(new Wu(1));
      const T = this.state.maybeInArrowParameters, S = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const _ = this.state.startLoc, I = [], R = new Oi();
      let M, K, ne = !0;
      for (; !this.match(11); ) {
        if (ne) ne = !1;
        else if (this.expect(12, R.optionalParametersLoc === null ? null : R.optionalParametersLoc), this.match(11)) {
          K = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const Pe = this.state.startLoc;
          if (M = this.state.startLoc, I.push(this.parseParenItem(this.parseRestBinding(), Pe)), !this.checkCommaAfterRest(41)) break;
        } else I.push(this.parseMaybeAssignAllowInOrVoidPattern(11, R, this.parseParenItem));
      }
      const ve = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = T, this.state.inFSharpPipelineDirectBody = S;
      let de = this.startNodeAt(a);
      return r && this.shouldParseArrow(I) && (de = this.parseArrow(de)) ? (this.checkDestructuringPrivate(R), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(de, I, !1), de) : (this.expressionScope.exit(), I.length || this.unexpected(this.state.lastTokStartLoc), K && this.unexpected(K), M && this.unexpected(M), this.checkExpressionErrors(R, !0), this.toReferencedListDeep(I, !0), I.length > 1 ? (u = this.startNodeAt(_), u.expressions = I, this.finishNode(u, "SequenceExpression"), this.resetEndLocation(u, ve)) : u = I[0], this.wrapParenthesis(a, u));
    }
    wrapParenthesis(r, a) {
      if (!(1024 & this.optionFlags)) return this.addExtra(a, "parenthesized", !0), this.addExtra(a, "parenStart", r.index), this.takeSurroundingComments(a, r.index, this.state.lastTokEndLoc.index), a;
      const u = this.startNodeAt(r);
      return u.expression = a, this.finishNode(u, "ParenthesizedExpression");
    }
    shouldParseArrow(r) {
      return !this.canInsertSemicolon();
    }
    parseArrow(r) {
      if (this.eat(19)) return r;
    }
    parseParenItem(r, a) {
      return r;
    }
    parseNewOrNewTarget() {
      const r = this.startNode();
      if (this.next(), this.match(16)) {
        const a = this.createIdentifier(this.startNodeAtNode(r), "new");
        this.next();
        const u = this.parseMetaProperty(r, a, "target");
        return this.scope.allowNewTarget || this.raise(b.UnexpectedNewTarget, u), u;
      }
      return this.parseNew(r);
    }
    parseNew(r) {
      if (this.parseNewCallee(r), this.eat(10)) {
        const a = this.parseExprList(11);
        this.toReferencedList(a), r.arguments = a;
      } else r.arguments = [];
      return this.finishNode(r, "NewExpression");
    }
    parseNewCallee(r) {
      const a = this.match(83), u = this.parseNoCallExpr();
      r.callee = u, !a || u.type !== "Import" && u.type !== "ImportExpression" || this.raise(b.ImportCallNotNewExpression, u);
    }
    parseTemplateElement(r) {
      const { start: a, startLoc: u, end: T, value: S } = this.state, _ = a + 1, I = this.startNodeAt(n(u, 1));
      S === null && (r || this.raise(b.InvalidEscapeSequenceTemplate, n(this.state.firstInvalidTemplateEscapePos, 1)));
      const R = this.match(24), M = R ? -1 : -2, K = T + M;
      I.value = { raw: this.input.slice(_, K).replace(/\r\n?/g, `
`), cooked: S === null ? null : S.slice(1, M) }, I.tail = R, this.next();
      const ne = this.finishNode(I, "TemplateElement");
      return this.resetEndLocation(ne, n(this.state.lastTokEndLoc, M)), ne;
    }
    parseTemplate(r) {
      const a = this.startNode();
      let u = this.parseTemplateElement(r);
      const T = [u], S = [];
      for (; !u.tail; ) S.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), T.push(u = this.parseTemplateElement(r));
      return a.expressions = S, a.quasis = T, this.finishNode(a, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(r, a, u, T) {
      u && this.expectPlugin("recordAndTuple");
      const S = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let _ = !1, I = !0;
      const R = this.startNode();
      for (R.properties = [], this.next(); !this.match(r); ) {
        if (I) I = !1;
        else if (this.expect(12), this.match(r)) {
          this.addTrailingCommaExtraToNode(R);
          break;
        }
        let K;
        a ? K = this.parseBindingProperty() : (K = this.parsePropertyDefinition(T), _ = this.checkProto(K, u, _, T)), u && !this.isObjectProperty(K) && K.type !== "SpreadElement" && this.raise(b.InvalidRecordProperty, K), K.shorthand && this.addExtra(K, "shorthand", !0), R.properties.push(K);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = S;
      let M = "ObjectExpression";
      return a ? M = "ObjectPattern" : u && (M = "RecordExpression"), this.finishNode(R, M);
    }
    addTrailingCommaExtraToNode(r) {
      this.addExtra(r, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(r, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(r) {
      return !r.computed && r.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(r) {
      let a = [];
      if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(b.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) a.push(this.parseDecorator());
      const u = this.startNode();
      let T, S = !1, _ = !1;
      if (this.match(21)) return a.length && this.unexpected(), this.parseSpread();
      a.length && (u.decorators = a, a = []), u.method = !1, r && (T = this.state.startLoc);
      let I = this.eat(55);
      this.parsePropertyNamePrefixOperator(u);
      const R = this.state.containsEsc;
      if (this.parsePropertyName(u, r), !I && !R && this.maybeAsyncOrAccessorProp(u)) {
        const { key: M } = u, K = M.name;
        K !== "async" || this.hasPrecedingLineBreak() || (S = !0, this.resetPreviousNodeTrailingComments(M), I = this.eat(55), this.parsePropertyName(u)), K !== "get" && K !== "set" || (_ = !0, this.resetPreviousNodeTrailingComments(M), u.kind = K, this.match(55) && (I = !0, this.raise(b.AccessorIsGenerator, this.state.curPosition(), { kind: K }), this.next()), this.parsePropertyName(u));
      }
      return this.parseObjPropValue(u, T, I, S, !1, _, r);
    }
    getGetterSetterExpectedParamCount(r) {
      return r.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(r) {
      return r.params;
    }
    checkGetterSetterParams(r) {
      var a;
      const u = this.getGetterSetterExpectedParamCount(r), T = this.getObjectOrClassMethodParams(r);
      T.length !== u && this.raise(r.kind === "get" ? b.BadGetterArity : b.BadSetterArity, r), r.kind === "set" && ((a = T[T.length - 1]) == null ? void 0 : a.type) === "RestElement" && this.raise(b.BadSetterRestParameter, r);
    }
    parseObjectMethod(r, a, u, T, S) {
      if (S) {
        const _ = this.parseMethod(r, a, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(_), _;
      }
      if (u || a || this.match(10)) return T && this.unexpected(), r.kind = "method", r.method = !0, this.parseMethod(r, a, u, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(r, a, u, T) {
      if (r.shorthand = !1, this.eat(14)) return r.value = u ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, T), this.finishObjectProperty(r);
      if (!r.computed && r.key.type === "Identifier") {
        if (this.checkReservedWord(r.key.name, r.key.loc.start, !0, !1), u) r.value = this.parseMaybeDefault(a, this.cloneIdentifier(r.key));
        else if (this.match(29)) {
          const S = this.state.startLoc;
          T != null ? T.shorthandAssignLoc === null && (T.shorthandAssignLoc = S) : this.raise(b.InvalidCoverInitializedName, S), r.value = this.parseMaybeDefault(a, this.cloneIdentifier(r.key));
        } else r.value = this.cloneIdentifier(r.key);
        return r.shorthand = !0, this.finishObjectProperty(r);
      }
    }
    finishObjectProperty(r) {
      return this.finishNode(r, "ObjectProperty");
    }
    parseObjPropValue(r, a, u, T, S, _, I) {
      const R = this.parseObjectMethod(r, u, T, S, _) || this.parseObjectProperty(r, a, S, I);
      return R || this.unexpected(), R;
    }
    parsePropertyName(r, a) {
      if (this.eat(0)) r.computed = !0, r.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const { type: u, value: T } = this.state;
        let S;
        if (z(u)) S = this.parseIdentifier(!0);
        else switch (u) {
          case 135:
            S = this.parseNumericLiteral(T);
            break;
          case 134:
            S = this.parseStringLiteral(T);
            break;
          case 136:
            S = this.parseBigIntLiteral(T);
            break;
          case 139: {
            const _ = this.state.startLoc;
            a != null ? a.privateKeyLoc === null && (a.privateKeyLoc = _) : this.raise(b.UnexpectedPrivateField, _), S = this.parsePrivateName();
            break;
          }
          default:
            if (u === 137) {
              S = this.parseDecimalLiteral(T);
              break;
            }
            this.unexpected();
        }
        r.key = S, u !== 139 && (r.computed = !1);
      }
    }
    initFunction(r, a) {
      r.id = null, r.generator = !1, r.async = a;
    }
    parseMethod(r, a, u, T, S, _, I = !1) {
      this.initFunction(r, u), r.generator = a, this.scope.enter(530 | (I ? 576 : 0) | (S ? 32 : 0)), this.prodParam.enter(Ci(u, r.generator)), this.parseFunctionParams(r, T);
      const R = this.parseFunctionBodyAndFinish(r, _, !0);
      return this.prodParam.exit(), this.scope.exit(), R;
    }
    parseArrayLike(r, a, u, T) {
      u && this.expectPlugin("recordAndTuple");
      const S = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const _ = this.startNode();
      return this.next(), _.elements = this.parseExprList(r, !u, T, _), this.state.inFSharpPipelineDirectBody = S, this.finishNode(_, u ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(r, a, u, T) {
      this.scope.enter(518);
      let S = Ci(u, !1);
      !this.match(5) && this.prodParam.hasIn && (S |= 8), this.prodParam.enter(S), this.initFunction(r, u);
      const _ = this.state.maybeInArrowParameters;
      return a && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(r, a, T)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(r, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = _, this.finishNode(r, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(r, a, u) {
      this.toAssignableList(a, u, !1), r.params = a;
    }
    parseFunctionBodyAndFinish(r, a, u = !1) {
      return this.parseFunctionBody(r, !1, u), this.finishNode(r, a);
    }
    parseFunctionBody(r, a, u = !1) {
      const T = a && !this.match(5);
      if (this.expressionScope.enter(Gu()), T) r.body = this.parseMaybeAssign(), this.checkParams(r, !1, a, !1);
      else {
        const S = this.state.strict, _ = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), r.body = this.parseBlock(!0, !1, (I) => {
          const R = !this.isSimpleParamList(r.params);
          I && R && this.raise(b.IllegalLanguageModeDirective, r.kind !== "method" && r.kind !== "constructor" || !r.key ? r : r.key.loc.end);
          const M = !S && this.state.strict;
          this.checkParams(r, !(this.state.strict || a || u || R), a, M), this.state.strict && r.id && this.checkIdentifier(r.id, 65, M);
        }), this.prodParam.exit(), this.state.labels = _;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(r) {
      return r.type === "Identifier";
    }
    isSimpleParamList(r) {
      for (let a = 0, u = r.length; a < u; a++) if (!this.isSimpleParameter(r[a])) return !1;
      return !0;
    }
    checkParams(r, a, u, T = !0) {
      const S = !a && /* @__PURE__ */ new Set(), _ = { type: "FormalParameters" };
      for (const I of r.params) this.checkLVal(I, _, 5, S, T);
    }
    parseExprList(r, a, u, T) {
      const S = [];
      let _ = !0;
      for (; !this.eat(r); ) {
        if (_) _ = !1;
        else if (this.expect(12), this.match(r)) {
          T && this.addTrailingCommaExtraToNode(T), this.next();
          break;
        }
        S.push(this.parseExprListItem(r, a, u));
      }
      return S;
    }
    parseExprListItem(r, a, u, T) {
      let S;
      if (this.match(12)) a || this.raise(b.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), S = null;
      else if (this.match(21)) {
        const _ = this.state.startLoc;
        S = this.parseParenItem(this.parseSpread(u), _);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), T || this.raise(b.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const _ = this.startNode();
        this.next(), S = this.finishNode(_, "ArgumentPlaceholder");
      } else S = this.parseMaybeAssignAllowInOrVoidPattern(r, u, this.parseParenItem);
      return S;
    }
    parseIdentifier(r) {
      const a = this.startNode(), u = this.parseIdentifierName(r);
      return this.createIdentifier(a, u);
    }
    createIdentifier(r, a) {
      return r.name = a, r.loc.identifierName = a, this.finishNode(r, "Identifier");
    }
    createIdentifierAt(r, a, u) {
      return r.name = a, r.loc.identifierName = a, this.finishNodeAt(r, "Identifier", u);
    }
    parseIdentifierName(r) {
      let a;
      const { startLoc: u, type: T } = this.state;
      z(T) ? a = this.state.value : this.unexpected();
      const S = T <= 92;
      return r ? S && this.replaceToken(132) : this.checkReservedWord(a, u, S, !1), this.next(), a;
    }
    checkReservedWord(r, a, u, T) {
      if (!(r.length > 10) && (function(S) {
        return z0.has(S);
      })(r)) {
        if (u && (function(S) {
          return q0.has(S);
        })(r)) return void this.raise(b.UnexpectedKeyword, a, { keyword: r });
        if ((this.state.strict ? T ? ju : Du : Mu)(r, this.inModule)) this.raise(b.UnexpectedReservedWord, a, { reservedWord: r });
        else if (r === "yield") {
          if (this.prodParam.hasYield) return void this.raise(b.YieldBindingIdentifier, a);
        } else if (r === "await") {
          if (this.prodParam.hasAwait) return void this.raise(b.AwaitBindingIdentifier, a);
          if (this.scope.inStaticBlock) return void this.raise(b.AwaitBindingIdentifierInStaticBlock, a);
          this.expressionScope.recordAsyncArrowParametersError(a);
        } else if (r === "arguments" && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(b.ArgumentsInClass, a);
      }
    }
    recordAwaitIfAllowed() {
      const r = this.prodParam.hasAwait;
      return r && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), r;
    }
    parseAwait(r) {
      const a = this.startNodeAt(r);
      return this.expressionScope.recordParameterInitializerError(b.AwaitExpressionFormalParameter, a), this.eat(55) && this.raise(b.ObsoleteAwaitStar, a), this.scope.inFunction || 1 & this.optionFlags || (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (a.argument = this.parseMaybeUnary(null, !0)), this.finishNode(a, "AwaitExpression");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      const { type: r } = this.state;
      return r === 53 || r === 10 || r === 0 || qe(r) || r === 102 && !this.state.containsEsc || r === 138 || r === 56 || this.hasPlugin("v8intrinsic") && r === 54;
    }
    parseYield(r) {
      const a = this.startNodeAt(r);
      this.expressionScope.recordParameterInitializerError(b.YieldInParameter, a);
      let u = !1, T = null;
      if (!this.hasPrecedingLineBreak()) switch (u = this.eat(55), this.state.type) {
        case 13:
        case 140:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!u) break;
        default:
          T = this.parseMaybeAssign();
      }
      return a.delegate = u, a.argument = T, this.finishNode(a, "YieldExpression");
    }
    parseImportCall(r) {
      if (this.next(), r.source = this.parseMaybeAssignAllowIn(), r.options = null, this.eat(12)) {
        if (this.match(11)) this.addTrailingCommaExtraToNode(r.source);
        else if (r.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(r.options), !this.match(11))) {
          do
            this.parseMaybeAssignAllowIn();
          while (this.eat(12) && !this.match(11));
          this.raise(b.ImportCallArity, r);
        }
      }
      return this.expect(11), this.finishNode(r, "ImportExpression");
    }
    checkPipelineAtInfixOperator(r, a) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && r.type === "SequenceExpression" && this.raise(b.PipelineHeadSequenceExpression, a);
    }
    parseSmartPipelineBodyInStyle(r, a) {
      if (this.isSimpleReference(r)) {
        const u = this.startNodeAt(a);
        return u.callee = r, this.finishNode(u, "PipelineBareFunction");
      }
      {
        const u = this.startNodeAt(a);
        return this.checkSmartPipeTopicBodyEarlyErrors(a), u.expression = r, this.finishNode(u, "PipelineTopicExpression");
      }
    }
    isSimpleReference(r) {
      switch (r.type) {
        case "MemberExpression":
          return !r.computed && this.isSimpleReference(r.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(r) {
      if (this.match(19)) throw this.raise(b.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(b.PipelineTopicUnused, r);
    }
    withTopicBindingContext(r) {
      const a = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return r();
      } finally {
        this.state.topicContext = a;
      }
    }
    withSmartMixTopicForbiddingContext(r) {
      if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return r();
      {
        const a = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return r();
        } finally {
          this.state.topicContext = a;
        }
      }
    }
    withSoloAwaitPermittingContext(r) {
      const a = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return r();
      } finally {
        this.state.soloAwait = a;
      }
    }
    allowInAnd(r) {
      const a = this.prodParam.currentFlags();
      if (8 & ~a) {
        this.prodParam.enter(8 | a);
        try {
          return r();
        } finally {
          this.prodParam.exit();
        }
      }
      return r();
    }
    disallowInAnd(r) {
      const a = this.prodParam.currentFlags();
      if (8 & a) {
        this.prodParam.enter(-9 & a);
        try {
          return r();
        } finally {
          this.prodParam.exit();
        }
      }
      return r();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(r) {
      const a = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const u = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const T = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), a, r);
      return this.state.inFSharpPipelineDirectBody = u, T;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const r = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const a = this.startNodeAt(this.state.endLoc);
      this.next();
      const u = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        r.body = this.parseProgram(a, 8, "module");
      } finally {
        u();
      }
      return this.finishNode(r, "ModuleExpression");
    }
    parseVoidPattern(r) {
      this.expectPlugin("discardBinding");
      const a = this.startNode();
      return r != null && (r.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(a, "VoidPattern");
    }
    parseMaybeAssignAllowInOrVoidPattern(r, a, u) {
      if (a != null && this.match(88)) {
        const T = this.lookaheadCharCode();
        if (T === 44 || T === (r === 3 ? 93 : r === 8 ? 125 : 41) || T === 61) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(a));
      }
      return this.parseMaybeAssignAllowIn(a, u);
    }
    parsePropertyNamePrefixOperator(r) {
    }
  }
  const nc = { kind: 1 }, TT = { kind: 2 }, vT = /[\uD800-\uDFFF]/u, ic = /in(?:stanceof)?/y;
  class kT extends bT {
    parseTopLevel(r, a) {
      return r.program = this.parseProgram(a, 140, this.options.sourceType === "module" ? "module" : "script"), r.comments = this.comments, 256 & this.optionFlags && (r.tokens = (function(u, T, S) {
        for (let _ = 0; _ < u.length; _++) {
          const I = u[_], { type: R } = I;
          if (typeof R == "number") {
            if (R === 139) {
              const { loc: M, start: K, value: ne, end: ve } = I, de = K + 1, Pe = n(M.start, 1);
              u.splice(_, 1, new Br({ type: Me(27), value: "#", start: K, end: de, startLoc: M.start, endLoc: Pe }), new Br({ type: Me(132), value: ne, start: de, end: ve, startLoc: Pe, endLoc: M.end })), _++;
              continue;
            }
            if (qe(R)) {
              const { loc: M, start: K, value: ne, end: ve } = I, de = K + 1, Pe = n(M.start, 1);
              let He, ct, Re, nt, En;
              He = T.charCodeAt(K - S) === 96 ? new Br({ type: Me(22), value: "`", start: K, end: de, startLoc: M.start, endLoc: Pe }) : new Br({ type: Me(8), value: "}", start: K, end: de, startLoc: M.start, endLoc: Pe }), R === 24 ? (Re = ve - 1, nt = n(M.end, -1), ct = ne === null ? null : ne.slice(1, -1), En = new Br({ type: Me(22), value: "`", start: Re, end: ve, startLoc: nt, endLoc: M.end })) : (Re = ve - 2, nt = n(M.end, -2), ct = ne === null ? null : ne.slice(1, -2), En = new Br({ type: Me(23), value: "${", start: Re, end: ve, startLoc: nt, endLoc: M.end })), u.splice(_, 1, He, new Br({ type: Me(20), value: ct, start: de, end: Re, startLoc: Pe, endLoc: nt }), En), _ += 2;
              continue;
            }
            I.type = Me(R);
          }
        }
        return u;
      })(this.tokens, this.input, this.startIndex)), this.finishNode(r, "File");
    }
    parseProgram(r, a, u) {
      if (r.sourceType = u, r.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(r, !0, !0, a), this.inModule) {
        if (!(64 & this.optionFlags) && this.scope.undefinedExports.size > 0) for (const [S, _] of Array.from(this.scope.undefinedExports)) this.raise(b.ModuleExportUndefined, _, { localName: S });
        this.addExtra(r, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let T;
      return T = a === 140 ? this.finishNode(r, "Program") : this.finishNodeAt(r, "Program", n(this.state.startLoc, -1)), T;
    }
    stmtToDirective(r) {
      const a = this.castNodeTo(r, "Directive"), u = this.castNodeTo(r.expression, "DirectiveLiteral"), T = u.value, S = this.input.slice(this.offsetToSourcePos(u.start), this.offsetToSourcePos(u.end)), _ = u.value = S.slice(1, -1);
      return this.addExtra(u, "raw", S), this.addExtra(u, "rawValue", _), this.addExtra(u, "expressionValue", T), a.value = u, delete r.expression, a;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null;
      const r = this.startNode();
      return r.value = this.state.value, this.next(), this.finishNode(r, "InterpreterDirective");
    }
    isLet() {
      return !!this.isContextual(100) && this.hasFollowingBindingAtom();
    }
    isUsing() {
      if (!this.isContextual(107)) return !1;
      const r = this.nextTokenInLineStart(), a = this.codePointAtPos(r);
      return this.chStartsBindingIdentifier(a, r);
    }
    isForUsing() {
      if (!this.isContextual(107)) return !1;
      const r = this.nextTokenInLineStart(), a = this.codePointAtPos(r);
      if (this.isUnparsedContextual(r, "of")) {
        const u = this.lookaheadCharCodeSince(r + 2);
        if (u !== 61 && u !== 58 && u !== 59) return !1;
      }
      return !(!this.chStartsBindingIdentifier(a, r) && !this.isUnparsedContextual(r, "void"));
    }
    isAwaitUsing() {
      if (!this.isContextual(96)) return !1;
      let r = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(r, "using")) {
        r = this.nextTokenInLineStartSince(r + 5);
        const a = this.codePointAtPos(r);
        if (this.chStartsBindingIdentifier(a, r)) return !0;
      }
      return !1;
    }
    chStartsBindingIdentifier(r, a) {
      if (er(r)) {
        if (ic.lastIndex = a, ic.test(this.input)) {
          const u = this.codePointAtPos(ic.lastIndex);
          if (!Fr(u) && u !== 92) return !1;
        }
        return !0;
      }
      return r === 92;
    }
    chStartsBindingPattern(r) {
      return r === 91 || r === 123;
    }
    hasFollowingBindingAtom() {
      const r = this.nextTokenStart(), a = this.codePointAtPos(r);
      return this.chStartsBindingPattern(a) || this.chStartsBindingIdentifier(a, r);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      const r = this.nextTokenInLineStart(), a = this.codePointAtPos(r);
      return a === 123 || this.chStartsBindingIdentifier(a, r);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(r = !1) {
      let a = 0;
      return this.options.annexB && !this.state.strict && (a |= 4, r && (a |= 8)), this.parseStatementLike(a);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(r) {
      let a = null;
      return this.match(26) && (a = this.parseDecorators(!0)), this.parseStatementContent(r, a);
    }
    parseStatementContent(r, a) {
      const u = this.state.type, T = this.startNode(), S = !!(2 & r), _ = !!(4 & r), I = 1 & r;
      switch (u) {
        case 60:
          return this.parseBreakContinueStatement(T, !0);
        case 63:
          return this.parseBreakContinueStatement(T, !1);
        case 64:
          return this.parseDebuggerStatement(T);
        case 90:
          return this.parseDoWhileStatement(T);
        case 91:
          return this.parseForStatement(T);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return _ || this.raise(this.state.strict ? b.StrictFunction : this.options.annexB ? b.SloppyFunctionAnnexB : b.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(T, !1, !S && _);
        case 80:
          return S || this.unexpected(), this.parseClass(this.maybeTakeDecorators(a, T), !0);
        case 69:
          return this.parseIfStatement(T);
        case 70:
          return this.parseReturnStatement(T);
        case 71:
          return this.parseSwitchStatement(T);
        case 72:
          return this.parseThrowStatement(T);
        case 73:
          return this.parseTryStatement(T);
        case 96:
          if (this.isAwaitUsing()) return this.allowsUsing() ? S ? this.recordAwaitIfAllowed() || this.raise(b.AwaitUsingNotInAsyncContext, T) : this.raise(b.UnexpectedLexicalDeclaration, T) : this.raise(b.UnexpectedUsingDeclaration, T), this.next(), this.parseVarStatement(T, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
          return this.allowsUsing() ? S || this.raise(b.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(b.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(T, "using");
        case 100: {
          if (this.state.containsEsc) break;
          const K = this.nextTokenStart(), ne = this.codePointAtPos(K);
          if (ne !== 91 && (!S && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(ne, K) && ne !== 123))
            break;
        }
        case 75:
          S || this.raise(b.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const K = this.state.value;
          return this.parseVarStatement(T, K);
        }
        case 92:
          return this.parseWhileStatement(T);
        case 76:
          return this.parseWithStatement(T);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(T);
        case 83: {
          const K = this.lookaheadCharCode();
          if (K === 40 || K === 46) break;
        }
        case 82: {
          let K;
          return 8 & this.optionFlags || I || this.raise(b.UnexpectedImportExport, this.state.startLoc), this.next(), K = u === 83 ? this.parseImport(T) : this.parseExport(T, a), this.assertModuleNodeAllowed(K), K;
        }
        default:
          if (this.isAsyncFunction()) return S || this.raise(b.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(T, !0, !S && _);
      }
      const R = this.state.value, M = this.parseExpression();
      return se(u) && M.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(T, R, M, r) : this.parseExpressionStatement(T, M, a);
    }
    assertModuleNodeAllowed(r) {
      8 & this.optionFlags || this.inModule || this.raise(b.ImportOutsideModule, r);
    }
    decoratorsEnabledBeforeExport() {
      return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(r, a, u) {
      var T;
      return r && ((T = a.decorators) != null && T.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(b.DecoratorsBeforeAfterExport, a.decorators[0]), a.decorators.unshift(...r)) : a.decorators = r, this.resetStartLocationFromNode(a, r[0]), u && this.resetStartLocationFromNode(u, a)), a;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(r) {
      const a = [];
      do
        a.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82)) r || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(b.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator()) throw this.raise(b.UnexpectedLeadingDecorator, this.state.startLoc);
      return a;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const r = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const a = this.state.startLoc;
        let u;
        if (this.match(10)) {
          const T = this.state.startLoc;
          this.next(), u = this.parseExpression(), this.expect(11), u = this.wrapParenthesis(T, u);
          const S = this.state.startLoc;
          r.expression = this.parseMaybeDecoratorArguments(u, T), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && r.expression !== u && this.raise(b.DecoratorArgumentsOutsideParentheses, S);
        } else {
          for (u = this.parseIdentifier(!1); this.eat(16); ) {
            const T = this.startNodeAt(a);
            T.object = u, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), T.property = this.parsePrivateName()) : T.property = this.parseIdentifier(!0), T.computed = !1, u = this.finishNode(T, "MemberExpression");
          }
          r.expression = this.parseMaybeDecoratorArguments(u, a);
        }
      } else r.expression = this.parseExprSubscripts();
      return this.finishNode(r, "Decorator");
    }
    parseMaybeDecoratorArguments(r, a) {
      if (this.eat(10)) {
        const u = this.startNodeAt(a);
        return u.callee = r, u.arguments = this.parseCallExpressionArguments(), this.toReferencedList(u.arguments), this.finishNode(u, "CallExpression");
      }
      return r;
    }
    parseBreakContinueStatement(r, a) {
      return this.next(), this.isLineTerminator() ? r.label = null : (r.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(r, a), this.finishNode(r, a ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(r, a) {
      let u;
      for (u = 0; u < this.state.labels.length; ++u) {
        const T = this.state.labels[u];
        if ((r.label == null || T.name === r.label.name) && (T.kind != null && (a || T.kind === 1) || r.label && a))
          break;
      }
      if (u === this.state.labels.length) {
        const T = a ? "BreakStatement" : "ContinueStatement";
        this.raise(b.IllegalBreakContinue, r, { type: T });
      }
    }
    parseDebuggerStatement(r) {
      return this.next(), this.semicolon(), this.finishNode(r, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const r = this.parseExpression();
      return this.expect(11), r;
    }
    parseDoWhileStatement(r) {
      return this.next(), this.state.labels.push(nc), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), r.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(r, "DoWhileStatement");
    }
    parseForStatement(r) {
      this.next(), this.state.labels.push(nc);
      let a = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (a = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return a !== null && this.unexpected(a), this.parseFor(r, null);
      const u = this.isContextual(100);
      {
        const R = this.isAwaitUsing(), M = R || this.isForUsing(), K = u && this.hasFollowingBindingAtom() || M;
        if (this.match(74) || this.match(75) || K) {
          const ne = this.startNode();
          let ve;
          R ? (ve = "await using", this.recordAwaitIfAllowed() || this.raise(b.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : ve = this.state.value, this.next(), this.parseVar(ne, !0, ve);
          const de = this.finishNode(ne, "VariableDeclaration"), Pe = this.match(58);
          return Pe && M && this.raise(b.ForInUsing, de), (Pe || this.isContextual(102)) && de.declarations.length === 1 ? this.parseForIn(r, de, a) : (a !== null && this.unexpected(a), this.parseFor(r, de));
        }
      }
      const T = this.isContextual(95), S = new Oi(), _ = this.parseExpression(!0, S), I = this.isContextual(102);
      if (I && (u && this.raise(b.ForOfLet, _), a === null && T && _.type === "Identifier" && this.raise(b.ForOfAsync, _)), I || this.match(58)) {
        this.checkDestructuringPrivate(S), this.toAssignable(_, !0);
        const R = I ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(_, { type: R }), this.parseForIn(r, _, a);
      }
      return this.checkExpressionErrors(S, !0), a !== null && this.unexpected(a), this.parseFor(r, _);
    }
    parseFunctionStatement(r, a, u) {
      return this.next(), this.parseFunction(r, 1 | (u ? 2 : 0) | (a ? 8 : 0));
    }
    parseIfStatement(r) {
      return this.next(), r.test = this.parseHeaderExpression(), r.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), r.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(r, "IfStatement");
    }
    parseReturnStatement(r) {
      return this.prodParam.hasReturn || this.raise(b.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? r.argument = null : (r.argument = this.parseExpression(), this.semicolon()), this.finishNode(r, "ReturnStatement");
    }
    parseSwitchStatement(r) {
      this.next(), r.discriminant = this.parseHeaderExpression();
      const a = r.cases = [];
      let u;
      this.expect(5), this.state.labels.push(TT), this.scope.enter(256);
      for (let T; !this.match(8); ) if (this.match(61) || this.match(65)) {
        const S = this.match(61);
        u && this.finishNode(u, "SwitchCase"), a.push(u = this.startNode()), u.consequent = [], this.next(), S ? u.test = this.parseExpression() : (T && this.raise(b.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), T = !0, u.test = null), this.expect(14);
      } else u ? u.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), u && this.finishNode(u, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(r, "SwitchStatement");
    }
    parseThrowStatement(r) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(b.NewlineAfterThrow, this.state.lastTokEndLoc), r.argument = this.parseExpression(), this.semicolon(), this.finishNode(r, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const r = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && r.type === "Identifier" ? 8 : 0), this.checkLVal(r, { type: "CatchClause" }, 9), r;
    }
    parseTryStatement(r) {
      if (this.next(), r.block = this.parseBlock(), r.handler = null, this.match(62)) {
        const a = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), a.param = this.parseCatchClauseParam(), this.expect(11)) : (a.param = null, this.scope.enter(0)), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), r.handler = this.finishNode(a, "CatchClause");
      }
      return r.finalizer = this.eat(67) ? this.parseBlock() : null, r.handler || r.finalizer || this.raise(b.NoCatchOrFinally, r), this.finishNode(r, "TryStatement");
    }
    parseVarStatement(r, a, u = !1) {
      return this.next(), this.parseVar(r, !1, a, u), this.semicolon(), this.finishNode(r, "VariableDeclaration");
    }
    parseWhileStatement(r) {
      return this.next(), r.test = this.parseHeaderExpression(), this.state.labels.push(nc), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(r, "WhileStatement");
    }
    parseWithStatement(r) {
      return this.state.strict && this.raise(b.StrictWith, this.state.startLoc), this.next(), r.object = this.parseHeaderExpression(), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(r, "WithStatement");
    }
    parseEmptyStatement(r) {
      return this.next(), this.finishNode(r, "EmptyStatement");
    }
    parseLabeledStatement(r, a, u, T) {
      for (const I of this.state.labels) I.name === a && this.raise(b.LabelRedeclaration, u, { labelName: a });
      const S = (_ = this.state.type) >= 90 && _ <= 92 ? 1 : this.match(71) ? 2 : null;
      var _;
      for (let I = this.state.labels.length - 1; I >= 0; I--) {
        const R = this.state.labels[I];
        if (R.statementStart !== r.start) break;
        R.statementStart = this.sourceToOffsetPos(this.state.start), R.kind = S;
      }
      return this.state.labels.push({ name: a, kind: S, statementStart: this.sourceToOffsetPos(this.state.start) }), r.body = 8 & T ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), r.label = u, this.finishNode(r, "LabeledStatement");
    }
    parseExpressionStatement(r, a, u) {
      return r.expression = a, this.semicolon(), this.finishNode(r, "ExpressionStatement");
    }
    parseBlock(r = !1, a = !0, u) {
      const T = this.startNode();
      return r && this.state.strictErrors.clear(), this.expect(5), a && this.scope.enter(0), this.parseBlockBody(T, r, !1, 8, u), a && this.scope.exit(), this.finishNode(T, "BlockStatement");
    }
    isValidDirective(r) {
      return r.type === "ExpressionStatement" && r.expression.type === "StringLiteral" && !r.expression.extra.parenthesized;
    }
    parseBlockBody(r, a, u, T, S) {
      const _ = r.body = [], I = r.directives = [];
      this.parseBlockOrModuleBlockBody(_, a ? I : void 0, u, T, S);
    }
    parseBlockOrModuleBlockBody(r, a, u, T, S) {
      const _ = this.state.strict;
      let I = !1, R = !1;
      for (; !this.match(T); ) {
        const M = u ? this.parseModuleItem() : this.parseStatementListItem();
        if (a && !R) {
          if (this.isValidDirective(M)) {
            const K = this.stmtToDirective(M);
            a.push(K), I || K.value.value !== "use strict" || (I = !0, this.setStrict(!0));
            continue;
          }
          R = !0, this.state.strictErrors.clear();
        }
        r.push(M);
      }
      S?.call(this, I), _ || this.setStrict(!1), this.next();
    }
    parseFor(r, a) {
      return r.init = a, this.semicolon(!1), r.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), r.update = this.match(11) ? null : this.parseExpression(), this.expect(11), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(r, "ForStatement");
    }
    parseForIn(r, a, u) {
      const T = this.match(58);
      return this.next(), T ? u !== null && this.unexpected(u) : r.await = u !== null, a.type !== "VariableDeclaration" || a.declarations[0].init == null || T && this.options.annexB && !this.state.strict && a.kind === "var" && a.declarations[0].id.type === "Identifier" || this.raise(b.ForInOfLoopInitializer, a, { type: T ? "ForInStatement" : "ForOfStatement" }), a.type === "AssignmentPattern" && this.raise(b.InvalidLhs, a, { ancestor: { type: "ForStatement" } }), r.left = a, r.right = T ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(r, T ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(r, a, u, T = !1) {
      const S = r.declarations = [];
      for (r.kind = u; ; ) {
        const _ = this.startNode();
        if (this.parseVarId(_, u), _.init = this.eat(29) ? a ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, _.init !== null || T || (_.id.type === "Identifier" || a && (this.match(58) || this.isContextual(102)) ? u !== "const" && u !== "using" && u !== "await using" || this.match(58) || this.isContextual(102) || this.raise(b.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: u }) : this.raise(b.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), S.push(this.finishNode(_, "VariableDeclarator")), !this.eat(12)) break;
      }
      return r;
    }
    parseVarId(r, a) {
      const u = this.parseBindingAtom();
      a === "using" || a === "await using" ? u.type !== "ArrayPattern" && u.type !== "ObjectPattern" || this.raise(b.UsingDeclarationHasBindingPattern, u.loc.start) : u.type === "VoidPattern" && this.raise(b.UnexpectedVoidPattern, u.loc.start), this.checkLVal(u, { type: "VariableDeclarator" }, a === "var" ? 5 : 8201), r.id = u;
    }
    parseAsyncFunctionExpression(r) {
      return this.parseFunction(r, 8);
    }
    parseFunction(r, a = 0) {
      const u = 2 & a, T = !!(1 & a), S = T && !(4 & a), _ = !!(8 & a);
      this.initFunction(r, _), this.match(55) && (u && this.raise(b.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), r.generator = !0), T && (r.id = this.parseFunctionId(S));
      const I = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(Ci(_, r.generator)), T || (r.id = this.parseFunctionId()), this.parseFunctionParams(r, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(r, T ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), T && !u && this.registerFunctionStatementId(r), this.state.maybeInArrowParameters = I, r;
    }
    parseFunctionId(r) {
      return r || se(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(r, a) {
      this.expect(10), this.expressionScope.enter(new Ni(3)), r.params = this.parseBindingList(11, 41, 2 | (a ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(r) {
      r.id && this.scope.declareName(r.id.name, !this.options.annexB || this.state.strict || r.generator || r.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, r.id.loc.start);
    }
    parseClass(r, a, u) {
      this.next();
      const T = this.state.strict;
      return this.state.strict = !0, this.parseClassId(r, a, u), this.parseClassSuper(r), r.body = this.parseClassBody(!!r.superClass, T), this.finishNode(r, a ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(r) {
      return r.type === "Identifier" && r.name === "constructor" || r.type === "StringLiteral" && r.value === "constructor";
    }
    isNonstaticConstructor(r) {
      return !r.computed && !r.static && this.nameIsConstructor(r.key);
    }
    parseClassBody(r, a) {
      this.classScope.enter();
      const u = { hadConstructor: !1, hadSuperClass: r };
      let T = [];
      const S = this.startNode();
      if (S.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (T.length > 0) throw this.raise(b.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            T.push(this.parseDecorator());
            continue;
          }
          const _ = this.startNode();
          T.length && (_.decorators = T, this.resetStartLocationFromNode(_, T[0]), T = []), this.parseClassMember(S, _, u), _.kind === "constructor" && _.decorators && _.decorators.length > 0 && this.raise(b.DecoratorConstructor, _);
        }
      }), this.state.strict = a, this.next(), T.length) throw this.raise(b.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(S, "ClassBody");
    }
    parseClassMemberFromModifier(r, a) {
      const u = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const T = a;
        return T.kind = "method", T.computed = !1, T.key = u, T.static = !1, this.pushClassMethod(r, T, !1, !1, !1, !1), !0;
      }
      if (this.isClassProperty()) {
        const T = a;
        return T.computed = !1, T.key = u, T.static = !1, r.body.push(this.parseClassProperty(T)), !0;
      }
      return this.resetPreviousNodeTrailingComments(u), !1;
    }
    parseClassMember(r, a, u) {
      const T = this.isContextual(106);
      if (T) {
        if (this.parseClassMemberFromModifier(r, a)) return;
        if (this.eat(5)) return void this.parseClassStaticBlock(r, a);
      }
      this.parseClassMemberWithIsStatic(r, a, u, T);
    }
    parseClassMemberWithIsStatic(r, a, u, T) {
      const S = a, _ = a, I = a, R = a, M = a, K = S, ne = S;
      if (a.static = T, this.parsePropertyNamePrefixOperator(a), this.eat(55)) {
        K.kind = "method";
        const Re = this.match(139);
        return this.parseClassElementName(K), this.parsePostMemberNameModifiers(K), Re ? void this.pushClassPrivateMethod(r, _, !0, !1) : (this.isNonstaticConstructor(S) && this.raise(b.ConstructorIsGenerator, S.key), void this.pushClassMethod(r, S, !0, !1, !1, !1));
      }
      const ve = !this.state.containsEsc && se(this.state.type), de = this.parseClassElementName(a), Pe = ve ? de.name : null, He = this.isPrivateName(de), ct = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(ne), this.isClassMethod()) {
        if (K.kind = "method", He) return void this.pushClassPrivateMethod(r, _, !1, !1);
        const Re = this.isNonstaticConstructor(S);
        let nt = !1;
        Re && (S.kind = "constructor", u.hadConstructor && !this.hasPlugin("typescript") && this.raise(b.DuplicateConstructor, de), Re && this.hasPlugin("typescript") && a.override && this.raise(b.OverrideOnConstructor, de), u.hadConstructor = !0, nt = u.hadSuperClass), this.pushClassMethod(r, S, !1, !1, Re, nt);
      } else if (this.isClassProperty()) He ? this.pushClassPrivateProperty(r, R) : this.pushClassProperty(r, I);
      else if (Pe !== "async" || this.isLineTerminator()) if (Pe !== "get" && Pe !== "set" || this.match(55) && this.isLineTerminator()) if (Pe !== "accessor" || this.isLineTerminator()) this.isLineTerminator() ? He ? this.pushClassPrivateProperty(r, R) : this.pushClassProperty(r, I) : this.unexpected();
      else {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(de);
        const Re = this.match(139);
        this.parseClassElementName(I), this.pushClassAccessorProperty(r, M, Re);
      }
      else {
        this.resetPreviousNodeTrailingComments(de), K.kind = Pe;
        const Re = this.match(139);
        this.parseClassElementName(S), Re ? this.pushClassPrivateMethod(r, _, !1, !1) : (this.isNonstaticConstructor(S) && this.raise(b.ConstructorIsAccessor, S.key), this.pushClassMethod(r, S, !1, !1, !1, !1)), this.checkGetterSetterParams(S);
      }
      else {
        this.resetPreviousNodeTrailingComments(de);
        const Re = this.eat(55);
        ne.optional && this.unexpected(ct), K.kind = "method";
        const nt = this.match(139);
        this.parseClassElementName(K), this.parsePostMemberNameModifiers(ne), nt ? this.pushClassPrivateMethod(r, _, Re, !0) : (this.isNonstaticConstructor(S) && this.raise(b.ConstructorIsAsync, S.key), this.pushClassMethod(r, S, Re, !0, !1, !1));
      }
    }
    parseClassElementName(r) {
      const { type: a, value: u } = this.state;
      if (a !== 132 && a !== 134 || !r.static || u !== "prototype" || this.raise(b.StaticPrototype, this.state.startLoc), a === 139) {
        u === "constructor" && this.raise(b.ConstructorClassPrivateField, this.state.startLoc);
        const T = this.parsePrivateName();
        return r.key = T, T;
      }
      return this.parsePropertyName(r), r.key;
    }
    parseClassStaticBlock(r, a) {
      var u;
      this.scope.enter(720);
      const T = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const S = a.body = [];
      this.parseBlockOrModuleBlockBody(S, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = T, r.body.push(this.finishNode(a, "StaticBlock")), (u = a.decorators) != null && u.length && this.raise(b.DecoratorStaticBlock, a);
    }
    pushClassProperty(r, a) {
      !a.computed && this.nameIsConstructor(a.key) && this.raise(b.ConstructorClassField, a.key), r.body.push(this.parseClassProperty(a));
    }
    pushClassPrivateProperty(r, a) {
      const u = this.parseClassPrivateProperty(a);
      r.body.push(u), this.classScope.declarePrivateName(this.getPrivateNameSV(u.key), 0, u.key.loc.start);
    }
    pushClassAccessorProperty(r, a, u) {
      u || a.computed || !this.nameIsConstructor(a.key) || this.raise(b.ConstructorClassField, a.key);
      const T = this.parseClassAccessorProperty(a);
      r.body.push(T), u && this.classScope.declarePrivateName(this.getPrivateNameSV(T.key), 0, T.key.loc.start);
    }
    pushClassMethod(r, a, u, T, S, _) {
      r.body.push(this.parseMethod(a, u, T, S, _, "ClassMethod", !0));
    }
    pushClassPrivateMethod(r, a, u, T) {
      const S = this.parseMethod(a, u, T, !1, !1, "ClassPrivateMethod", !0);
      r.body.push(S);
      const _ = S.kind === "get" ? S.static ? 6 : 2 : S.kind === "set" ? S.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(S, _);
    }
    declareClassPrivateMethodInScope(r, a) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), a, r.key.loc.start);
    }
    parsePostMemberNameModifiers(r) {
    }
    parseClassPrivateProperty(r) {
      return this.parseInitializer(r), this.semicolon(), this.finishNode(r, "ClassPrivateProperty");
    }
    parseClassProperty(r) {
      return this.parseInitializer(r), this.semicolon(), this.finishNode(r, "ClassProperty");
    }
    parseClassAccessorProperty(r) {
      return this.parseInitializer(r), this.semicolon(), this.finishNode(r, "ClassAccessorProperty");
    }
    parseInitializer(r) {
      this.scope.enter(592), this.expressionScope.enter(Gu()), this.prodParam.enter(0), r.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(r, a, u, T = 8331) {
      if (se(this.state.type)) r.id = this.parseIdentifier(), a && this.declareNameFromIdentifier(r.id, T);
      else {
        if (!u && a) throw this.raise(b.MissingClassName, this.state.startLoc);
        r.id = null;
      }
    }
    parseClassSuper(r) {
      r.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(r, a) {
      const u = this.parseMaybeImportPhase(r, !0), T = this.maybeParseExportDefaultSpecifier(r, u), S = !T || this.eat(12), _ = S && this.eatExportStar(r), I = _ && this.maybeParseExportNamespaceSpecifier(r), R = S && (!I || this.eat(12)), M = T || _;
      if (_ && !I) {
        if (T && this.unexpected(), a) throw this.raise(b.UnsupportedDecoratorExport, r);
        return this.parseExportFrom(r, !0), this.sawUnambiguousESM = !0, this.finishNode(r, "ExportAllDeclaration");
      }
      const K = this.maybeParseExportNamedSpecifiers(r);
      let ne;
      if (T && S && !_ && !K && this.unexpected(null, 5), I && R && this.unexpected(null, 98), M || K) {
        if (ne = !1, a) throw this.raise(b.UnsupportedDecoratorExport, r);
        this.parseExportFrom(r, M);
      } else ne = this.maybeParseExportDeclaration(r);
      if (M || K || ne) {
        var ve;
        const de = r;
        if (this.checkExport(de, !0, !1, !!de.source), ((ve = de.declaration) == null ? void 0 : ve.type) === "ClassDeclaration") this.maybeTakeDecorators(a, de.declaration, de);
        else if (a) throw this.raise(b.UnsupportedDecoratorExport, r);
        return this.sawUnambiguousESM = !0, this.finishNode(de, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const de = r, Pe = this.parseExportDefaultExpression();
        if (de.declaration = Pe, Pe.type === "ClassDeclaration") this.maybeTakeDecorators(a, Pe, de);
        else if (a) throw this.raise(b.UnsupportedDecoratorExport, r);
        return this.checkExport(de, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(de, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(r) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(r, a) {
      if (a || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", a?.loc.start);
        const u = a || this.parseIdentifier(!0), T = this.startNodeAtNode(u);
        return T.exported = u, r.specifiers = [this.finishNode(T, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      if (this.isContextual(93)) {
        var a;
        (a = r).specifiers != null || (a.specifiers = []);
        const u = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), u.exported = this.parseModuleExportName(), r.specifiers.push(this.finishNode(u, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(r) {
      if (this.match(5)) {
        const a = r;
        a.specifiers || (a.specifiers = []);
        const u = a.exportKind === "type";
        return a.specifiers.push(...this.parseExportSpecifiers(u)), a.source = null, this.hasPlugin("importAssertions") ? a.assertions = [] : a.attributes = [], a.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(r) {
      return !!this.shouldParseExportDeclaration() && (r.specifiers = [], r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] : r.attributes = [], r.declaration = this.parseExportDeclaration(r), !0);
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      const r = this.nextTokenInLineStart();
      return this.isUnparsedContextual(r, "function");
    }
    parseExportDefaultExpression() {
      const r = this.startNode();
      if (this.match(68)) return this.next(), this.parseFunction(r, 5);
      if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(r, 13);
      if (this.match(80)) return this.parseClass(r, !0, !0);
      if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(b.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(b.UnsupportedDefaultExport, this.state.startLoc);
      const a = this.parseMaybeAssignAllowIn();
      return this.semicolon(), a;
    }
    parseExportDeclaration(r) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const { type: r } = this.state;
      if (se(r)) {
        if (r === 95 && !this.state.containsEsc || r === 100) return !1;
        if ((r === 130 || r === 129) && !this.state.containsEsc) {
          const T = this.nextTokenStart(), S = this.input.charCodeAt(T);
          if (S === 123 || this.chStartsBindingIdentifier(S, T) && !this.input.startsWith("from", T)) return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65)) return !1;
      const a = this.nextTokenStart(), u = this.isUnparsedContextual(a, "from");
      if (this.input.charCodeAt(a) === 44 || se(this.state.type) && u) return !0;
      if (this.match(65) && u) {
        const T = this.input.charCodeAt(this.nextTokenStartSince(a + 4));
        return T === 34 || T === 39;
      }
      return !1;
    }
    parseExportFrom(r, a) {
      this.eatContextual(98) ? (r.source = this.parseImportSource(), this.checkExport(r), this.maybeParseImportAttributes(r), this.checkJSONModuleImport(r)) : a && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const { type: r } = this.state;
      return r === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(b.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() || this.isAwaitUsing() ? (this.raise(b.UsingDeclarationExport, this.state.startLoc), !0) : r === 74 || r === 75 || r === 68 || r === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(r, a, u, T) {
      var S;
      if (a) {
        if (u) {
          if (this.checkDuplicateExports(r, "default"), this.hasPlugin("exportDefaultFrom")) {
            var _;
            const I = r.declaration;
            I.type !== "Identifier" || I.name !== "from" || I.end - I.start !== 4 || (_ = I.extra) != null && _.parenthesized || this.raise(b.ExportDefaultFromAsIdentifier, I);
          }
        } else if ((S = r.specifiers) != null && S.length) for (const I of r.specifiers) {
          const { exported: R } = I, M = R.type === "Identifier" ? R.name : R.value;
          if (this.checkDuplicateExports(I, M), !T && I.local) {
            const { local: K } = I;
            K.type !== "Identifier" ? this.raise(b.ExportBindingIsString, I, { localName: K.value, exportName: M }) : (this.checkReservedWord(K.name, K.loc.start, !0, !1), this.scope.checkLocalExport(K));
          }
        }
        else if (r.declaration) {
          const I = r.declaration;
          if (I.type === "FunctionDeclaration" || I.type === "ClassDeclaration") {
            const { id: R } = I;
            if (!R) throw new Error("Assertion failure");
            this.checkDuplicateExports(r, R.name);
          } else if (I.type === "VariableDeclaration") for (const R of I.declarations) this.checkDeclaration(R.id);
        }
      }
    }
    checkDeclaration(r) {
      if (r.type === "Identifier") this.checkDuplicateExports(r, r.name);
      else if (r.type === "ObjectPattern") for (const a of r.properties) this.checkDeclaration(a);
      else if (r.type === "ArrayPattern") for (const a of r.elements) a && this.checkDeclaration(a);
      else r.type === "ObjectProperty" ? this.checkDeclaration(r.value) : r.type === "RestElement" ? this.checkDeclaration(r.argument) : r.type === "AssignmentPattern" && this.checkDeclaration(r.left);
    }
    checkDuplicateExports(r, a) {
      this.exportedIdentifiers.has(a) && (a === "default" ? this.raise(b.DuplicateDefaultExport, r) : this.raise(b.DuplicateExport, r, { exportName: a })), this.exportedIdentifiers.add(a);
    }
    parseExportSpecifiers(r) {
      const a = [];
      let u = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (u) u = !1;
        else if (this.expect(12), this.eat(8)) break;
        const T = this.isContextual(130), S = this.match(134), _ = this.startNode();
        _.local = this.parseModuleExportName(), a.push(this.parseExportSpecifier(_, S, r, T));
      }
      return a;
    }
    parseExportSpecifier(r, a, u, T) {
      return this.eatContextual(93) ? r.exported = this.parseModuleExportName() : a ? r.exported = this.cloneStringLiteral(r.local) : r.exported || (r.exported = this.cloneIdentifier(r.local)), this.finishNode(r, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        const r = this.parseStringLiteral(this.state.value), a = vT.exec(r.value);
        return a && this.raise(b.ModuleExportNameHasLoneSurrogate, r, { surrogateCharCode: a[0].charCodeAt(0) }), r;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(r) {
      return r.assertions != null && r.assertions.some(({ key: a, value: u }) => u.value === "json" && (a.type === "Identifier" ? a.name === "type" : a.value === "type"));
    }
    checkImportReflection(r) {
      const { specifiers: a } = r, u = a.length === 1 ? a[0].type : null;
      if (r.phase === "source") u !== "ImportDefaultSpecifier" && this.raise(b.SourcePhaseImportRequiresDefault, a[0].loc.start);
      else if (r.phase === "defer") u !== "ImportNamespaceSpecifier" && this.raise(b.DeferImportRequiresNamespace, a[0].loc.start);
      else if (r.module) {
        var T;
        u !== "ImportDefaultSpecifier" && this.raise(b.ImportReflectionNotBinding, a[0].loc.start), ((T = r.assertions) == null ? void 0 : T.length) > 0 && this.raise(b.ImportReflectionHasAssertion, a[0].loc.start);
      }
    }
    checkJSONModuleImport(r) {
      if (this.isJSONModuleImport(r) && r.type !== "ExportAllDeclaration") {
        const { specifiers: a } = r;
        if (a != null) {
          const u = a.find((T) => {
            let S;
            if (T.type === "ExportSpecifier" ? S = T.local : T.type === "ImportSpecifier" && (S = T.imported), S !== void 0) return S.type === "Identifier" ? S.name !== "default" : S.value !== "default";
          });
          u !== void 0 && this.raise(b.ImportJSONBindingNotDefault, u.loc.start);
        }
      }
    }
    isPotentialImportPhase(r) {
      return !r && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
    }
    applyImportPhase(r, a, u, T) {
      a || (u === "module" ? (this.expectPlugin("importReflection", T), r.module = !0) : this.hasPlugin("importReflection") && (r.module = !1), u === "source" ? (this.expectPlugin("sourcePhaseImports", T), r.phase = "source") : u === "defer" ? (this.expectPlugin("deferredImportEvaluation", T), r.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (r.phase = null));
    }
    parseMaybeImportPhase(r, a) {
      if (!this.isPotentialImportPhase(a)) return this.applyImportPhase(r, a, null), null;
      const u = this.startNode(), T = this.parseIdentifierName(!0), { type: S } = this.state;
      return (z(S) ? S !== 98 || this.lookaheadCharCode() === 102 : S !== 12) ? (this.applyImportPhase(r, a, T, u.loc.start), null) : (this.applyImportPhase(r, a, null), this.createIdentifier(u, T));
    }
    isPrecedingIdImportPhase(r) {
      const { type: a } = this.state;
      return se(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12;
    }
    parseImport(r) {
      return this.match(134) ? this.parseImportSourceAndAttributes(r) : this.parseImportSpecifiersAndAfter(r, this.parseMaybeImportPhase(r, !1));
    }
    parseImportSpecifiersAndAfter(r, a) {
      r.specifiers = [];
      const u = !this.maybeParseDefaultImportSpecifier(r, a) || this.eat(12), T = u && this.maybeParseStarImportSpecifier(r);
      return u && !T && this.parseNamedImportSpecifiers(r), this.expectContextual(98), this.parseImportSourceAndAttributes(r);
    }
    parseImportSourceAndAttributes(r) {
      return r.specifiers != null || (r.specifiers = []), r.source = this.parseImportSource(), this.maybeParseImportAttributes(r), this.checkImportReflection(r), this.checkJSONModuleImport(r), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(r, a, u) {
      a.local = this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(a, u));
    }
    finishImportSpecifier(r, a, u = 8201) {
      return this.checkLVal(r.local, { type: a }, u), this.finishNode(r, a);
    }
    parseImportAttributes() {
      this.expect(5);
      const r = [], a = /* @__PURE__ */ new Set();
      do {
        if (this.match(8)) break;
        const u = this.startNode(), T = this.state.value;
        if (a.has(T) && this.raise(b.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: T }), a.add(T), this.match(134) ? u.key = this.parseStringLiteral(T) : u.key = this.parseIdentifier(!0), this.expect(14), !this.match(134)) throw this.raise(b.ModuleAttributeInvalidValue, this.state.startLoc);
        u.value = this.parseStringLiteral(this.state.value), r.push(this.finishNode(u, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), r;
    }
    parseModuleAttributes() {
      const r = [], a = /* @__PURE__ */ new Set();
      do {
        const u = this.startNode();
        if (u.key = this.parseIdentifier(!0), u.key.name !== "type" && this.raise(b.ModuleAttributeDifferentFromType, u.key), a.has(u.key.name) && this.raise(b.ModuleAttributesWithDuplicateKeys, u.key, { key: u.key.name }), a.add(u.key.name), this.expect(14), !this.match(134)) throw this.raise(b.ModuleAttributeInvalidValue, this.state.startLoc);
        u.value = this.parseStringLiteral(this.state.value), r.push(this.finishNode(u, "ImportAttribute"));
      } while (this.eat(12));
      return r;
    }
    maybeParseImportAttributes(r) {
      let a;
      var u = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
        this.next(), this.hasPlugin("moduleAttributes") ? (a = this.parseModuleAttributes(), this.addExtra(r, "deprecatedWithLegacySyntax", !0)) : a = this.parseImportAttributes(), u = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin("deprecatedImportAssert") || this.hasPlugin("importAssertions") || this.raise(b.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(r, "deprecatedAssertSyntax", !0), this.next(), a = this.parseImportAttributes()) : a = [];
      !u && this.hasPlugin("importAssertions") ? r.assertions = a : r.attributes = a;
    }
    maybeParseDefaultImportSpecifier(r, a) {
      if (a) {
        const u = this.startNodeAtNode(a);
        return u.local = a, r.specifiers.push(this.finishImportSpecifier(u, "ImportDefaultSpecifier")), !0;
      }
      return !!z(this.state.type) && (this.parseImportSpecifierLocal(r, this.startNode(), "ImportDefaultSpecifier"), !0);
    }
    maybeParseStarImportSpecifier(r) {
      if (this.match(55)) {
        const a = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(r, a, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(r) {
      let a = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (a) a = !1;
        else {
          if (this.eat(14)) throw this.raise(b.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const u = this.startNode(), T = this.match(134), S = this.isContextual(130);
        u.imported = this.parseModuleExportName();
        const _ = this.parseImportSpecifier(u, T, r.importKind === "type" || r.importKind === "typeof", S, void 0);
        r.specifiers.push(_);
      }
    }
    parseImportSpecifier(r, a, u, T, S) {
      if (this.eatContextual(93)) r.local = this.parseIdentifier();
      else {
        const { imported: _ } = r;
        if (a) throw this.raise(b.ImportBindingIsString, r, { importName: _.value });
        this.checkReservedWord(_.name, r.loc.start, !0, !0), r.local || (r.local = this.cloneIdentifier(_));
      }
      return this.finishImportSpecifier(r, "ImportSpecifier", S);
    }
    isThisParam(r) {
      return r.type === "Identifier" && r.name === "this";
    }
  }
  class s1 extends kT {
    constructor(r, a, u) {
      super(r = (function(S) {
        const _ = { sourceType: "script", sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, allowYieldOutsideFunction: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
        if (S == null) return _;
        if (S.annexB != null && S.annexB !== !1) throw new Error("The `annexB` option can only be set to `false`.");
        for (const I of Object.keys(_)) S[I] != null && (_[I] = S[I]);
        if (_.startLine === 1) S.startIndex == null && _.startColumn > 0 ? _.startIndex = _.startColumn : S.startColumn == null && _.startIndex > 0 && (_.startColumn = _.startIndex);
        else if ((S.startColumn == null || S.startIndex == null) && S.startIndex != null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        if (_.sourceType === "commonjs") {
          if (S.allowAwaitOutsideFunction != null) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
          if (S.allowReturnOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
          if (S.allowNewTargetOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
        }
        return _;
      })(r), a), this.options = r, this.initializeScopes(), this.plugins = u, this.filename = r.sourceFilename, this.startIndex = r.startIndex;
      let T = 0;
      r.allowAwaitOutsideFunction && (T |= 1), r.allowReturnOutsideFunction && (T |= 2), r.allowImportExportEverywhere && (T |= 8), r.allowSuperOutsideMethod && (T |= 16), r.allowUndeclaredExports && (T |= 64), r.allowNewTargetOutsideFunction && (T |= 4), r.allowYieldOutsideFunction && (T |= 32), r.ranges && (T |= 128), r.tokens && (T |= 256), r.createImportExpressions && (T |= 512), r.createParenthesizedExpressions && (T |= 1024), r.errorRecovery && (T |= 2048), r.attachComment && (T |= 4096), r.annexB && (T |= 8192), this.optionFlags = T;
    }
    getScopeHandler() {
      return Qa;
    }
    parse() {
      this.enterInitialScopes();
      const r = this.startNode(), a = this.startNode();
      return this.nextToken(), r.errors = null, this.parseTopLevel(r, a), r.errors = this.state.errors, r.comments.length = this.state.commentsLen, r;
    }
  }
  const ST = (function(P) {
    const r = {};
    for (const a of Object.keys(P)) r[a] = Me(P[a]);
    return r;
  })(Y);
  function Sn(P, r) {
    let a = s1;
    const u = /* @__PURE__ */ new Map();
    if (P != null && P.plugins) {
      for (const T of P.plugins) {
        let S, _;
        typeof T == "string" ? S = T : [S, _] = T, u.has(S) || u.set(S, _ || {});
      }
      (function(T) {
        if (T.has("decorators")) {
          if (T.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          const I = T.get("decorators").decoratorsBeforeExport;
          if (I != null && typeof I != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          const R = T.get("decorators").allowCallParenthesized;
          if (R != null && typeof R != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
        }
        if (T.has("flow") && T.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
        if (T.has("placeholders") && T.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        if (T.has("pipelineOperator")) {
          var S;
          const I = T.get("pipelineOperator").proposal;
          if (!e1.includes(I)) {
            const R = e1.map((M) => `"${M}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${R}.`);
          }
          if (I === "hack") {
            if (T.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            if (T.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            const R = T.get("pipelineOperator").topicToken;
            if (!t1.includes(R)) {
              const M = t1.map((K) => `"${K}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${M}.`);
            }
            var _;
            if (R === "#" && ((_ = T.get("recordAndTuple")) == null ? void 0 : _.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", T.get("recordAndTuple")])}\`.`);
          } else if (I === "smart" && ((S = T.get("recordAndTuple")) == null ? void 0 : S.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", T.get("recordAndTuple")])}\`.`);
        }
        if (T.has("moduleAttributes")) {
          if (T.has("deprecatedImportAssert") || T.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
          if (T.get("moduleAttributes").version !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
        if (T.has("importAssertions") && T.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        if (!T.has("deprecatedImportAssert") && T.has("importAttributes") && T.get("importAttributes").deprecatedAssertSyntax && T.set("deprecatedImportAssert", {}), T.has("recordAndTuple")) {
          const I = T.get("recordAndTuple").syntaxType;
          if (I != null) {
            const R = ["hash", "bar"];
            if (!R.includes(I)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + R.map((M) => `'${M}'`).join(", "));
          }
        }
        if (T.has("asyncDoExpressions") && !T.has("doExpressions")) {
          const I = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw I.missingPlugins = "doExpressions", I;
        }
        if (T.has("optionalChainingAssign") && T.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        if (T.has("discardBinding") && T.get("discardBinding").syntaxType !== "void") throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
      })(u), a = (function(T) {
        const S = [];
        for (const R of xT) T.has(R) && S.push(R);
        const _ = S.join("|");
        let I = n1.get(_);
        if (!I) {
          I = s1;
          for (const R of S) I = r1[R](I);
          n1.set(_, I);
        }
        return I;
      })(u);
    }
    return new a(P, r, u);
  }
  const n1 = /* @__PURE__ */ new Map();
  return js.parse = function(P, r) {
    var a;
    if (((a = r) == null ? void 0 : a.sourceType) !== "unambiguous") return Sn(r, P).parse();
    r = Object.assign({}, r);
    try {
      r.sourceType = "module";
      const u = Sn(r, P), T = u.parse();
      if (u.sawUnambiguousESM) return T;
      if (u.ambiguousScriptDifferentAst) try {
        return r.sourceType = "script", Sn(r, P).parse();
      } catch {
      }
      else T.program.sourceType = "script";
      return T;
    } catch (u) {
      try {
        return r.sourceType = "script", Sn(r, P).parse();
      } catch {
      }
      throw u;
    }
  }, js.parseExpression = function(P, r) {
    const a = Sn(r, P);
    return a.options.strictMode && (a.state.strict = !0), a.getExpression();
  }, js.tokTypes = ST, js;
}
var ar = av();
class cv {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: (t) => this.replacement = t };
  }
  replace(t, s, n, i) {
    t && (n !== null ? t[s][n] = i : t[s] = i);
  }
  remove(t, s, n) {
    t && (n !== null ? t[s].splice(n, 1) : delete t[s]);
  }
}
class lv extends cv {
  constructor(t, s) {
    super(), this.enter = t, this.leave = s;
  }
  visit(t, s, n, i) {
    if (t) {
      if (this.enter) {
        const o = this.should_skip, c = this.should_remove, l = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, s, n, i), this.replacement && (t = this.replacement, this.replace(s, n, i, t)), this.should_remove && this.remove(s, n, i);
        const p = this.should_skip, d = this.should_remove;
        if (this.should_skip = o, this.should_remove = c, this.replacement = l, p) return t;
        if (d) return null;
      }
      for (const o in t) {
        const c = t[o];
        if (typeof c == "object") if (Array.isArray(c)) for (let l = 0; l < c.length; l += 1) c[l] !== null && typeof c[l].type == "string" && (this.visit(c[l], t, o, l) || l--);
        else c !== null && typeof c.type == "string" && this.visit(c, t, o, null);
      }
      if (this.leave) {
        const o = this.replacement, c = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, s, n, i), this.replacement && (t = this.replacement, this.replace(s, n, i, t)), this.should_remove && this.remove(s, n, i);
        const l = this.should_remove;
        if (this.replacement = o, this.should_remove = c, l) return null;
      }
    }
    return t;
  }
}
function Yp(e, { enter: t, leave: s }) {
  return new lv(t, s).visit(e, null);
}
function Ta(e, t, s = !1, n = [], i = /* @__PURE__ */ Object.create(null)) {
  const o = e.type === "Program" ? e.body[0].type === "ExpressionStatement" && e.body[0].expression : e;
  Yp(e, { enter(c, l) {
    if (l && n.push(l), l && l.type.startsWith("TS") && !ka.includes(l.type)) return this.skip();
    if (c.type === "Identifier") {
      const p = !!i[c.name], d = Qp(c, l, n);
      (s || d && !p) && t(c, l, n, d, p);
    } else if (c.type === "ObjectProperty" && l?.type === "ObjectPattern") c.inPattern = !0;
    else if (Wr(c)) c.scopeIds ? c.scopeIds.forEach((p) => Vs(p, i)) : Zp(c, (p) => wn(c, p, i));
    else if (c.type === "BlockStatement") c.scopeIds ? c.scopeIds.forEach((p) => Vs(p, i)) : eh(c, (p) => wn(c, p, i));
    else if (c.type === "SwitchStatement") c.scopeIds ? c.scopeIds.forEach((p) => Vs(p, i)) : ay(c, !1, (p) => wn(c, p, i));
    else if (c.type === "CatchClause" && c.param) if (c.scopeIds) c.scopeIds.forEach((p) => Vs(p, i));
    else for (const p of Yt(c.param)) wn(c, p, i);
    else iy(c) && (c.scopeIds ? c.scopeIds.forEach((p) => Vs(p, i)) : oy(c, !1, (p) => wn(c, p, i)));
  }, leave(c, l) {
    if (l && n.pop(), c !== o && c.scopeIds) for (const p of c.scopeIds) i[p]--, i[p] === 0 && delete i[p];
  } });
}
function Qp(e, t, s) {
  if (!t) return !0;
  if (e.name === "arguments") return !1;
  if ((function(n, i, o) {
    switch (i.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return i.property === n ? !!i.computed : i.object === n;
      case "JSXMemberExpression":
        return i.object === n;
      case "VariableDeclarator":
        return i.init === n;
      case "ArrowFunctionExpression":
        return i.body === n;
      case "PrivateName":
      case "LabeledStatement":
      case "CatchClause":
      case "RestElement":
      case "BreakStatement":
      case "ContinueStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportAttribute":
      case "JSXAttribute":
      case "ObjectPattern":
      case "ArrayPattern":
      case "MetaProperty":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return i.key === n && !!i.computed;
      case "ObjectProperty":
        return i.key === n ? !!i.computed : !o || o.type !== "ObjectPattern";
      case "ClassProperty":
      case "TSPropertySignature":
        return i.key !== n || !!i.computed;
      case "ClassPrivateProperty":
      case "ObjectTypeProperty":
        return i.key !== n;
      case "ClassDeclaration":
      case "ClassExpression":
        return i.superClass === n;
      case "AssignmentExpression":
      case "AssignmentPattern":
        return i.right === n;
      case "ExportSpecifier":
        return !o?.source && i.local === n;
      case "TSEnumMember":
        return i.id !== n;
    }
    return !0;
  })(e, t, s[s.length - 2])) return !0;
  switch (t.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return !0;
    case "ObjectProperty":
      return t.key !== e && ri(t, s);
    case "ArrayPattern":
      return ri(t, s);
  }
  return !1;
}
function ri(e, t) {
  if (e && (e.type === "ObjectProperty" || e.type === "ArrayPattern")) {
    let s = t.length;
    for (; s--; ) {
      const n = t[s];
      if (n.type === "AssignmentExpression") return !0;
      if (n.type !== "ObjectProperty" && !n.type.endsWith("Pattern")) break;
    }
  }
  return !1;
}
function ny(e) {
  let t = e.length;
  for (; t--; ) {
    const s = e[t];
    if (s.type === "NewExpression") return !0;
    if (s.type !== "MemberExpression") break;
  }
  return !1;
}
function Zp(e, t) {
  for (const s of e.params) for (const n of Yt(s)) t(n);
}
function eh(e, t) {
  const s = e.type === "SwitchCase" ? e.consequent : e.body;
  for (const n of s) if (n.type === "VariableDeclaration") {
    if (n.declare) continue;
    for (const i of n.declarations) for (const o of Yt(i.id)) t(o);
  } else if (n.type === "FunctionDeclaration" || n.type === "ClassDeclaration") {
    if (n.declare || !n.id) continue;
    t(n.id);
  } else iy(n) ? oy(n, !0, t) : n.type === "SwitchStatement" && ay(n, !0, t);
}
function iy(e) {
  return e.type === "ForOfStatement" || e.type === "ForInStatement" || e.type === "ForStatement";
}
function oy(e, t, s) {
  const n = e.type === "ForStatement" ? e.init : e.left;
  if (n && n.type === "VariableDeclaration" && (n.kind === "var" ? t : !t)) for (const i of n.declarations) for (const o of Yt(i.id)) s(o);
}
function ay(e, t, s) {
  for (const n of e.cases) {
    for (const i of n.consequent) if (i.type === "VariableDeclaration" && (i.kind === "var" ? t : !t)) for (const o of i.declarations) for (const c of Yt(o.id)) s(c);
    eh(n, s);
  }
}
function Yt(e, t = []) {
  switch (e.type) {
    case "Identifier":
      t.push(e);
      break;
    case "MemberExpression":
      let s = e;
      for (; s.type === "MemberExpression"; ) s = s.object;
      t.push(s);
      break;
    case "ObjectPattern":
      for (const n of e.properties) n.type === "RestElement" ? Yt(n.argument, t) : Yt(n.value, t);
      break;
    case "ArrayPattern":
      e.elements.forEach((n) => {
        n && Yt(n, t);
      });
      break;
    case "RestElement":
      Yt(e.argument, t);
      break;
    case "AssignmentPattern":
      Yt(e.left, t);
  }
  return t;
}
function Vs(e, t) {
  e in t ? t[e]++ : t[e] = 1;
}
function wn(e, t, s) {
  const { name: n } = t;
  e.scopeIds && e.scopeIds.has(n) || (Vs(n, s), (e.scopeIds || (e.scopeIds = /* @__PURE__ */ new Set())).add(n));
}
const Wr = (e) => /Function(?:Expression|Declaration)$|Method$/.test(e.type), va = (e) => e && (e.type === "ObjectProperty" || e.type === "ObjectMethod") && !e.computed, cy = (e, t) => va(t) && t.key === e, ka = ["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"];
function Gt(e) {
  return ka.includes(e.type) ? Gt(e.expression) : e;
}
const vt = (e) => e.type === 4 && e.isStatic;
function th(e) {
  switch (e) {
    case "Teleport":
    case "teleport":
      return Ts;
    case "Suspense":
    case "suspense":
      return dn;
    case "KeepAlive":
    case "keep-alive":
      return Qn;
    case "BaseTransition":
    case "base-transition":
      return $p;
  }
}
const pv = /^$|^\d|[^\$\w\xA0-\uFFFF]/, Lr = (e) => !pv.test(e), Wl = /[A-Za-z_$\xA0-\uFFFF]/, hv = /[\.\?\w$\xA0-\uFFFF]/, uv = /\s+[.[]\s*|\s*[.[]\s+/g, Io = (e) => e.type === 4 ? e.content : e.loc.source, ly = (e, t) => {
  try {
    let s = e.ast || ar.parseExpression(Io(e), { plugins: t.expressionPlugins ? [...t.expressionPlugins, "typescript"] : ["typescript"] });
    return s = Gt(s), s.type === "MemberExpression" || s.type === "OptionalMemberExpression" || s.type === "Identifier" && s.name !== "undefined";
  } catch {
    return !1;
  }
}, rh = ly, dv = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/, py = (e, t) => {
  try {
    let s = e.ast || ar.parseExpression(Io(e), { plugins: t.expressionPlugins ? [...t.expressionPlugins, "typescript"] : ["typescript"] });
    return s.type === "Program" && (s = s.body[0], s.type === "ExpressionStatement" && (s = s.expression)), s = Gt(s), s.type === "FunctionExpression" || s.type === "ArrowFunctionExpression";
  } catch {
    return !1;
  }
}, hy = py;
function Gl(e, t, s = t.length) {
  return sh({ offset: e.offset, line: e.line, column: e.column }, t, s);
}
function sh(e, t, s = t.length) {
  let n = 0, i = -1;
  for (let o = 0; o < s; o++) t.charCodeAt(o) === 10 && (n++, i = o);
  return e.offset += s, e.line += n, e.column = i === -1 ? e.column + s : s - i, e;
}
function Xl(e, t) {
  if (!e) throw new Error(t || "unexpected compiler condition");
}
function rt(e, t, s = !1) {
  for (let n = 0; n < e.props.length; n++) {
    const i = e.props[n];
    if (i.type === 7 && (s || i.exp) && (De(t) ? i.name === t : t.test(i.name))) return i;
  }
}
function Ut(e, t, s = !1, n = !1) {
  for (let i = 0; i < e.props.length; i++) {
    const o = e.props[i];
    if (o.type === 6) {
      if (s) continue;
      if (o.name === t && (o.value || n)) return o;
    } else if (o.name === "bind" && (o.exp || n) && xr(o.arg, t)) return o;
  }
}
function xr(e, t) {
  return !(!e || !vt(e) || e.content !== t);
}
function Sa(e) {
  return e.props.some((t) => !(t.type !== 7 || t.name !== "bind" || t.arg && t.arg.type === 4 && t.arg.isStatic));
}
function Bn(e) {
  return e.type === 5 || e.type === 2;
}
function Kl(e) {
  return e.type === 7 && e.name === "pre";
}
function Ea(e) {
  return e.type === 7 && e.name === "slot";
}
function an(e) {
  return e.type === 1 && e.tagType === 3;
}
function cn(e) {
  return e.type === 1 && e.tagType === 2;
}
const fv = /* @__PURE__ */ new Set([sn, mn]);
function uy(e, t = []) {
  if (e && !De(e) && e.type === 14) {
    const s = e.callee;
    if (!De(s) && fv.has(s)) return uy(e.arguments[0], t.concat(e));
  }
  return [e, t];
}
function si(e, t, s) {
  let n, i, o = e.type === 13 ? e.props : e.arguments[2], c = [];
  if (o && !De(o) && o.type === 14) {
    const l = uy(o);
    o = l[0], c = l[1], i = c[c.length - 1];
  }
  if (o == null || De(o)) n = Ft([t]);
  else if (o.type === 14) {
    const l = o.arguments[0];
    De(l) || l.type !== 15 ? o.callee === fa ? n = we(s.helper(Es), [Ft([t]), o]) : o.arguments.unshift(Ft([t])) : d1(t, l) || l.properties.unshift(t), !n && (n = o);
  } else o.type === 15 ? (d1(t, o) || o.properties.unshift(t), n = o) : (n = we(s.helper(Es), [Ft([t]), o]), i && i.callee === mn && (i = c[c.length - 2]));
  e.type === 13 ? i ? i.arguments[0] = n : e.props = n : i ? i.arguments[0] = n : e.arguments[2] = n;
}
function d1(e, t) {
  let s = !1;
  if (e.key.type === 4) {
    const n = e.key.content;
    s = t.properties.some((i) => i.key.type === 4 && i.key.content === n);
  }
  return s;
}
function ni(e, t) {
  return `_${t}_${e.replace(/[^\w]/g, (s, n) => s === "-" ? "_" : e.charCodeAt(n).toString())}`;
}
function _t(e, t) {
  if (!e || Object.keys(t).length === 0) return !1;
  switch (e.type) {
    case 1:
      for (let s = 0; s < e.props.length; s++) {
        const n = e.props[s];
        if (n.type === 7 && (_t(n.arg, t) || _t(n.exp, t))) return !0;
      }
      return e.children.some((s) => _t(s, t));
    case 11:
      return !!_t(e.source, t) || e.children.some((s) => _t(s, t));
    case 9:
      return e.branches.some((s) => _t(s, t));
    case 10:
      return !!_t(e.condition, t) || e.children.some((s) => _t(s, t));
    case 4:
      return !e.isStatic && Lr(e.content) && !!t[e.content];
    case 8:
      return e.children.some((s) => ss(s) && _t(s, t));
    case 5:
    case 12:
      return _t(e.content, t);
    default:
      return !1;
  }
}
function dy(e) {
  return e.type === 14 && e.callee === ga ? e.arguments[1].returns : e;
}
const fy = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/, my = { parseMode: "base", ns: 0, delimiters: ["{{", "}}"], getNamespace: () => 0, isVoidTag: Dn, isPreTag: Dn, isIgnoreNewlineTag: Dn, isCustomElement: Dn, onError: Kp, onWarn: sy, comments: !0, prefixIdentifiers: !1 };
let Xe = my, No = null, Or = "", Pt = null, Fe = null, Xt = "", _r = -1, ps = -1, nh = 0, Hr = !1, Jl = null;
const it = [], Ye = new class {
  constructor(e, t) {
    this.stack = e, this.cbs = t, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = c1, this.delimiterClose = l1, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new ty(ey, (s, n) => this.emitCodePoint(s, n));
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = c1, this.delimiterClose = l1;
  }
  getPos(e) {
    let t = 1, s = e + 1;
    for (let n = this.newlines.length - 1; n >= 0; n--) {
      const i = this.newlines[n];
      if (e > i) {
        t = n + 2, s = e - i;
        break;
      }
    }
    return { column: s, line: t, offset: e };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(e) {
    e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : e === 38 ? this.startEntity() : this.inVPre || e !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e));
  }
  stateInterpolationOpen(e) {
    if (e === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) {
      const t = this.index + 1 - this.delimiterOpen.length;
      t > this.sectionStart && this.cbs.ontext(this.sectionStart, t), this.state = 3, this.sectionStart = t;
    } else this.delimiterIndex++;
    else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e));
  }
  stateInterpolation(e) {
    e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e));
  }
  stateInterpolationClose(e) {
    e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e));
  }
  stateSpecialStartSequence(e) {
    const t = this.sequenceIndex === this.currentSequence.length;
    if (t ? Ur(e) : (32 | e) === this.currentSequence[this.sequenceIndex]) {
      if (!t) return void this.sequenceIndex++;
    } else this.inRCDATA = !1;
    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e);
  }
  stateInRCDATA(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === 62 || qt(e)) {
        const t = this.index - this.currentSequence.length;
        if (this.sectionStart < t) {
          const s = this.index;
          this.index = t, this.cbs.ontext(this.sectionStart, t), this.index = s;
        }
        return this.sectionStart = t + 2, this.stateInClosingTagName(e), void (this.inRCDATA = !1);
      }
      this.sequenceIndex = 0;
    }
    (32 | e) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === bt.TitleEnd || this.currentSequence === bt.TextareaEnd && !this.inSFCRoot ? e === 38 ? this.startEntity() : this.inVPre || e !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === 60);
  }
  stateCDATASequence(e) {
    e === bt.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === bt.Cdata.length && (this.state = 28, this.currentSequence = bt.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e));
  }
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      if (t === 10 && this.newlines.push(this.index), t === e) return !0;
    }
    return this.index = this.buffer.length - 1, !1;
  }
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === bt.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  startSpecial(e, t) {
    this.enterRCDATA(e, t), this.state = 31;
  }
  enterRCDATA(e, t) {
    this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = t;
  }
  stateBeforeTagName(e) {
    e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : p1(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : this.state = e === 116 ? 30 : e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e));
  }
  stateInTagName(e) {
    Ur(e) && this.handleTagName(e);
  }
  stateInSFCRootTagName(e) {
    if (Ur(e)) {
      const t = this.buffer.slice(this.sectionStart, this.index);
      t !== "template" && this.enterRCDATA(Co("</" + t), 0), this.handleTagName(e);
    }
  }
  handleTagName(e) {
    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e);
  }
  stateBeforeClosingTagName(e) {
    qt(e) || (e === 62 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = p1(e) ? 9 : 27, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === 62 || qt(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    e === 62 && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeAttrName(e) {
    e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? (this.state = 7, this.peek() !== 62 && this.cbs.onerr(22, this.index)) : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : qt(e) || (e === 61 && this.cbs.onerr(19, this.index), this.handleAttrStart(e));
  }
  handleAttrStart(e) {
    e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : qt(e) || (this.state = 11, this.stateBeforeAttrName(e));
  }
  stateInAttrName(e) {
    e === 61 || Ur(e) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e !== 34 && e !== 39 && e !== 60 || this.cbs.onerr(17, this.index);
  }
  stateInDirName(e) {
    e === 61 || Ur(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDirArg(e) {
    e === 61 || Ur(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDynamicDirArg(e) {
    e === 93 ? this.state = 14 : (e === 61 || Ur(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e), this.cbs.onerr(27, this.index));
  }
  stateInDirModifier(e) {
    e === 61 || Ur(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
  }
  handleAttrNameEnd(e) {
    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e);
  }
  stateAfterAttrName(e) {
    e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : qt(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));
  }
  stateBeforeAttrValue(e) {
    e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : qt(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e));
  }
  handleInAttrValue(e, t) {
    e === t ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(t === 34 ? 3 : 2, this.index + 1), this.state = 11) : e === 38 && this.startEntity();
  }
  stateInAttrValueDoubleQuotes(e) {
    this.handleInAttrValue(e, 34);
  }
  stateInAttrValueSingleQuotes(e) {
    this.handleInAttrValue(e, 39);
  }
  stateInAttrValueNoQuotes(e) {
    qt(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : e === 34 || e === 39 || e === 60 || e === 61 || e === 96 ? this.cbs.onerr(18, this.index) : e === 38 && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23;
  }
  stateInDeclaration(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === 45 ? (this.state = 28, this.currentSequence = bt.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
  }
  stateInSpecialComment(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    e === bt.ScriptEnd[3] ? this.startSpecial(bt.ScriptEnd, 4) : e === bt.StyleEnd[3] ? this.startSpecial(bt.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    e === bt.TitleEnd[3] ? this.startSpecial(bt.TitleEnd, 4) : e === bt.TextareaEnd[3] ? this.startSpecial(bt.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(this.baseState === 1 || this.baseState === 32 ? mr.Legacy : mr.Attribute);
  }
  stateInEntity() {
    {
      const e = this.entityDecoder.write(this.buffer, this.index);
      e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
    }
  }
  parse(e) {
    for (this.buffer = e; this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      switch (t === 10 && this.state !== 33 && this.newlines.push(this.index), this.state) {
        case 1:
          this.stateText(t);
          break;
        case 2:
          this.stateInterpolationOpen(t);
          break;
        case 3:
          this.stateInterpolation(t);
          break;
        case 4:
          this.stateInterpolationClose(t);
          break;
        case 31:
          this.stateSpecialStartSequence(t);
          break;
        case 32:
          this.stateInRCDATA(t);
          break;
        case 26:
          this.stateCDATASequence(t);
          break;
        case 19:
          this.stateInAttrValueDoubleQuotes(t);
          break;
        case 12:
          this.stateInAttrName(t);
          break;
        case 13:
          this.stateInDirName(t);
          break;
        case 14:
          this.stateInDirArg(t);
          break;
        case 15:
          this.stateInDynamicDirArg(t);
          break;
        case 16:
          this.stateInDirModifier(t);
          break;
        case 28:
          this.stateInCommentLike(t);
          break;
        case 27:
          this.stateInSpecialComment(t);
          break;
        case 11:
          this.stateBeforeAttrName(t);
          break;
        case 6:
          this.stateInTagName(t);
          break;
        case 34:
          this.stateInSFCRootTagName(t);
          break;
        case 9:
          this.stateInClosingTagName(t);
          break;
        case 5:
          this.stateBeforeTagName(t);
          break;
        case 17:
          this.stateAfterAttrName(t);
          break;
        case 20:
          this.stateInAttrValueSingleQuotes(t);
          break;
        case 18:
          this.stateBeforeAttrValue(t);
          break;
        case 8:
          this.stateBeforeClosingTagName(t);
          break;
        case 10:
          this.stateAfterClosingTagName(t);
          break;
        case 29:
          this.stateBeforeSpecialS(t);
          break;
        case 30:
          this.stateBeforeSpecialT(t);
          break;
        case 21:
          this.stateInAttrValueNoQuotes(t);
          break;
        case 7:
          this.stateInSelfClosingTag(t);
          break;
        case 23:
          this.stateInDeclaration(t);
          break;
        case 22:
          this.stateBeforeDeclaration(t);
          break;
        case 25:
          this.stateBeforeComment(t);
          break;
        case 24:
          this.stateInProcessingInstruction(t);
          break;
        case 33:
          this.stateInEntity();
      }
      this.index++;
    }
    this.cleanup(), this.finish();
  }
  cleanup() {
    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : this.state !== 19 && this.state !== 20 && this.state !== 21 || (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  finish() {
    this.state === 33 && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  handleTrailingData() {
    const e = this.buffer.length;
    this.sectionStart >= e || (this.state === 28 ? this.currentSequence === bt.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, t) {
    this.baseState !== 1 && this.baseState !== 32 ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.onattribentity(Vl(e), this.entityStart, this.sectionStart)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.ontextentity(Vl(e), this.entityStart, this.sectionStart));
  }
}(it, { onerr: It, ontext(e, t) {
  Ri(Et(e, t), e, t);
}, ontextentity(e, t, s) {
  Ri(e, t, s);
}, oninterpolation(e, t) {
  if (Hr) return Ri(Et(e, t), e, t);
  let s = e + Ye.delimiterOpen.length, n = t - Ye.delimiterClose.length;
  for (; qt(Or.charCodeAt(s)); ) s++;
  for (; qt(Or.charCodeAt(n - 1)); ) n--;
  let i = Et(s, n);
  i.includes("&") && (i = (function(o, c = mr.Legacy) {
    return iv(o, c);
  })(i)), Yl({ type: 5, content: Mi(i, !1, ot(s, n)), loc: ot(e, t) });
}, onopentagname(e, t) {
  const s = Et(e, t);
  Pt = { type: 1, tag: s, ns: Xe.getNamespace(s, it[0], Xe.ns), tagType: 0, props: [], children: [], loc: ot(e - 1, t), codegenNode: void 0 };
}, onopentagend(e) {
  m1(e);
}, onclosetag(e, t) {
  const s = Et(e, t);
  if (!Xe.isVoidTag(s)) {
    let n = !1;
    for (let i = 0; i < it.length; i++)
      if (it[i].tag.toLowerCase() === s.toLowerCase()) {
        n = !0, i > 0 && It(24, it[0].loc.start.offset);
        for (let o = 0; o <= i; o++)
          ao(it.shift(), t, o < i);
        break;
      }
    n || It(23, gy(e, 60));
  }
}, onselfclosingtag(e) {
  const t = Pt.tag;
  Pt.isSelfClosing = !0, m1(e), it[0] && it[0].tag === t && ao(it.shift(), e);
}, onattribname(e, t) {
  Fe = { type: 6, name: Et(e, t), nameLoc: ot(e, t), value: void 0, loc: ot(e) };
}, ondirname(e, t) {
  const s = Et(e, t), n = s === "." || s === ":" ? "bind" : s === "@" ? "on" : s === "#" ? "slot" : s.slice(2);
  if (Hr || n !== "" || It(26, e), Hr || n === "") Fe = { type: 6, name: s, nameLoc: ot(e, t), value: void 0, loc: ot(e) };
  else if (Fe = { type: 7, name: n, rawName: s, exp: void 0, arg: void 0, modifiers: s === "." ? [ue("prop")] : [], loc: ot(e) }, n === "pre") {
    Hr = Ye.inVPre = !0, Jl = Pt;
    const i = Pt.props;
    for (let o = 0; o < i.length; o++) i[o].type === 7 && (i[o] = Tv(i[o]));
  }
}, ondirarg(e, t) {
  if (e === t) return;
  const s = Et(e, t);
  if (Hr && !Kl(Fe)) Fe.name += s, Gs(Fe.nameLoc, t);
  else {
    const n = s[0] !== "[";
    Fe.arg = Mi(n ? s : s.slice(1, -1), n, ot(e, t), n ? 3 : 0);
  }
}, ondirmodifier(e, t) {
  const s = Et(e, t);
  if (Hr && !Kl(Fe)) Fe.name += "." + s, Gs(Fe.nameLoc, t);
  else if (Fe.name === "slot") {
    const n = Fe.arg;
    n && (n.content += "." + s, Gs(n.loc, t));
  } else {
    const n = ue(s, !0, ot(e, t));
    Fe.modifiers.push(n);
  }
}, onattribdata(e, t) {
  Xt += Et(e, t), _r < 0 && (_r = e), ps = t;
}, onattribentity(e, t, s) {
  Xt += e, _r < 0 && (_r = t), ps = s;
}, onattribnameend(e) {
  const t = Fe.loc.start.offset, s = Et(t, e);
  Fe.type === 7 && (Fe.rawName = s), Pt.props.some((n) => (n.type === 7 ? n.rawName : n.name) === s) && It(2, t);
}, onattribend(e, t) {
  if (Pt && Fe) {
    if (Gs(Fe.loc, t), e !== 0) if (Fe.type === 6) Fe.name === "class" && (Xt = xy(Xt).trim()), e !== 1 || Xt || It(13, t), Fe.value = { type: 2, content: Xt, loc: e === 1 ? ot(_r, ps) : ot(_r - 1, ps + 1) }, Ye.inSFCRoot && Pt.tag === "template" && Fe.name === "lang" && Xt && Xt !== "html" && Ye.enterRCDATA(Co("</template"), 0);
    else {
      let s = 0;
      Fe.name === "for" ? s = 3 : Fe.name === "slot" ? s = 1 : Fe.name === "on" && Xt.includes(";") && (s = 2), Fe.exp = Mi(Xt, !1, ot(_r, ps), 0, s), Fe.name === "for" && (Fe.forParseResult = (function(n) {
        const i = n.loc, o = n.content, c = o.match(fy);
        if (!c) return;
        const [, l, p] = c, d = (y, v, b = !1) => {
          const E = i.start.offset + v;
          return Mi(y, !1, ot(E, E + y.length), 0, b ? 1 : 0);
        }, g = { source: d(p.trim(), o.indexOf(p, l.length)), value: void 0, key: void 0, index: void 0, finalized: !1 };
        let f = l.trim().replace(mv, "").trim();
        const x = l.indexOf(f), m = f.match(f1);
        if (m) {
          f = f.replace(f1, "").trim();
          const y = m[1].trim();
          let v;
          if (y && (v = o.indexOf(y, x + f.length), g.key = d(y, v, !0)), m[2]) {
            const b = m[2].trim();
            b && (g.index = d(b, o.indexOf(b, g.key ? v + y.length : x + f.length), !0));
          }
        }
        return f && (g.value = d(f, x, !0)), g;
      })(Fe.exp));
    }
    Fe.type === 7 && Fe.name === "pre" || Pt.props.push(Fe);
  }
  Xt = "", _r = ps = -1;
}, oncomment(e, t) {
  Xe.comments && Yl({ type: 3, content: Et(e, t), loc: ot(e - 4, t + 3) });
}, onend() {
  const e = Or.length;
  if (Ye.state !== 1) switch (Ye.state) {
    case 5:
    case 8:
      It(5, e);
      break;
    case 3:
    case 4:
      It(25, Ye.sectionStart);
      break;
    case 28:
      Ye.currentSequence === bt.CdataEnd ? It(6, e) : It(7, e);
      break;
    case 6:
    case 7:
    case 9:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      It(9, e);
  }
  for (let t = 0; t < it.length; t++) ao(it[t], e - 1), It(24, it[t].loc.start.offset);
}, oncdata(e, t) {
  it[0].ns !== 0 ? Ri(Et(e, t), e, t) : It(1, e - 9);
}, onprocessinginstruction(e) {
  (it[0] ? it[0].ns : Xe.ns) === 0 && It(21, e - 1);
} }), f1 = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, mv = /^\(|\)$/g;
function Et(e, t) {
  return Or.slice(e, t);
}
function m1(e) {
  Ye.inSFCRoot && (Pt.innerLoc = ot(e + 1, e + 1)), Yl(Pt);
  const { tag: t, ns: s } = Pt;
  s === 0 && Xe.isPreTag(t) && nh++, Xe.isVoidTag(t) ? ao(Pt, e) : (it.unshift(Pt), s !== 1 && s !== 2 || (Ye.inXML = !0)), Pt = null;
}
function Ri(e, t, s) {
  const n = it[0] || No, i = n.children[n.children.length - 1];
  i && i.type === 2 ? (i.content += e, Gs(i.loc, s)) : n.children.push({ type: 2, content: e, loc: ot(t, s) });
}
function ao(e, t, s = !1) {
  Gs(e.loc, s ? gy(t, 60) : (function(c, l) {
    let p = c;
    for (; Or.charCodeAt(p) !== l && p < Or.length - 1; ) p++;
    return p;
  })(t, 62) + 1), Ye.inSFCRoot && (e.children.length ? e.innerLoc.end = kr({}, e.children[e.children.length - 1].loc.end) : e.innerLoc.end = kr({}, e.innerLoc.start), e.innerLoc.source = Et(e.innerLoc.start.offset, e.innerLoc.end.offset));
  const { tag: n, ns: i, children: o } = e;
  if (Hr || (n === "slot" ? e.tagType = 2 : (function({ tag: c, props: l }) {
    if (c === "template") {
      for (let p = 0; p < l.length; p++) if (l[p].type === 7 && gv.has(l[p].name)) return !0;
    }
    return !1;
  })(e) ? e.tagType = 3 : (function({ tag: c, props: l }) {
    if (Xe.isCustomElement(c)) return !1;
    if (c === "component" || (p = c.charCodeAt(0), p > 64 && p < 91) || th(c) || Xe.isBuiltInComponent && Xe.isBuiltInComponent(c) || Xe.isNativeTag && !Xe.isNativeTag(c)) return !0;
    var p;
    for (let d = 0; d < l.length; d++) {
      const g = l[d];
      if (g.type === 6 && g.name === "is" && g.value && g.value.content.startsWith("vue:")) return !0;
    }
    return !1;
  })(e) && (e.tagType = 1)), Ye.inRCDATA || (e.children = yy(o)), i === 0 && Xe.isIgnoreNewlineTag(n)) {
    const c = o[0];
    c && c.type === 2 && (c.content = c.content.replace(/^\r?\n/, ""));
  }
  i === 0 && Xe.isPreTag(n) && nh--, Jl === e && (Hr = Ye.inVPre = !1, Jl = null), Ye.inXML && (it[0] ? it[0].ns : Xe.ns) === 0 && (Ye.inXML = !1);
}
function gy(e, t) {
  let s = e;
  for (; Or.charCodeAt(s) !== t && s >= 0; ) s--;
  return s;
}
const gv = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]), yv = /\r\n/g;
function yy(e) {
  const t = Xe.whitespace !== "preserve";
  let s = !1;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    if (i.type === 2) if (nh) i.content = i.content.replace(yv, `
`);
    else if (xv(i.content)) {
      const o = e[n - 1] && e[n - 1].type, c = e[n + 1] && e[n + 1].type;
      !o || !c || t && (o === 3 && (c === 3 || c === 1) || o === 1 && (c === 3 || c === 1 && bv(i.content))) ? (s = !0, e[n] = null) : i.content = " ";
    } else t && (i.content = xy(i.content));
  }
  return s ? e.filter(Boolean) : e;
}
function xv(e) {
  for (let t = 0; t < e.length; t++) if (!qt(e.charCodeAt(t))) return !1;
  return !0;
}
function bv(e) {
  for (let t = 0; t < e.length; t++) {
    const s = e.charCodeAt(t);
    if (s === 10 || s === 13) return !0;
  }
  return !1;
}
function xy(e) {
  let t = "", s = !1;
  for (let n = 0; n < e.length; n++) qt(e.charCodeAt(n)) ? s || (t += " ", s = !0) : (t += e[n], s = !1);
  return t;
}
function Yl(e) {
  (it[0] || No).children.push(e);
}
function ot(e, t) {
  return { start: Ye.getPos(e), end: t == null ? t : Ye.getPos(t), source: t == null ? t : Et(e, t) };
}
function Gs(e, t) {
  e.end = Ye.getPos(t), e.source = Et(e.start.offset, t);
}
function Tv(e) {
  const t = { type: 6, name: e.rawName, nameLoc: ot(e.loc.start.offset, e.loc.start.offset + e.rawName.length), value: void 0, loc: e.loc };
  if (e.exp) {
    const s = e.exp.loc;
    s.end.offset < e.loc.end.offset && (s.start.offset--, s.start.column--, s.end.offset++, s.end.column++), t.value = { type: 2, content: e.exp.content, loc: s };
  }
  return t;
}
function Mi(e, t = !1, s, n = 0, i = 0) {
  const o = ue(e, t, s, n);
  if (!t && Xe.prefixIdentifiers && i !== 3 && e.trim()) {
    if (Lr(e)) return o.ast = null, o;
    try {
      const c = Xe.expressionPlugins, l = { plugins: c ? [...c, "typescript"] : ["typescript"] };
      o.ast = i === 2 ? ar.parse(` ${e} `, l).program : i === 1 ? ar.parseExpression(`(${e})=>{}`, l) : ar.parseExpression(`(${e})`, l);
    } catch (c) {
      o.ast = !1, It(45, s.start.offset, c.message);
    }
  }
  return o;
}
function It(e, t, s) {
  Xe.onError($e(e, ot(t, t), void 0, s));
}
function Oo(e, t) {
  if (Ye.reset(), Pt = null, Fe = null, Xt = "", _r = -1, ps = -1, it.length = 0, Or = e, Xe = kr({}, my), t) {
    let i;
    for (i in t) t[i] != null && (Xe[i] = t[i]);
  }
  Xe.decodeEntities && console.warn("[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds."), Ye.mode = Xe.parseMode === "html" ? 1 : Xe.parseMode === "sfc" ? 2 : 0, Ye.inXML = Xe.ns === 1 || Xe.ns === 2;
  const s = t && t.delimiters;
  s && (Ye.delimiterOpen = Co(s[0]), Ye.delimiterClose = Co(s[1]));
  const n = No = Ns([], e);
  return Ye.parse(Or), n.loc = ot(0, e.length), n.children = yy(n.children), No = null, n;
}
function vv(e, t) {
  co(e, void 0, t, !!by(e));
}
function by(e) {
  const t = e.children.filter((s) => s.type !== 3);
  return t.length !== 1 || t[0].type !== 1 || cn(t[0]) ? null : t[0];
}
function co(e, t, s, n = !1, i = !1) {
  const { children: o } = e, c = [];
  for (let g = 0; g < o.length; g++) {
    const f = o[g];
    if (f.type === 1 && f.tagType === 0) {
      const x = n ? 0 : jt(f, s);
      if (x > 0) {
        if (x >= 2) {
          f.codegenNode.patchFlag = -1, c.push(f);
          continue;
        }
      } else {
        const m = f.codegenNode;
        if (m.type === 13) {
          const y = m.patchFlag;
          if ((y === void 0 || y === 512 || y === 1) && vy(f, s) >= 2) {
            const v = ky(f);
            v && (m.props = s.hoist(v));
          }
          m.dynamicProps && (m.dynamicProps = s.hoist(m.dynamicProps));
        }
      }
    } else if (f.type === 12 && (n ? 0 : jt(f, s)) >= 2) {
      f.codegenNode.type === 14 && f.codegenNode.arguments.length > 0 && f.codegenNode.arguments.push(`-1 /* ${jn[-1]} */`), c.push(f);
      continue;
    }
    if (f.type === 1) {
      const x = f.tagType === 1;
      x && s.scopes.vSlot++, co(f, e, s, !1, i), x && s.scopes.vSlot--;
    } else if (f.type === 11) co(f, e, s, f.children.length === 1, !0);
    else if (f.type === 9) for (let x = 0; x < f.branches.length; x++) co(f.branches[x], e, s, f.branches[x].children.length === 1, i);
  }
  let l = !1;
  if (c.length === o.length && e.type === 1) {
    if (e.tagType === 0 && e.codegenNode && e.codegenNode.type === 13 && gt(e.codegenNode.children)) e.codegenNode.children = p(Nr(e.codegenNode.children)), l = !0;
    else if (e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !gt(e.codegenNode.children) && e.codegenNode.children.type === 15) {
      const g = d(e.codegenNode, "default");
      g && (g.returns = p(Nr(g.returns)), l = !0);
    } else if (e.tagType === 3 && t && t.type === 1 && t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !gt(t.codegenNode.children) && t.codegenNode.children.type === 15) {
      const g = rt(e, "slot", !0), f = g && g.arg && d(t.codegenNode, g.arg);
      f && (f.returns = p(Nr(f.returns)), l = !0);
    }
  }
  if (!l) for (const g of c) g.codegenNode = s.cache(g.codegenNode);
  function p(g) {
    const f = s.cache(g);
    return f.needArraySpread = !0, f;
  }
  function d(g, f) {
    if (g.children && !gt(g.children) && g.children.type === 15) {
      const x = g.children.properties.find((m) => m.key === f || m.key.content === f);
      return x && x.value;
    }
  }
  c.length && s.transformHoist && s.transformHoist(o, s, e);
}
function jt(e, t) {
  const { constantCache: s } = t;
  switch (e.type) {
    case 1:
      if (e.tagType !== 0) return 0;
      const n = s.get(e);
      if (n !== void 0) return n;
      const i = e.codegenNode;
      if (i.type !== 13 || i.isBlock && e.tag !== "svg" && e.tag !== "foreignObject" && e.tag !== "math") return 0;
      if (i.patchFlag === void 0) {
        let c = 3;
        const l = vy(e, t);
        if (l === 0) return s.set(e, 0), 0;
        l < c && (c = l);
        for (let p = 0; p < e.children.length; p++) {
          const d = jt(e.children[p], t);
          if (d === 0) return s.set(e, 0), 0;
          d < c && (c = d);
        }
        if (c > 1) for (let p = 0; p < e.props.length; p++) {
          const d = e.props[p];
          if (d.type === 7 && d.name === "bind" && d.exp) {
            const g = jt(d.exp, t);
            if (g === 0) return s.set(e, 0), 0;
            g < c && (c = g);
          }
        }
        if (i.isBlock) {
          for (let p = 0; p < e.props.length; p++)
            if (e.props[p].type === 7) return s.set(e, 0), 0;
          t.removeHelper(Qr), t.removeHelper(_s(t.inSSR, i.isComponent)), i.isBlock = !1, t.helper(ws(t.inSSR, i.isComponent));
        }
        return s.set(e, c), c;
      }
      return s.set(e, 0), 0;
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
    default:
      return 0;
    case 5:
    case 12:
      return jt(e.content, t);
    case 4:
      return e.constType;
    case 8:
      let o = 3;
      for (let c = 0; c < e.children.length; c++) {
        const l = e.children[c];
        if (De(l) || rs(l)) continue;
        const p = jt(l, t);
        if (p === 0) return 0;
        p < o && (o = p);
      }
      return o;
    case 20:
      return 2;
  }
}
const kv = /* @__PURE__ */ new Set([ua, da, sn, mn]);
function Ty(e, t) {
  if (e.type === 14 && !De(e.callee) && kv.has(e.callee)) {
    const s = e.arguments[0];
    if (s.type === 4) return jt(s, t);
    if (s.type === 14) return Ty(s, t);
  }
  return 0;
}
function vy(e, t) {
  let s = 3;
  const n = ky(e);
  if (n && n.type === 15) {
    const { properties: i } = n;
    for (let o = 0; o < i.length; o++) {
      const { key: c, value: l } = i[o], p = jt(c, t);
      if (p === 0) return p;
      let d;
      if (p < s && (s = p), d = l.type === 4 ? jt(l, t) : l.type === 14 ? Ty(l, t) : 0, d === 0) return d;
      d < s && (s = d);
    }
  }
  return s;
}
function ky(e) {
  const t = e.codegenNode;
  if (t.type === 13) return t.props;
}
function Ti(e, { filename: t = "", prefixIdentifiers: s = !1, hoistStatic: n = !1, hmr: i = !1, cacheHandlers: o = !1, nodeTransforms: c = [], directiveTransforms: l = {}, transformHoist: p = null, isBuiltInComponent: d = ac, isCustomElement: g = ac, expressionPlugins: f = [], scopeId: x = null, slotted: m = !0, ssr: y = !1, inSSR: v = !1, ssrCssVars: b = "", bindingMetadata: E = NT, inline: w = !1, isTS: C = !1, onError: A = Kp, onWarn: O = sy, compatConfig: D }) {
  const N = t.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), j = { filename: t, selfName: N && Yr(Dt(N[1])), prefixIdentifiers: s, hoistStatic: n, hmr: i, cacheHandlers: o, nodeTransforms: c, directiveTransforms: l, transformHoist: p, isBuiltInComponent: d, isCustomElement: g, expressionPlugins: f, scopeId: x, slotted: m, ssr: y, inSSR: v, ssrCssVars: b, bindingMetadata: E, inline: w, isTS: C, onError: A, onWarn: O, compatConfig: D, root: e, helpers: /* @__PURE__ */ new Map(), components: /* @__PURE__ */ new Set(), directives: /* @__PURE__ */ new Set(), hoists: [], imports: [], cached: [], constantCache: /* @__PURE__ */ new WeakMap(), temps: 0, identifiers: /* @__PURE__ */ Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, grandParent: null, currentNode: e, childIndex: 0, inVOnce: !1, helper(W) {
    const H = j.helpers.get(W) || 0;
    return j.helpers.set(W, H + 1), W;
  }, removeHelper(W) {
    const H = j.helpers.get(W);
    if (H) {
      const F = H - 1;
      F ? j.helpers.set(W, F) : j.helpers.delete(W);
    }
  }, helperString: (W) => `_${Mt[j.helper(W)]}`, replaceNode(W) {
    if (!j.currentNode) throw new Error("Node being replaced is already removed.");
    if (!j.parent) throw new Error("Cannot replace root node.");
    j.parent.children[j.childIndex] = j.currentNode = W;
  }, removeNode(W) {
    if (!j.parent) throw new Error("Cannot remove root node.");
    const H = j.parent.children, F = W ? H.indexOf(W) : j.currentNode ? j.childIndex : -1;
    if (F < 0) throw new Error("node being removed is not a child of current parent");
    W && W !== j.currentNode ? j.childIndex > F && (j.childIndex--, j.onNodeRemoved()) : (j.currentNode = null, j.onNodeRemoved()), j.parent.children.splice(F, 1);
  }, onNodeRemoved: ac, addIdentifiers(W) {
    De(W) ? U(W) : W.identifiers ? W.identifiers.forEach(U) : W.type === 4 && U(W.content);
  }, removeIdentifiers(W) {
    De(W) ? X(W) : W.identifiers ? W.identifiers.forEach(X) : W.type === 4 && X(W.content);
  }, hoist(W) {
    De(W) && (W = ue(W)), j.hoists.push(W);
    const H = ue(`_hoisted_${j.hoists.length}`, !1, W.loc, 2);
    return H.hoisted = W, H;
  }, cache(W, H = !1, F = !1) {
    const q = Yg(j.cached.length, W, H, F);
    return j.cached.push(q), q;
  } };
  function U(W) {
    const { identifiers: H } = j;
    H[W] === void 0 && (H[W] = 0), H[W]++;
  }
  function X(W) {
    j.identifiers[W]--;
  }
  return j;
}
function ih(e, t) {
  const s = Ti(e, t);
  ln(e, s), t.hoistStatic && vv(e, s), t.ssr || (function(n, i) {
    const { helper: o } = i, { children: c } = n;
    if (c.length === 1) {
      const l = by(n);
      if (l && l.codegenNode) {
        const p = l.codegenNode;
        p.type === 13 && ya(p, i), n.codegenNode = p;
      } else n.codegenNode = c[0];
    } else if (c.length > 1) {
      let l = 64;
      c.filter((p) => p.type !== 3).length === 1 && (l |= 2048), n.codegenNode = on(i, o(rn), void 0, n.children, l, void 0, void 0, !0, void 0, !1);
    }
  })(e, s), e.helpers = /* @__PURE__ */ new Set([...s.helpers.keys()]), e.components = [...s.components], e.directives = [...s.directives], e.imports = s.imports, e.hoists = s.hoists, e.temps = s.temps, e.cached = s.cached, e.transformed = !0;
}
function ln(e, t) {
  t.currentNode = e;
  const { nodeTransforms: s } = t, n = [];
  for (let o = 0; o < s.length; o++) {
    const c = s[o](e, t);
    if (c && (gt(c) ? n.push(...c) : n.push(c)), !t.currentNode) return;
    e = t.currentNode;
  }
  switch (e.type) {
    case 3:
      t.ssr || t.helper(fn);
      break;
    case 5:
      t.ssr || t.helper(xi);
      break;
    case 9:
      for (let o = 0; o < e.branches.length; o++) ln(e.branches[o], t);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      (function(o, c) {
        let l = 0;
        const p = () => {
          l--;
        };
        for (; l < o.children.length; l++) {
          const d = o.children[l];
          De(d) || (c.grandParent = c.parent, c.parent = o, c.childIndex = l, c.onNodeRemoved = p, ln(d, c));
        }
      })(e, t);
  }
  t.currentNode = e;
  let i = n.length;
  for (; i--; ) n[i]();
}
function vi(e, t) {
  const s = De(e) ? (n) => n === e : (n) => e.test(n);
  return (n, i) => {
    if (n.type === 1) {
      const { props: o } = n;
      if (n.tagType === 3 && o.some(Ea)) return;
      const c = [];
      for (let l = 0; l < o.length; l++) {
        const p = o[l];
        if (p.type === 7 && s(p.name)) {
          o.splice(l, 1), l--;
          const d = t(n, p, i);
          d && c.push(d);
        }
      }
      return c;
    }
  };
}
var g1, y1, Di = {}, hc = {}, Fi = {}, ji = {};
function Sv() {
  if (g1) return ji;
  g1 = 1;
  var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return ji.encode = function(t) {
    if (0 <= t && t < e.length) return e[t];
    throw new TypeError("Must be between 0 and 63: " + t);
  }, ji.decode = function(t) {
    return 65 <= t && t <= 90 ? t - 65 : 97 <= t && t <= 122 ? t - 97 + 26 : 48 <= t && t <= 57 ? t - 48 + 52 : t == 43 ? 62 : t == 47 ? 63 : -1;
  }, ji;
}
function Sy() {
  if (y1) return Fi;
  y1 = 1;
  var e = Sv();
  return Fi.encode = function(t) {
    var s, n = "", i = (function(o) {
      return o < 0 ? 1 + (-o << 1) : 0 + (o << 1);
    })(t);
    do
      s = 31 & i, (i >>>= 5) > 0 && (s |= 32), n += e.encode(s);
    while (i > 0);
    return n;
  }, Fi.decode = function(t, s, n) {
    var i, o, c, l, p = t.length, d = 0, g = 0;
    do {
      if (s >= p) throw new Error("Expected more digits in base 64 VLQ value.");
      if ((o = e.decode(t.charCodeAt(s++))) === -1) throw new Error("Invalid base64 digit: " + t.charAt(s - 1));
      i = !!(32 & o), d += (o &= 31) << g, g += 5;
    } while (i);
    n.value = (l = (c = d) >> 1, 1 & ~c ? l : -l), n.rest = s;
  }, Fi;
}
var x1, b1 = {};
function ki() {
  return x1 || (x1 = 1, (function(e) {
    e.getArg = function(m, y, v) {
      if (y in m) return m[y];
      if (arguments.length === 3) return v;
      throw new Error('"' + y + '" is a required argument.');
    };
    var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
    function n(m) {
      var y = m.match(t);
      return y ? { scheme: y[1], auth: y[2], host: y[3], port: y[4], path: y[5] } : null;
    }
    function i(m) {
      var y = "";
      return m.scheme && (y += m.scheme + ":"), y += "//", m.auth && (y += m.auth + "@"), m.host && (y += m.host), m.port && (y += ":" + m.port), m.path && (y += m.path), y;
    }
    e.urlParse = n, e.urlGenerate = i;
    var o, c, l = (o = function(m) {
      var y = m, v = n(m);
      if (v) {
        if (!v.path) return m;
        y = v.path;
      }
      for (var b = e.isAbsolute(y), E = [], w = 0, C = 0; ; ) {
        if (w = C, (C = y.indexOf("/", w)) === -1) {
          E.push(y.slice(w));
          break;
        }
        for (E.push(y.slice(w, C)); C < y.length && y[C] === "/"; ) C++;
      }
      var A, O = 0;
      for (C = E.length - 1; C >= 0; C--) (A = E[C]) === "." ? E.splice(C, 1) : A === ".." ? O++ : O > 0 && (A === "" ? (E.splice(C + 1, O), O = 0) : (E.splice(C, 2), O--));
      return (y = E.join("/")) === "" && (y = b ? "/" : "."), v ? (v.path = y, i(v)) : y;
    }, c = [], function(m) {
      for (var y = 0; y < c.length; y++) if (c[y].input === m) {
        var v = c[0];
        return c[0] = c[y], c[y] = v, c[0].result;
      }
      var b = o(m);
      return c.unshift({ input: m, result: b }), c.length > 32 && c.pop(), b;
    });
    function p(m, y) {
      m === "" && (m = "."), y === "" && (y = ".");
      var v = n(y), b = n(m);
      if (b && (m = b.path || "/"), v && !v.scheme) return b && (v.scheme = b.scheme), i(v);
      if (v || y.match(s)) return y;
      if (b && !b.host && !b.path) return b.host = y, i(b);
      var E = y.charAt(0) === "/" ? y : l(m.replace(/\/+$/, "") + "/" + y);
      return b ? (b.path = E, i(b)) : E;
    }
    e.normalize = l, e.join = p, e.isAbsolute = function(m) {
      return m.charAt(0) === "/" || t.test(m);
    }, e.relative = function(m, y) {
      m === "" && (m = "."), m = m.replace(/\/$/, "");
      for (var v = 0; y.indexOf(m + "/") !== 0; ) {
        var b = m.lastIndexOf("/");
        if (b < 0 || (m = m.slice(0, b)).match(/^([^\/]+:\/)?\/*$/)) return y;
        ++v;
      }
      return Array(v + 1).join("../") + y.substr(m.length + 1);
    };
    var d = !("__proto__" in /* @__PURE__ */ Object.create(null));
    function g(m) {
      return m;
    }
    function f(m) {
      if (!m) return !1;
      var y = m.length;
      if (y < 9 || m.charCodeAt(y - 1) !== 95 || m.charCodeAt(y - 2) !== 95 || m.charCodeAt(y - 3) !== 111 || m.charCodeAt(y - 4) !== 116 || m.charCodeAt(y - 5) !== 111 || m.charCodeAt(y - 6) !== 114 || m.charCodeAt(y - 7) !== 112 || m.charCodeAt(y - 8) !== 95 || m.charCodeAt(y - 9) !== 95) return !1;
      for (var v = y - 10; v >= 0; v--) if (m.charCodeAt(v) !== 36) return !1;
      return !0;
    }
    function x(m, y) {
      return m === y ? 0 : m === null ? 1 : y === null ? -1 : m > y ? 1 : -1;
    }
    e.toSetString = d ? g : function(m) {
      return f(m) ? "$" + m : m;
    }, e.fromSetString = d ? g : function(m) {
      return f(m) ? m.slice(1) : m;
    }, e.compareByOriginalPositions = function(m, y, v) {
      var b = x(m.source, y.source);
      return b !== 0 || (b = m.originalLine - y.originalLine) !== 0 || (b = m.originalColumn - y.originalColumn) !== 0 || v || (b = m.generatedColumn - y.generatedColumn) !== 0 || (b = m.generatedLine - y.generatedLine) !== 0 ? b : x(m.name, y.name);
    }, e.compareByOriginalPositionsNoSource = function(m, y, v) {
      var b;
      return (b = m.originalLine - y.originalLine) !== 0 || (b = m.originalColumn - y.originalColumn) !== 0 || v || (b = m.generatedColumn - y.generatedColumn) !== 0 || (b = m.generatedLine - y.generatedLine) !== 0 ? b : x(m.name, y.name);
    }, e.compareByGeneratedPositionsDeflated = function(m, y, v) {
      var b = m.generatedLine - y.generatedLine;
      return b !== 0 || (b = m.generatedColumn - y.generatedColumn) !== 0 || v || (b = x(m.source, y.source)) !== 0 || (b = m.originalLine - y.originalLine) !== 0 || (b = m.originalColumn - y.originalColumn) !== 0 ? b : x(m.name, y.name);
    }, e.compareByGeneratedPositionsDeflatedNoLine = function(m, y, v) {
      var b = m.generatedColumn - y.generatedColumn;
      return b !== 0 || v || (b = x(m.source, y.source)) !== 0 || (b = m.originalLine - y.originalLine) !== 0 || (b = m.originalColumn - y.originalColumn) !== 0 ? b : x(m.name, y.name);
    }, e.compareByGeneratedPositionsInflated = function(m, y) {
      var v = m.generatedLine - y.generatedLine;
      return v !== 0 || (v = m.generatedColumn - y.generatedColumn) !== 0 || (v = x(m.source, y.source)) !== 0 || (v = m.originalLine - y.originalLine) !== 0 || (v = m.originalColumn - y.originalColumn) !== 0 ? v : x(m.name, y.name);
    }, e.parseSourceMapInput = function(m) {
      return JSON.parse(m.replace(/^\)]}'[^\n]*\n/, ""));
    }, e.computeSourceURL = function(m, y, v) {
      if (y = y || "", m && (m[m.length - 1] !== "/" && y[0] !== "/" && (m += "/"), y = m + y), v) {
        var b = n(v);
        if (!b) throw new Error("sourceMapURL could not be parsed");
        if (b.path) {
          var E = b.path.lastIndexOf("/");
          E >= 0 && (b.path = b.path.substring(0, E + 1));
        }
        y = p(i(b), y);
      }
      return l(y);
    };
  })(b1)), b1;
}
var T1, uc = {};
function Ey() {
  if (T1) return uc;
  T1 = 1;
  var e = ki(), t = Object.prototype.hasOwnProperty, s = typeof Map < "u";
  function n() {
    this._array = [], this._set = s ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return n.fromArray = function(i, o) {
    for (var c = new n(), l = 0, p = i.length; l < p; l++) c.add(i[l], o);
    return c;
  }, n.prototype.size = function() {
    return s ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, n.prototype.add = function(i, o) {
    var c = s ? i : e.toSetString(i), l = s ? this.has(i) : t.call(this._set, c), p = this._array.length;
    l && !o || this._array.push(i), l || (s ? this._set.set(i, p) : this._set[c] = p);
  }, n.prototype.has = function(i) {
    if (s) return this._set.has(i);
    var o = e.toSetString(i);
    return t.call(this._set, o);
  }, n.prototype.indexOf = function(i) {
    if (s) {
      var o = this._set.get(i);
      if (o >= 0) return o;
    } else {
      var c = e.toSetString(i);
      if (t.call(this._set, c)) return this._set[c];
    }
    throw new Error('"' + i + '" is not in the set.');
  }, n.prototype.at = function(i) {
    if (i >= 0 && i < this._array.length) return this._array[i];
    throw new Error("No element indexed by " + i);
  }, n.prototype.toArray = function() {
    return this._array.slice();
  }, uc.ArraySet = n, uc;
}
var v1, k1, dc = {};
function Ev() {
  if (v1) return dc;
  v1 = 1;
  var e = ki();
  function t() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return t.prototype.unsortedForEach = function(s, n) {
    this._array.forEach(s, n);
  }, t.prototype.add = function(s) {
    var n, i, o, c, l, p;
    n = this._last, i = s, o = n.generatedLine, c = i.generatedLine, l = n.generatedColumn, p = i.generatedColumn, c > o || c == o && p >= l || e.compareByGeneratedPositionsInflated(n, i) <= 0 ? (this._last = s, this._array.push(s)) : (this._sorted = !1, this._array.push(s));
  }, t.prototype.toArray = function() {
    return this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, dc.MappingList = t, dc;
}
function wy() {
  if (k1) return hc;
  k1 = 1;
  var e = Sy(), t = ki(), s = Ey().ArraySet, n = Ev().MappingList;
  function i(o) {
    o || (o = {}), this._file = t.getArg(o, "file", null), this._sourceRoot = t.getArg(o, "sourceRoot", null), this._skipValidation = t.getArg(o, "skipValidation", !1), this._ignoreInvalidMapping = t.getArg(o, "ignoreInvalidMapping", !1), this._sources = new s(), this._names = new s(), this._mappings = new n(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(o, c) {
    var l = o.sourceRoot, p = new i(Object.assign(c || {}, { file: o.file, sourceRoot: l }));
    return o.eachMapping(function(d) {
      var g = { generated: { line: d.generatedLine, column: d.generatedColumn } };
      d.source != null && (g.source = d.source, l != null && (g.source = t.relative(l, g.source)), g.original = { line: d.originalLine, column: d.originalColumn }, d.name != null && (g.name = d.name)), p.addMapping(g);
    }), o.sources.forEach(function(d) {
      var g = d;
      l !== null && (g = t.relative(l, d)), p._sources.has(g) || p._sources.add(g);
      var f = o.sourceContentFor(d);
      f != null && p.setSourceContent(d, f);
    }), p;
  }, i.prototype.addMapping = function(o) {
    var c = t.getArg(o, "generated"), l = t.getArg(o, "original", null), p = t.getArg(o, "source", null), d = t.getArg(o, "name", null);
    (this._skipValidation || this._validateMapping(c, l, p, d) !== !1) && (p != null && (p = String(p), this._sources.has(p) || this._sources.add(p)), d != null && (d = String(d), this._names.has(d) || this._names.add(d)), this._mappings.add({ generatedLine: c.line, generatedColumn: c.column, originalLine: l != null && l.line, originalColumn: l != null && l.column, source: p, name: d }));
  }, i.prototype.setSourceContent = function(o, c) {
    var l = o;
    this._sourceRoot != null && (l = t.relative(this._sourceRoot, l)), c != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[t.toSetString(l)] = c) : this._sourcesContents && (delete this._sourcesContents[t.toSetString(l)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(o, c, l) {
    var p = c;
    if (c == null) {
      if (o.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      p = o.file;
    }
    var d = this._sourceRoot;
    d != null && (p = t.relative(d, p));
    var g = new s(), f = new s();
    this._mappings.unsortedForEach(function(x) {
      if (x.source === p && x.originalLine != null) {
        var m = o.originalPositionFor({ line: x.originalLine, column: x.originalColumn });
        m.source != null && (x.source = m.source, l != null && (x.source = t.join(l, x.source)), d != null && (x.source = t.relative(d, x.source)), x.originalLine = m.line, x.originalColumn = m.column, m.name != null && (x.name = m.name));
      }
      var y = x.source;
      y == null || g.has(y) || g.add(y);
      var v = x.name;
      v == null || f.has(v) || f.add(v);
    }, this), this._sources = g, this._names = f, o.sources.forEach(function(x) {
      var m = o.sourceContentFor(x);
      m != null && (l != null && (x = t.join(l, x)), d != null && (x = t.relative(d, x)), this.setSourceContent(x, m));
    }, this);
  }, i.prototype._validateMapping = function(o, c, l, p) {
    if (c && typeof c.line != "number" && typeof c.column != "number") {
      var d = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping) return typeof console < "u" && console.warn && console.warn(d), !1;
      throw new Error(d);
    }
    if ((!(o && "line" in o && "column" in o && o.line > 0 && o.column >= 0) || c || l || p) && !(o && "line" in o && "column" in o && c && "line" in c && "column" in c && o.line > 0 && o.column >= 0 && c.line > 0 && c.column >= 0 && l)) {
      if (d = "Invalid mapping: " + JSON.stringify({ generated: o, source: l, original: c, name: p }), this._ignoreInvalidMapping) return typeof console < "u" && console.warn && console.warn(d), !1;
      throw new Error(d);
    }
  }, i.prototype._serializeMappings = function() {
    for (var o, c, l, p, d = 0, g = 1, f = 0, x = 0, m = 0, y = 0, v = "", b = this._mappings.toArray(), E = 0, w = b.length; E < w; E++) {
      if (o = "", (c = b[E]).generatedLine !== g) for (d = 0; c.generatedLine !== g; ) o += ";", g++;
      else if (E > 0) {
        if (!t.compareByGeneratedPositionsInflated(c, b[E - 1])) continue;
        o += ",";
      }
      o += e.encode(c.generatedColumn - d), d = c.generatedColumn, c.source != null && (p = this._sources.indexOf(c.source), o += e.encode(p - y), y = p, o += e.encode(c.originalLine - 1 - x), x = c.originalLine - 1, o += e.encode(c.originalColumn - f), f = c.originalColumn, c.name != null && (l = this._names.indexOf(c.name), o += e.encode(l - m), m = l)), v += o;
    }
    return v;
  }, i.prototype._generateSourcesContent = function(o, c) {
    return o.map(function(l) {
      if (!this._sourcesContents) return null;
      c != null && (l = t.relative(c, l));
      var p = t.toSetString(l);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, p) ? this._sourcesContents[p] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var o = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return this._file != null && (o.file = this._file), this._sourceRoot != null && (o.sourceRoot = this._sourceRoot), this._sourcesContents && (o.sourcesContent = this._generateSourcesContent(o.sources, o.sourceRoot)), o;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, hc.SourceMapGenerator = i, hc;
}
var S1, _n = {}, E1 = {};
function wv() {
  return S1 || (S1 = 1, (function(e) {
    function t(s, n, i, o, c, l) {
      var p = Math.floor((n - s) / 2) + s, d = c(i, o[p], !0);
      return d === 0 ? p : d > 0 ? n - p > 1 ? t(p, n, i, o, c, l) : l == e.LEAST_UPPER_BOUND ? n < o.length ? n : -1 : p : p - s > 1 ? t(s, p, i, o, c, l) : l == e.LEAST_UPPER_BOUND ? p : s < 0 ? -1 : s;
    }
    e.GREATEST_LOWER_BOUND = 1, e.LEAST_UPPER_BOUND = 2, e.search = function(s, n, i, o) {
      if (n.length === 0) return -1;
      var c = t(-1, n.length, s, n, i, o || e.GREATEST_LOWER_BOUND);
      if (c < 0) return -1;
      for (; c - 1 >= 0 && i(n[c], n[c - 1], !0) === 0; ) --c;
      return c;
    };
  })(E1)), E1;
}
var w1, _1, fc = {};
function _v() {
  if (w1) return fc;
  function e(s) {
    function n(i, o, c) {
      var l = i[o];
      i[o] = i[c], i[c] = l;
    }
    return function i(o, c, l, p) {
      if (l < p) {
        var d = l - 1;
        n(o, (m = l, y = p, Math.round(m + Math.random() * (y - m))), p);
        for (var g = o[p], f = l; f < p; f++) c(o[f], g, !1) <= 0 && n(o, d += 1, f);
        n(o, d + 1, f);
        var x = d + 1;
        i(o, c, l, x - 1), i(o, c, x + 1, p);
      }
      var m, y;
    };
  }
  w1 = 1;
  let t = /* @__PURE__ */ new WeakMap();
  return fc.quickSort = function(s, n, i = 0) {
    let o = t.get(n);
    o === void 0 && (o = (function(c) {
      let l = e.toString();
      return new Function(`return ${l}`)()(c);
    })(n), t.set(n, o)), o(s, n, i, s.length - 1);
  }, fc;
}
function Pv() {
  if (_1) return _n;
  _1 = 1;
  var e = ki(), t = wv(), s = Ey().ArraySet, n = Sy(), i = _v().quickSort;
  function o(f, x) {
    var m = f;
    return typeof f == "string" && (m = e.parseSourceMapInput(f)), m.sections != null ? new g(m, x) : new c(m, x);
  }
  function c(f, x) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var y = e.getArg(m, "version"), v = e.getArg(m, "sources"), b = e.getArg(m, "names", []), E = e.getArg(m, "sourceRoot", null), w = e.getArg(m, "sourcesContent", null), C = e.getArg(m, "mappings"), A = e.getArg(m, "file", null);
    if (y != this._version) throw new Error("Unsupported version: " + y);
    E && (E = e.normalize(E)), v = v.map(String).map(e.normalize).map(function(O) {
      return E && e.isAbsolute(E) && e.isAbsolute(O) ? e.relative(E, O) : O;
    }), this._names = s.fromArray(b.map(String), !0), this._sources = s.fromArray(v, !0), this._absoluteSources = this._sources.toArray().map(function(O) {
      return e.computeSourceURL(E, O, x);
    }), this.sourceRoot = E, this.sourcesContent = w, this._mappings = C, this._sourceMapURL = x, this.file = A;
  }
  function l() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  o.fromSourceMap = function(f, x) {
    return c.fromSourceMap(f, x);
  }, o.prototype._version = 3, o.prototype.__generatedMappings = null, Object.defineProperty(o.prototype, "_generatedMappings", { configurable: !0, enumerable: !0, get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  } }), o.prototype.__originalMappings = null, Object.defineProperty(o.prototype, "_originalMappings", { configurable: !0, enumerable: !0, get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  } }), o.prototype._charIsMappingSeparator = function(f, x) {
    var m = f.charAt(x);
    return m === ";" || m === ",";
  }, o.prototype._parseMappings = function(f, x) {
    throw new Error("Subclasses must implement _parseMappings");
  }, o.GENERATED_ORDER = 1, o.ORIGINAL_ORDER = 2, o.GREATEST_LOWER_BOUND = 1, o.LEAST_UPPER_BOUND = 2, o.prototype.eachMapping = function(f, x, m) {
    var y, v = x || null;
    switch (m || o.GENERATED_ORDER) {
      case o.GENERATED_ORDER:
        y = this._generatedMappings;
        break;
      case o.ORIGINAL_ORDER:
        y = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    for (var b = this.sourceRoot, E = f.bind(v), w = this._names, C = this._sources, A = this._sourceMapURL, O = 0, D = y.length; O < D; O++) {
      var N = y[O], j = N.source === null ? null : C.at(N.source);
      j !== null && (j = e.computeSourceURL(b, j, A)), E({ source: j, generatedLine: N.generatedLine, generatedColumn: N.generatedColumn, originalLine: N.originalLine, originalColumn: N.originalColumn, name: N.name === null ? null : w.at(N.name) });
    }
  }, o.prototype.allGeneratedPositionsFor = function(f) {
    var x = e.getArg(f, "line"), m = { source: e.getArg(f, "source"), originalLine: x, originalColumn: e.getArg(f, "column", 0) };
    if (m.source = this._findSourceIndex(m.source), m.source < 0) return [];
    var y = [], v = this._findMapping(m, this._originalMappings, "originalLine", "originalColumn", e.compareByOriginalPositions, t.LEAST_UPPER_BOUND);
    if (v >= 0) {
      var b = this._originalMappings[v];
      if (f.column === void 0) for (var E = b.originalLine; b && b.originalLine === E; ) y.push({ line: e.getArg(b, "generatedLine", null), column: e.getArg(b, "generatedColumn", null), lastColumn: e.getArg(b, "lastGeneratedColumn", null) }), b = this._originalMappings[++v];
      else for (var w = b.originalColumn; b && b.originalLine === x && b.originalColumn == w; ) y.push({ line: e.getArg(b, "generatedLine", null), column: e.getArg(b, "generatedColumn", null), lastColumn: e.getArg(b, "lastGeneratedColumn", null) }), b = this._originalMappings[++v];
    }
    return y;
  }, _n.SourceMapConsumer = o, c.prototype = Object.create(o.prototype), c.prototype.consumer = o, c.prototype._findSourceIndex = function(f) {
    var x, m = f;
    if (this.sourceRoot != null && (m = e.relative(this.sourceRoot, m)), this._sources.has(m)) return this._sources.indexOf(m);
    for (x = 0; x < this._absoluteSources.length; ++x) if (this._absoluteSources[x] == f) return x;
    return -1;
  }, c.fromSourceMap = function(f, x) {
    var m = Object.create(c.prototype), y = m._names = s.fromArray(f._names.toArray(), !0), v = m._sources = s.fromArray(f._sources.toArray(), !0);
    m.sourceRoot = f._sourceRoot, m.sourcesContent = f._generateSourcesContent(m._sources.toArray(), m.sourceRoot), m.file = f._file, m._sourceMapURL = x, m._absoluteSources = m._sources.toArray().map(function(N) {
      return e.computeSourceURL(m.sourceRoot, N, x);
    });
    for (var b = f._mappings.toArray().slice(), E = m.__generatedMappings = [], w = m.__originalMappings = [], C = 0, A = b.length; C < A; C++) {
      var O = b[C], D = new l();
      D.generatedLine = O.generatedLine, D.generatedColumn = O.generatedColumn, O.source && (D.source = v.indexOf(O.source), D.originalLine = O.originalLine, D.originalColumn = O.originalColumn, O.name && (D.name = y.indexOf(O.name)), w.push(D)), E.push(D);
    }
    return i(m.__originalMappings, e.compareByOriginalPositions), m;
  }, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", { get: function() {
    return this._absoluteSources.slice();
  } });
  const p = e.compareByGeneratedPositionsDeflatedNoLine;
  function d(f, x) {
    let m = f.length, y = f.length - x;
    if (!(y <= 1)) if (y == 2) {
      let v = f[x], b = f[x + 1];
      p(v, b) > 0 && (f[x] = b, f[x + 1] = v);
    } else if (y < 20) for (let v = x; v < m; v++) for (let b = v; b > x; b--) {
      let E = f[b - 1], w = f[b];
      if (p(E, w) <= 0) break;
      f[b - 1] = w, f[b] = E;
    }
    else i(f, p, x);
  }
  function g(f, x) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var y = e.getArg(m, "version"), v = e.getArg(m, "sections");
    if (y != this._version) throw new Error("Unsupported version: " + y);
    this._sources = new s(), this._names = new s();
    var b = { line: -1, column: 0 };
    this._sections = v.map(function(E) {
      if (E.url) throw new Error("Support for url field in sections not implemented.");
      var w = e.getArg(E, "offset"), C = e.getArg(w, "line"), A = e.getArg(w, "column");
      if (C < b.line || C === b.line && A < b.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return b = w, { generatedOffset: { generatedLine: C + 1, generatedColumn: A + 1 }, consumer: new o(e.getArg(E, "map"), x) };
    });
  }
  return c.prototype._parseMappings = function(f, x) {
    var m, y, v, b, E = 1, w = 0, C = 0, A = 0, O = 0, D = 0, N = f.length, j = 0, U = {}, X = [], W = [];
    let H = 0;
    for (; j < N; ) if (f.charAt(j) === ";") E++, j++, w = 0, d(W, H), H = W.length;
    else if (f.charAt(j) === ",") j++;
    else {
      for ((m = new l()).generatedLine = E, v = j; v < N && !this._charIsMappingSeparator(f, v); v++) ;
      for (f.slice(j, v), y = []; j < v; ) n.decode(f, j, U), b = U.value, j = U.rest, y.push(b);
      if (y.length === 2) throw new Error("Found a source, but no line and column");
      if (y.length === 3) throw new Error("Found a source and line, but no column");
      if (m.generatedColumn = w + y[0], w = m.generatedColumn, y.length > 1 && (m.source = O + y[1], O += y[1], m.originalLine = C + y[2], C = m.originalLine, m.originalLine += 1, m.originalColumn = A + y[3], A = m.originalColumn, y.length > 4 && (m.name = D + y[4], D += y[4])), W.push(m), typeof m.originalLine == "number") {
        let q = m.source;
        for (; X.length <= q; ) X.push(null);
        X[q] === null && (X[q] = []), X[q].push(m);
      }
    }
    d(W, H), this.__generatedMappings = W;
    for (var F = 0; F < X.length; F++) X[F] != null && i(X[F], e.compareByOriginalPositionsNoSource);
    this.__originalMappings = [].concat(...X);
  }, c.prototype._findMapping = function(f, x, m, y, v, b) {
    if (f[m] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + f[m]);
    if (f[y] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + f[y]);
    return t.search(f, x, v, b);
  }, c.prototype.computeColumnSpans = function() {
    for (var f = 0; f < this._generatedMappings.length; ++f) {
      var x = this._generatedMappings[f];
      if (f + 1 < this._generatedMappings.length) {
        var m = this._generatedMappings[f + 1];
        if (x.generatedLine === m.generatedLine) {
          x.lastGeneratedColumn = m.generatedColumn - 1;
          continue;
        }
      }
      x.lastGeneratedColumn = 1 / 0;
    }
  }, c.prototype.originalPositionFor = function(f) {
    var x = { generatedLine: e.getArg(f, "line"), generatedColumn: e.getArg(f, "column") }, m = this._findMapping(x, this._generatedMappings, "generatedLine", "generatedColumn", e.compareByGeneratedPositionsDeflated, e.getArg(f, "bias", o.GREATEST_LOWER_BOUND));
    if (m >= 0) {
      var y = this._generatedMappings[m];
      if (y.generatedLine === x.generatedLine) {
        var v = e.getArg(y, "source", null);
        v !== null && (v = this._sources.at(v), v = e.computeSourceURL(this.sourceRoot, v, this._sourceMapURL));
        var b = e.getArg(y, "name", null);
        return b !== null && (b = this._names.at(b)), { source: v, line: e.getArg(y, "originalLine", null), column: e.getArg(y, "originalColumn", null), name: b };
      }
    }
    return { source: null, line: null, column: null, name: null };
  }, c.prototype.hasContentsOfAllSources = function() {
    return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(f) {
      return f == null;
    });
  }, c.prototype.sourceContentFor = function(f, x) {
    if (!this.sourcesContent) return null;
    var m = this._findSourceIndex(f);
    if (m >= 0) return this.sourcesContent[m];
    var y, v = f;
    if (this.sourceRoot != null && (v = e.relative(this.sourceRoot, v)), this.sourceRoot != null && (y = e.urlParse(this.sourceRoot))) {
      var b = v.replace(/^file:\/\//, "");
      if (y.scheme == "file" && this._sources.has(b)) return this.sourcesContent[this._sources.indexOf(b)];
      if ((!y.path || y.path == "/") && this._sources.has("/" + v)) return this.sourcesContent[this._sources.indexOf("/" + v)];
    }
    if (x) return null;
    throw new Error('"' + v + '" is not in the SourceMap.');
  }, c.prototype.generatedPositionFor = function(f) {
    var x = e.getArg(f, "source");
    if ((x = this._findSourceIndex(x)) < 0) return { line: null, column: null, lastColumn: null };
    var m = { source: x, originalLine: e.getArg(f, "line"), originalColumn: e.getArg(f, "column") }, y = this._findMapping(m, this._originalMappings, "originalLine", "originalColumn", e.compareByOriginalPositions, e.getArg(f, "bias", o.GREATEST_LOWER_BOUND));
    if (y >= 0) {
      var v = this._originalMappings[y];
      if (v.source === m.source) return { line: e.getArg(v, "generatedLine", null), column: e.getArg(v, "generatedColumn", null), lastColumn: e.getArg(v, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  }, _n.BasicSourceMapConsumer = c, g.prototype = Object.create(o.prototype), g.prototype.constructor = o, g.prototype._version = 3, Object.defineProperty(g.prototype, "sources", { get: function() {
    for (var f = [], x = 0; x < this._sections.length; x++) for (var m = 0; m < this._sections[x].consumer.sources.length; m++) f.push(this._sections[x].consumer.sources[m]);
    return f;
  } }), g.prototype.originalPositionFor = function(f) {
    var x = { generatedLine: e.getArg(f, "line"), generatedColumn: e.getArg(f, "column") }, m = t.search(x, this._sections, function(v, b) {
      var E = v.generatedLine - b.generatedOffset.generatedLine;
      return E || v.generatedColumn - b.generatedOffset.generatedColumn;
    }), y = this._sections[m];
    return y ? y.consumer.originalPositionFor({ line: x.generatedLine - (y.generatedOffset.generatedLine - 1), column: x.generatedColumn - (y.generatedOffset.generatedLine === x.generatedLine ? y.generatedOffset.generatedColumn - 1 : 0), bias: f.bias }) : { source: null, line: null, column: null, name: null };
  }, g.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(f) {
      return f.consumer.hasContentsOfAllSources();
    });
  }, g.prototype.sourceContentFor = function(f, x) {
    for (var m = 0; m < this._sections.length; m++) {
      var y = this._sections[m].consumer.sourceContentFor(f, !0);
      if (y || y === "") return y;
    }
    if (x) return null;
    throw new Error('"' + f + '" is not in the SourceMap.');
  }, g.prototype.generatedPositionFor = function(f) {
    for (var x = 0; x < this._sections.length; x++) {
      var m = this._sections[x];
      if (m.consumer._findSourceIndex(e.getArg(f, "source")) !== -1) {
        var y = m.consumer.generatedPositionFor(f);
        if (y) return { line: y.line + (m.generatedOffset.generatedLine - 1), column: y.column + (m.generatedOffset.generatedLine === y.line ? m.generatedOffset.generatedColumn - 1 : 0) };
      }
    }
    return { line: null, column: null };
  }, g.prototype._parseMappings = function(f, x) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var m = 0; m < this._sections.length; m++) for (var y = this._sections[m], v = y.consumer._generatedMappings, b = 0; b < v.length; b++) {
      var E = v[b], w = y.consumer._sources.at(E.source);
      w !== null && (w = e.computeSourceURL(y.consumer.sourceRoot, w, this._sourceMapURL)), this._sources.add(w), w = this._sources.indexOf(w);
      var C = null;
      E.name && (C = y.consumer._names.at(E.name), this._names.add(C), C = this._names.indexOf(C));
      var A = { source: w, generatedLine: E.generatedLine + (y.generatedOffset.generatedLine - 1), generatedColumn: E.generatedColumn + (y.generatedOffset.generatedLine === E.generatedLine ? y.generatedOffset.generatedColumn - 1 : 0), originalLine: E.originalLine, originalColumn: E.originalColumn, name: C };
      this.__generatedMappings.push(A), typeof A.originalLine == "number" && this.__originalMappings.push(A);
    }
    i(this.__generatedMappings, e.compareByGeneratedPositionsDeflated), i(this.__originalMappings, e.compareByOriginalPositions);
  }, _n.IndexedSourceMapConsumer = g, _n;
}
var P1, A1, mc = {};
function Av() {
  if (P1) return mc;
  P1 = 1;
  var e = wy().SourceMapGenerator, t = ki(), s = /(\r?\n)/, n = "$$$isSourceNode$$$";
  function i(o, c, l, p, d) {
    this.children = [], this.sourceContents = {}, this.line = o ?? null, this.column = c ?? null, this.source = l ?? null, this.name = d ?? null, this[n] = !0, p != null && this.add(p);
  }
  return i.fromStringWithSourceMap = function(o, c, l) {
    var p = new i(), d = o.split(s), g = 0, f = function() {
      return b() + (b() || "");
      function b() {
        return g < d.length ? d[g++] : void 0;
      }
    }, x = 1, m = 0, y = null;
    return c.eachMapping(function(b) {
      if (y !== null) {
        if (!(x < b.generatedLine)) {
          var E = (w = d[g] || "").substr(0, b.generatedColumn - m);
          return d[g] = w.substr(b.generatedColumn - m), m = b.generatedColumn, v(y, E), void (y = b);
        }
        v(y, f()), x++, m = 0;
      }
      for (; x < b.generatedLine; ) p.add(f()), x++;
      if (m < b.generatedColumn) {
        var w = d[g] || "";
        p.add(w.substr(0, b.generatedColumn)), d[g] = w.substr(b.generatedColumn), m = b.generatedColumn;
      }
      y = b;
    }, this), g < d.length && (y && v(y, f()), p.add(d.splice(g).join(""))), c.sources.forEach(function(b) {
      var E = c.sourceContentFor(b);
      E != null && (l != null && (b = t.join(l, b)), p.setSourceContent(b, E));
    }), p;
    function v(b, E) {
      if (b === null || b.source === void 0) p.add(E);
      else {
        var w = l ? t.join(l, b.source) : b.source;
        p.add(new i(b.originalLine, b.originalColumn, w, E, b.name));
      }
    }
  }, i.prototype.add = function(o) {
    if (Array.isArray(o)) o.forEach(function(c) {
      this.add(c);
    }, this);
    else {
      if (!o[n] && typeof o != "string") throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o);
      o && this.children.push(o);
    }
    return this;
  }, i.prototype.prepend = function(o) {
    if (Array.isArray(o)) for (var c = o.length - 1; c >= 0; c--) this.prepend(o[c]);
    else {
      if (!o[n] && typeof o != "string") throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o);
      this.children.unshift(o);
    }
    return this;
  }, i.prototype.walk = function(o) {
    for (var c, l = 0, p = this.children.length; l < p; l++) (c = this.children[l])[n] ? c.walk(o) : c !== "" && o(c, { source: this.source, line: this.line, column: this.column, name: this.name });
  }, i.prototype.join = function(o) {
    var c, l, p = this.children.length;
    if (p > 0) {
      for (c = [], l = 0; l < p - 1; l++) c.push(this.children[l]), c.push(o);
      c.push(this.children[l]), this.children = c;
    }
    return this;
  }, i.prototype.replaceRight = function(o, c) {
    var l = this.children[this.children.length - 1];
    return l[n] ? l.replaceRight(o, c) : typeof l == "string" ? this.children[this.children.length - 1] = l.replace(o, c) : this.children.push("".replace(o, c)), this;
  }, i.prototype.setSourceContent = function(o, c) {
    this.sourceContents[t.toSetString(o)] = c;
  }, i.prototype.walkSourceContents = function(o) {
    for (var c = 0, l = this.children.length; c < l; c++) this.children[c][n] && this.children[c].walkSourceContents(o);
    var p = Object.keys(this.sourceContents);
    for (c = 0, l = p.length; c < l; c++) o(t.fromSetString(p[c]), this.sourceContents[p[c]]);
  }, i.prototype.toString = function() {
    var o = "";
    return this.walk(function(c) {
      o += c;
    }), o;
  }, i.prototype.toStringWithSourceMap = function(o) {
    var c = { code: "", line: 1, column: 0 }, l = new e(o), p = !1, d = null, g = null, f = null, x = null;
    return this.walk(function(m, y) {
      c.code += m, y.source !== null && y.line !== null && y.column !== null ? (d === y.source && g === y.line && f === y.column && x === y.name || l.addMapping({ source: y.source, original: { line: y.line, column: y.column }, generated: { line: c.line, column: c.column }, name: y.name }), d = y.source, g = y.line, f = y.column, x = y.name, p = !0) : p && (l.addMapping({ generated: { line: c.line, column: c.column } }), d = null, p = !1);
      for (var v = 0, b = m.length; v < b; v++) m.charCodeAt(v) === 10 ? (c.line++, c.column = 0, v + 1 === b ? (d = null, p = !1) : p && l.addMapping({ source: y.source, original: { line: y.line, column: y.column }, generated: { line: c.line, column: c.column }, name: y.name })) : c.column++;
    }), this.walkSourceContents(function(m, y) {
      l.setSourceContent(m, y);
    }), { code: c.code, map: l };
  }, mc.SourceNode = i, mc;
}
function wa() {
  return A1 || (A1 = 1, Di.SourceMapGenerator = wy().SourceMapGenerator, Di.SourceMapConsumer = Pv().SourceMapConsumer, Di.SourceNode = Av().SourceNode), Di;
}
var vs = wa();
const Bi = "/*@__PURE__*/", Ui = (e) => `${Mt[e]}: _${Mt[e]}`;
function C1(e, { mode: t = "function", prefixIdentifiers: s = t === "module", sourceMap: n = !1, filename: i = "template.vue.html", scopeId: o = null, optimizeImports: c = !1, runtimeGlobalName: l = "Vue", runtimeModuleName: p = "vue", ssrRuntimeModuleName: d = "vue/server-renderer", ssr: g = !1, isTS: f = !1, inSSR: x = !1 }) {
  const m = { mode: t, prefixIdentifiers: s, sourceMap: n, filename: i, scopeId: o, optimizeImports: c, runtimeGlobalName: l, runtimeModuleName: p, ssrRuntimeModuleName: d, ssr: g, isTS: f, inSSR: x, source: e.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: !1, map: void 0, helper: (b) => `_${Mt[b]}`, push(b, E = -2, w) {
    if (m.code += b, m.map) {
      if (w) {
        let C;
        if (w.type === 4 && !w.isStatic) {
          const A = w.content.replace(/^_ctx\./, "");
          A !== w.content && Lr(A) && (C = A);
        }
        w.loc.source && v(w.loc.start, C);
      }
      E === -3 ? sh(m, b) : (m.offset += b.length, E === -2 ? m.column += b.length : (E === -1 && (E = b.length - 1), m.line++, m.column = b.length - E)), w && w.loc !== tt && w.loc.source && v(w.loc.end);
    }
  }, indent() {
    y(++m.indentLevel);
  }, deindent(b = !1) {
    b ? --m.indentLevel : y(--m.indentLevel);
  }, newline() {
    y(m.indentLevel);
  } };
  function y(b) {
    m.push(`
` + "  ".repeat(b), 0);
  }
  function v(b, E = null) {
    const { _names: w, _mappings: C } = m.map;
    E === null || w.has(E) || w.add(E), C.add({ originalLine: b.line, originalColumn: b.column - 1, generatedLine: m.line, generatedColumn: m.column - 1, source: i, name: E });
  }
  return n && (m.map = new vs.SourceMapGenerator(), m.map.setSourceContent(i, m.source), m.map._sources.add(i)), m;
}
function oh(e, t = {}) {
  const s = C1(e, t);
  t.onContextCreated && t.onContextCreated(s);
  const { mode: n, push: i, prefixIdentifiers: o, indent: c, deindent: l, newline: p, scopeId: d, ssr: g } = s, f = Array.from(e.helpers), x = f.length > 0, m = !o && n !== "module", y = !!t.inline, v = y ? C1(e, t) : s;
  n === "module" ? (function(C, A, O, D) {
    const { push: N, newline: j, optimizeImports: U, runtimeModuleName: X, ssrRuntimeModuleName: W } = A;
    if (C.helpers.size) {
      const H = Array.from(C.helpers);
      U ? (N(`import { ${H.map((F) => Mt[F]).join(", ")} } from ${JSON.stringify(X)}
`, -1), N(`
// Binding optimization for webpack code-split
const ${H.map((F) => `_${Mt[F]} = ${Mt[F]}`).join(", ")}
`, -1)) : N(`import { ${H.map((F) => `${Mt[F]} as _${Mt[F]}`).join(", ")} } from ${JSON.stringify(X)}
`, -1);
    }
    C.ssrHelpers && C.ssrHelpers.length && N(`import { ${C.ssrHelpers.map((H) => `${Mt[H]} as _${Mt[H]}`).join(", ")} } from "${W}"
`, -1), C.imports.length && ((function(H, F) {
      H.length && H.forEach((q) => {
        F.push("import "), Qe(q.exp, F), F.push(` from '${q.path}'`), F.newline();
      });
    })(C.imports, A), j()), N1(C.hoists, A), j(), D || N("export ");
  })(e, v, 0, y) : (function(C, A) {
    const { ssr: O, prefixIdentifiers: D, push: N, newline: j, runtimeModuleName: U, runtimeGlobalName: X, ssrRuntimeModuleName: W } = A, H = O ? `require(${JSON.stringify(U)})` : X, F = Array.from(C.helpers);
    F.length > 0 && (D ? N(`const { ${F.map(Ui).join(", ")} } = ${H}
`, -1) : (N(`const _Vue = ${H}
`, -1), C.hoists.length && N(`const { ${[gi, oa, fn, aa, ca].filter((q) => F.includes(q)).map(Ui).join(", ")} } = _Vue
`, -1))), C.ssrHelpers && C.ssrHelpers.length && N(`const { ${C.ssrHelpers.map(Ui).join(", ")} } = require("${W}")
`, -1), N1(C.hoists, A), j(), N("return ");
  })(e, v);
  const b = g ? "ssrRender" : "render", E = g ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  t.bindingMetadata && !t.inline && E.push("$props", "$setup", "$data", "$options");
  const w = t.isTS ? E.map((C) => `${C}: any`).join(",") : E.join(", ");
  if (i(y ? `(${w}) => {` : `function ${b}(${w}) {`), c(), m && (i("with (_ctx) {"), c(), x && (i(`const { ${f.map(Ui).join(", ")} } = _Vue
`, -1), p())), e.components.length && (I1(e.components, "component", s), (e.directives.length || e.temps > 0) && p()), e.directives.length && (I1(e.directives, "directive", s), e.temps > 0 && p()), e.temps > 0) {
    i("let ");
    for (let C = 0; C < e.temps; C++) i(`${C > 0 ? ", " : ""}_temp${C}`);
  }
  return (e.components.length || e.directives.length || e.temps) && (i(`
`, 0), p()), g || i("return "), e.codegenNode ? Qe(e.codegenNode, s) : i("null"), m && (l(), i("}")), l(), i("}"), { ast: e, code: s.code, preamble: y ? v.code : "", map: s.map ? s.map.toJSON() : void 0 };
}
function I1(e, t, { helper: s, push: n, newline: i, isTS: o }) {
  const c = s(t === "component" ? Zn : la);
  for (let l = 0; l < e.length; l++) {
    let p = e[l];
    const d = p.endsWith("__self");
    d && (p = p.slice(0, -6)), n(`const ${ni(p, t)} = ${c}(${JSON.stringify(p)}${d ? ", true" : ""})${o ? "!" : ""}`), l < e.length - 1 && i();
  }
}
function N1(e, t) {
  if (!e.length) return;
  t.pure = !0;
  const { push: s, newline: n } = t;
  n();
  for (let i = 0; i < e.length; i++) {
    const o = e[i];
    o && (s(`const _hoisted_${i + 1} = `), Qe(o, t), n());
  }
  t.pure = !1;
}
function lo(e, t) {
  const s = e.length > 3 || e.some((n) => gt(n) || !(function(i) {
    return De(i) || i.type === 4 || i.type === 2 || i.type === 5 || i.type === 8;
  })(n));
  t.push("["), s && t.indent(), Hs(e, t, s), s && t.deindent(), t.push("]");
}
function Hs(e, t, s = !1, n = !0) {
  const { push: i, newline: o } = t;
  for (let c = 0; c < e.length; c++) {
    const l = e[c];
    De(l) ? i(l, -3) : gt(l) ? lo(l, t) : Qe(l, t), c < e.length - 1 && (s ? (n && i(","), o()) : n && i(", "));
  }
}
function Qe(e, t) {
  if (De(e)) t.push(e, -3);
  else if (rs(e)) t.push(t.helper(e));
  else switch (e.type) {
    case 1:
    case 9:
    case 11:
      Xl(e.codegenNode != null, "Codegen node is missing for element/if/for node. Apply appropriate transforms first."), Qe(e.codegenNode, t);
      break;
    case 2:
      (function(s, n) {
        n.push(JSON.stringify(s.content), -3, s);
      })(e, t);
      break;
    case 4:
      O1(e, t);
      break;
    case 5:
      (function(s, n) {
        const { push: i, helper: o, pure: c } = n;
        c && i(Bi), i(`${o(xi)}(`), Qe(s.content, n), i(")");
      })(e, t);
      break;
    case 12:
      Qe(e.codegenNode, t);
      break;
    case 8:
      _y(e, t);
      break;
    case 3:
      (function(s, n) {
        const { push: i, helper: o, pure: c } = n;
        c && i(Bi), i(`${o(fn)}(${JSON.stringify(s.content)})`, -3, s);
      })(e, t);
      break;
    case 13:
      (function(s, n) {
        const { push: i, helper: o, pure: c } = n, { tag: l, props: p, children: d, patchFlag: g, dynamicProps: f, directives: x, isBlock: m, disableTracking: y, isComponent: v } = s;
        let b;
        if (g) if (g < 0) b = g + ` /* ${jn[g]} */`;
        else {
          const w = Object.keys(jn).map(Number).filter((C) => C > 0 && g & C).map((C) => jn[C]).join(", ");
          b = g + ` /* ${w} */`;
        }
        x && i(o(pa) + "("), m && i(`(${o(Qr)}(${y ? "true" : ""}), `), c && i(Bi);
        const E = m ? _s(n.inSSR, v) : ws(n.inSSR, v);
        i(o(E) + "(", -2, s), Hs((function(w) {
          let C = w.length;
          for (; C-- && w[C] == null; ) ;
          return w.slice(0, C + 1).map((A) => A || "null");
        })([l, p, d, b, f]), n), i(")"), m && i(")"), x && (i(", "), Qe(x, n), i(")"));
      })(e, t);
      break;
    case 14:
      (function(s, n) {
        const { push: i, helper: o, pure: c } = n, l = De(s.callee) ? s.callee : o(s.callee);
        c && i(Bi), i(l + "(", -2, s), Hs(s.arguments, n), i(")");
      })(e, t);
      break;
    case 15:
      (function(s, n) {
        const { push: i, indent: o, deindent: c, newline: l } = n, { properties: p } = s;
        if (!p.length) return void i("{}", -2, s);
        const d = p.length > 1 || p.some((g) => g.value.type !== 4);
        i(d ? "{" : "{ "), d && o();
        for (let g = 0; g < p.length; g++) {
          const { key: f, value: x } = p[g];
          Cv(f, n), i(": "), Qe(x, n), g < p.length - 1 && (i(","), l());
        }
        d && c(), i(d ? "}" : " }");
      })(e, t);
      break;
    case 17:
      (function(s, n) {
        lo(s.elements, n);
      })(e, t);
      break;
    case 18:
      (function(s, n) {
        const { push: i, indent: o, deindent: c } = n, { params: l, returns: p, body: d, newline: g, isSlot: f } = s;
        f && i(`_${Mt[ma]}(`), i("(", -2, s), gt(l) ? Hs(l, n) : l && Qe(l, n), i(") => "), (g || d) && (i("{"), o()), p ? (g && i("return "), gt(p) ? lo(p, n) : Qe(p, n)) : d && Qe(d, n), (g || d) && (c(), i("}")), f && i(")");
      })(e, t);
      break;
    case 19:
      (function(s, n) {
        const { test: i, consequent: o, alternate: c, newline: l } = s, { push: p, indent: d, deindent: g, newline: f } = n;
        if (i.type === 4) {
          const m = !Lr(i.content);
          m && p("("), O1(i, n), m && p(")");
        } else p("("), Qe(i, n), p(")");
        l && d(), n.indentLevel++, l || p(" "), p("? "), Qe(o, n), n.indentLevel--, l && f(), l || p(" "), p(": ");
        const x = c.type === 19;
        x || n.indentLevel++, Qe(c, n), x || n.indentLevel--, l && g(!0);
      })(e, t);
      break;
    case 20:
      (function(s, n) {
        const { push: i, helper: o, indent: c, deindent: l, newline: p } = n, { needPauseTracking: d, needArraySpread: g } = s;
        g && i("[...("), i(`_cache[${s.index}] || (`), d && (c(), i(`${o(ei)}(-1`), s.inVOnce && i(", true"), i("),"), p(), i("(")), i(`_cache[${s.index}] = `), Qe(s.value, n), d && (i(`).cacheIndex = ${s.index},`), p(), i(`${o(ei)}(1),`), p(), i(`_cache[${s.index}]`), l()), i(")"), g && i(")]");
      })(e, t);
      break;
    case 21:
      Hs(e.body, t, !0, !1);
      break;
    case 22:
      (function(s, n) {
        const { push: i, indent: o, deindent: c } = n;
        i("`");
        const l = s.elements.length, p = l > 3;
        for (let d = 0; d < l; d++) {
          const g = s.elements[d];
          De(g) ? i(g.replace(/(`|\$|\\)/g, "\\$1"), -3) : (i("${"), p && o(), Qe(g, n), p && c(), i("}"));
        }
        i("`");
      })(e, t);
      break;
    case 23:
      Py(e, t);
      break;
    case 24:
      (function(s, n) {
        Qe(s.left, n), n.push(" = "), Qe(s.right, n);
      })(e, t);
      break;
    case 25:
      (function(s, n) {
        n.push("("), Hs(s.expressions, n), n.push(")");
      })(e, t);
      break;
    case 26:
      (function({ returns: s }, n) {
        n.push("return "), gt(s) ? lo(s, n) : Qe(s, n);
      })(e, t);
      break;
    case 10:
      break;
    default:
      return Xl(!1, `unhandled codegen node type: ${e.type}`), e;
  }
}
function O1(e, t) {
  const { content: s, isStatic: n } = e;
  t.push(n ? JSON.stringify(s) : s, -3, e);
}
function _y(e, t) {
  for (let s = 0; s < e.children.length; s++) {
    const n = e.children[s];
    De(n) ? t.push(n, -3) : Qe(n, t);
  }
}
function Cv(e, t) {
  const { push: s } = t;
  e.type === 8 ? (s("["), _y(e, t), s("]")) : e.isStatic ? s(Lr(e.content) ? e.content : JSON.stringify(e.content), -2, e) : s(`[${e.content}]`, -3, e);
}
function Py(e, t) {
  const { push: s, indent: n, deindent: i } = t, { test: o, consequent: c, alternate: l } = e;
  s("if ("), Qe(o, t), s(") {"), n(), Qe(c, t), i(), s("}"), l && (s(" else "), l.type === 23 ? Py(l, t) : (s("{"), n(), Qe(l, t), i(), s("}")));
}
const Iv = kt("true,false,null,this"), ah = (e, t) => {
  if (e.type === 5) e.content = yt(e.content, t);
  else if (e.type === 1) {
    const s = rt(e, "memo");
    for (let n = 0; n < e.props.length; n++) {
      const i = e.props[n];
      if (i.type === 7 && i.name !== "for") {
        const o = i.exp, c = i.arg;
        !o || o.type !== 4 || i.name === "on" && c || s && c && c.type === 4 && c.content === "key" || (i.exp = yt(o, t, i.name === "slot")), c && c.type === 4 && !c.isStatic && (i.arg = yt(c, t));
      }
    }
  }
};
function yt(e, t, s = !1, n = !1, i = Object.create(t.identifiers)) {
  if (!t.prefixIdentifiers || !e.content.trim()) return e;
  const { inline: o, bindingMetadata: c } = t, l = (v, b, E) => {
    const w = Bp(c, v) && c[v];
    if (o) {
      const C = b && b.type === "AssignmentExpression" && b.left === E, A = b && b.type === "UpdateExpression" && b.argument === E, O = b && ri(b, f), D = b && ny(f), N = (j) => {
        const U = `${t.helperString(nn)}(${j})`;
        return D ? `(${U})` : U;
      };
      if (L1(w) || w === "setup-reactive-const" || i[v]) return v;
      if (w === "setup-ref") return `${v}.value`;
      if (w === "setup-maybe-ref") return C || A || O ? `${v}.value` : N(v);
      if (w === "setup-let") {
        if (C) {
          const { right: j, operator: U } = b, X = _a(yt(ue(p.slice(j.start - 1, j.end - 1), !1), t, !1, !1, x));
          return `${t.helperString(ti)}(${v})${t.isTS ? ` //@ts-ignore
` : ""} ? ${v}.value ${U} ${X} : ${v}`;
        }
        if (A) {
          E.start = b.start, E.end = b.end;
          const { prefix: j, operator: U } = b, X = j ? U : "", W = j ? "" : U;
          return `${t.helperString(ti)}(${v})${t.isTS ? ` //@ts-ignore
` : ""} ? ${X}${v}.value${W} : ${X}${v}${W}`;
        }
        return O ? v : N(v);
      }
      if (w === "props") return So(v);
      if (w === "props-aliased") return So(c.__propsAliases[v]);
    } else {
      if (w && w.startsWith("setup") || w === "literal-const") return `$setup.${v}`;
      if (w === "props-aliased") return `$props['${c.__propsAliases[v]}']`;
      if (w) return `$${w}.${v}`;
    }
    return `_ctx.${v}`;
  }, p = e.content;
  let d = e.ast;
  if (d === !1) return e;
  if (d === null || !d && Lr(p)) {
    const v = t.identifiers[p], b = a1(p), E = Iv(p);
    return s || v || E || b && !c[p] ? v || (e.constType = E ? 3 : 2) : (L1(c[p]) && (e.constType = 1), e.content = l(p)), e;
  }
  if (!d) {
    const v = n ? ` ${p} ` : `(${p})${s ? "=>{}" : ""}`;
    try {
      d = ar.parseExpression(v, { sourceType: "module", plugins: t.expressionPlugins });
    } catch (b) {
      return t.onError($e(45, e.loc, void 0, b.message)), e;
    }
  }
  const g = [], f = [], x = Object.create(t.identifiers);
  Ta(d, (v, b, E, w, C) => {
    if (cy(v, b)) return;
    const A = w && (function(O) {
      return !(a1(O.name) || O.name === "require");
    })(v);
    A && !C ? (va(b) && b.shorthand && (v.prefix = `${v.name}: `), v.name = l(v.name, b, v), g.push(v)) : (A && C || b && (b.type === "CallExpression" || b.type === "NewExpression" || b.type === "MemberExpression") || (v.isConstant = !0), g.push(v));
  }, !0, f, x);
  const m = [];
  let y;
  return g.sort((v, b) => v.start - b.start), g.forEach((v, b) => {
    const E = v.start - 1, w = v.end - 1, C = g[b - 1], A = p.slice(C ? C.end - 1 : 0, E);
    (A.length || v.prefix) && m.push(A + (v.prefix || ""));
    const O = p.slice(E, w);
    m.push(ue(v.name, !1, { start: Gl(e.loc.start, O, E), end: Gl(e.loc.start, O, w), source: O }, v.isConstant ? 3 : 0)), b === g.length - 1 && w < p.length && m.push(p.slice(w));
  }), m.length ? (y = dt(m, e.loc), y.ast = d) : (y = e, y.constType = 3), y.identifiers = Object.keys(x), y;
}
function _a(e) {
  return De(e) ? e : e.type === 4 ? e.content : e.children.map(_a).join("");
}
function L1(e) {
  return e === "setup-const" || e === "literal-const";
}
const Nv = vi(/^(?:if|else|else-if)$/, (e, t, s) => ch(e, t, s, (n, i, o) => {
  const c = s.parent.children;
  let l = c.indexOf(n), p = 0;
  for (; l-- >= 0; ) {
    const d = c[l];
    d && d.type === 9 && (p += d.branches.length);
  }
  return () => {
    if (o) n.codegenNode = M1(i, p, s);
    else {
      const d = (function(g) {
        for (; ; ) if (g.type === 19) {
          if (g.alternate.type !== 19) return g;
          g = g.alternate;
        } else g.type === 20 && (g = g.value);
      })(n.codegenNode);
      d.alternate = M1(i, p + n.branches.length - 1, s);
    }
  };
}));
function ch(e, t, s, n) {
  if (!(t.name === "else" || t.exp && t.exp.content.trim())) {
    const o = t.exp ? t.exp.loc : e.loc;
    s.onError($e(28, t.loc)), t.exp = ue("true", !1, o);
  }
  if (s.prefixIdentifiers && t.exp && (t.exp = yt(t.exp, s)), t.name === "if") {
    const o = R1(e, t), c = { type: 9, loc: (i = e.loc, ot(i.start.offset, i.end.offset)), branches: [o] };
    if (s.replaceNode(c), n) return n(c, o, !0);
  } else {
    const o = s.parent.children, c = [];
    let l = o.indexOf(e);
    for (; l-- >= -1; ) {
      const p = o[l];
      if (p && p.type === 3) s.removeNode(p), c.unshift(p);
      else {
        if (!p || p.type !== 2 || p.content.trim().length) {
          if (p && p.type === 9) {
            t.name !== "else-if" && t.name !== "else" || p.branches[p.branches.length - 1].condition !== void 0 || s.onError($e(30, e.loc)), s.removeNode();
            const d = R1(e, t);
            c.length && (!s.parent || s.parent.type !== 1 || s.parent.tag !== "transition" && s.parent.tag !== "Transition") && (d.children = [...c, ...d.children]);
            {
              const f = d.userKey;
              f && p.branches.forEach(({ userKey: x }) => {
                Ov(x, f) && s.onError($e(29, d.userKey.loc));
              });
            }
            p.branches.push(d);
            const g = n && n(p, d, !1);
            ln(d, s), g && g(), s.currentNode = null;
          } else s.onError($e(30, e.loc));
          break;
        }
        s.removeNode(p);
      }
    }
  }
  var i;
}
function R1(e, t) {
  const s = e.tagType === 3;
  return { type: 10, loc: e.loc, condition: t.name === "else" ? void 0 : t.exp, children: s && !rt(e, "for") ? e.children : [e], userKey: Ut(e, "key"), isTemplateIf: s };
}
function M1(e, t, s) {
  return e.condition ? or(e.condition, D1(e, t, s), we(s.helper(fn), ['"v-if"', "true"])) : D1(e, t, s);
}
function D1(e, t, s) {
  const { helper: n } = s, i = Ve("key", ue(`${t}`, !1, tt, 2)), { children: o } = e, c = o[0];
  if (o.length !== 1 || c.type !== 1) {
    if (o.length === 1 && c.type === 11) {
      const l = c.codegenNode;
      return si(l, i, s), l;
    }
    {
      let l = 64;
      return e.isTemplateIf || o.filter((p) => p.type !== 3).length !== 1 || (l |= 2048), on(s, n(rn), Ft([i]), o, l, void 0, void 0, !0, !1, !1, e.loc);
    }
  }
  {
    const l = c.codegenNode, p = dy(l);
    return p.type === 13 && ya(p, s), si(p, i, s), l;
  }
}
function Ov(e, t) {
  if (!e || e.type !== t.type) return !1;
  if (e.type === 6) {
    if (e.value.content !== t.value.content) return !1;
  } else {
    const s = e.exp, n = t.exp;
    if (s.type !== n.type || s.type !== 4 || s.isStatic !== n.isStatic || s.content !== n.content) return !1;
  }
  return !0;
}
const Lv = vi("for", (e, t, s) => {
  const { helper: n, removeHelper: i } = s;
  return lh(e, t, s, (o) => {
    const c = we(n(ha), [o.source]), l = an(e), p = rt(e, "memo"), d = Ut(e, "key", !1, !0), g = d && d.type === 7;
    let f = d && (d.type === 6 ? d.value ? ue(d.value.content, !0) : void 0 : d.exp);
    p && f && g && (d.exp = f = yt(f, s));
    const x = d && f ? Ve("key", f) : null;
    l && (p && (p.exp = yt(p.exp, s)), x && d.type !== 6 && (x.value = yt(x.value, s)));
    const m = o.source.type === 4 && o.source.constType > 0, y = m ? 64 : d ? 128 : 256;
    return o.codegenNode = on(s, n(rn), void 0, c, y, void 0, void 0, !0, !m, !1, e.loc), () => {
      let v;
      const { children: b } = o;
      l && e.children.some((C) => {
        if (C.type === 1) {
          const A = Ut(C, "key");
          if (A) return s.onError($e(33, A.loc)), !0;
        }
      });
      const E = b.length !== 1 || b[0].type !== 1, w = cn(e) ? e : l && e.children.length === 1 && cn(e.children[0]) ? e.children[0] : null;
      if (w ? (v = w.codegenNode, l && x && si(v, x, s)) : E ? v = on(s, n(rn), x ? Ft([x]) : void 0, e.children, 64, void 0, void 0, !0, void 0, !1) : (v = b[0].codegenNode, l && x && si(v, x, s), v.isBlock !== !m && (v.isBlock ? (i(Qr), i(_s(s.inSSR, v.isComponent))) : i(ws(s.inSSR, v.isComponent))), v.isBlock = !m, v.isBlock ? (n(Qr), n(_s(s.inSSR, v.isComponent))) : n(ws(s.inSSR, v.isComponent))), p) {
        const C = Wt(ii(o.parseResult, [ue("_cached")]));
        C.body = bi([dt(["const _memo = (", p.exp, ")"]), dt(["if (_cached", ...f ? [" && _cached.key === ", f] : [], ` && ${s.helperString(Wp)}(_cached, _memo)) return _cached`]), dt(["const _item = ", v]), ue("_item.memo = _memo"), ue("return _item")]), c.arguments.push(C, ue("_cache"), ue(String(s.cached.length))), s.cached.push(null);
      } else c.arguments.push(Wt(ii(o.parseResult), v, !0));
    };
  });
});
function lh(e, t, s, n) {
  if (!t.exp) return void s.onError($e(31, t.loc));
  const i = t.forParseResult;
  if (!i) return void s.onError($e(32, t.loc));
  ph(i, s);
  const { addIdentifiers: o, removeIdentifiers: c, scopes: l } = s, { source: p, value: d, key: g, index: f } = i, x = { type: 11, loc: t.loc, source: p, valueAlias: d, keyAlias: g, objectIndexAlias: f, parseResult: i, children: an(e) ? e.children : [e] };
  s.replaceNode(x), l.vFor++, s.prefixIdentifiers && (d && o(d), g && o(g), f && o(f));
  const m = n && n(x);
  return () => {
    l.vFor--, s.prefixIdentifiers && (d && c(d), g && c(g), f && c(f)), m && m();
  };
}
function ph(e, t) {
  e.finalized || (t.prefixIdentifiers && (e.source = yt(e.source, t), e.key && (e.key = yt(e.key, t, !0)), e.index && (e.index = yt(e.index, t, !0)), e.value && (e.value = yt(e.value, t, !0))), e.finalized = !0);
}
function ii({ value: e, key: t, index: s }, n = []) {
  return (function(i) {
    let o = i.length;
    for (; o-- && !i[o]; ) ;
    return i.slice(0, o + 1).map((c, l) => c || ue("_".repeat(l + 1), !1));
  })([e, t, s, ...n]);
}
const F1 = ue("undefined", !1), hh = (e, t) => {
  if (e.type === 1 && (e.tagType === 1 || e.tagType === 3)) {
    const s = rt(e, "slot");
    if (s) {
      const n = s.exp;
      return t.prefixIdentifiers && n && t.addIdentifiers(n), t.scopes.vSlot++, () => {
        t.prefixIdentifiers && n && t.removeIdentifiers(n), t.scopes.vSlot--;
      };
    }
  }
}, uh = (e, t) => {
  let s;
  if (an(e) && e.props.some(Ea) && (s = rt(e, "for"))) {
    const n = s.forParseResult;
    if (n) {
      ph(n, t);
      const { value: i, key: o, index: c } = n, { addIdentifiers: l, removeIdentifiers: p } = t;
      return i && l(i), o && l(o), c && l(c), () => {
        i && p(i), o && p(o), c && p(c);
      };
    }
  }
}, Rv = (e, t, s, n) => Wt(e, s, !1, !0, s.length ? s[0].loc : n);
function Un(e, t, s = Rv) {
  t.helper(ma);
  const { children: n, loc: i } = e, o = [], c = [];
  let l = t.scopes.vSlot > 0 || t.scopes.vFor > 0;
  !t.ssr && t.prefixIdentifiers && (l = e.props.some((b) => Ea(b) && (_t(b.arg, t.identifiers) || _t(b.exp, t.identifiers))) || n.some((b) => _t(b, t.identifiers)));
  const p = rt(e, "slot", !0);
  if (p) {
    const { arg: b, exp: E } = p;
    b && !vt(b) && (l = !0), o.push(Ve(b || ue("default", !0), s(E, void 0, n, i)));
  }
  let d = !1, g = !1;
  const f = [], x = /* @__PURE__ */ new Set();
  let m = 0;
  for (let b = 0; b < n.length; b++) {
    const E = n[b];
    let w;
    if (!an(E) || !(w = rt(E, "slot", !0))) {
      E.type !== 3 && f.push(E);
      continue;
    }
    if (p) {
      t.onError($e(37, w.loc));
      break;
    }
    d = !0;
    const { children: C, loc: A } = E, { arg: O = ue("default", !0), exp: D, loc: N } = w;
    let j;
    vt(O) ? j = O ? O.content : "default" : l = !0;
    const U = rt(E, "for"), X = s(D, U, C, A);
    let W, H;
    if (W = rt(E, "if")) l = !0, c.push(or(W.exp, $i(O, X, m++), F1));
    else if (H = rt(E, /^else(?:-if)?$/, !0)) {
      let F, q = b;
      for (; q-- && (F = n[q], F.type === 3 || !Ql(F)); ) ;
      if (F && an(F) && rt(F, /^(?:else-)?if$/)) {
        let G = c[c.length - 1];
        for (; G.alternate.type === 19; ) G = G.alternate;
        G.alternate = H.exp ? or(H.exp, $i(O, X, m++), F1) : $i(O, X, m++);
      } else t.onError($e(30, H.loc));
    } else if (U) {
      l = !0;
      const F = U.forParseResult;
      F ? (ph(F, t), c.push(we(t.helper(ha), [F.source, Wt(ii(F), $i(O, X), !0)]))) : t.onError($e(32, U.loc));
    } else {
      if (j) {
        if (x.has(j)) {
          t.onError($e(38, N));
          continue;
        }
        x.add(j), j === "default" && (g = !0);
      }
      o.push(Ve(O, X));
    }
  }
  if (!p) {
    const b = (E, w) => Ve("default", s(E, void 0, w, i));
    d ? f.length && f.some((E) => Ql(E)) && (g ? t.onError($e(39, f[0].loc)) : o.push(b(void 0, f))) : o.push(b(void 0, n));
  }
  const y = l ? 2 : po(e.children) ? 3 : 1;
  let v = Ft(o.concat(Ve("_", ue(y + ` /* ${jT[y]} */`, !1))), i);
  return c.length && (v = we(t.helper(zp), [v, Nr(c)])), { slots: v, hasDynamicSlots: l };
}
function $i(e, t, s) {
  const n = [Ve("name", e), Ve("fn", t)];
  return s != null && n.push(Ve("key", ue(String(s), !0))), Ft(n);
}
function po(e) {
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    switch (s.type) {
      case 1:
        if (s.tagType === 2 || po(s.children)) return !0;
        break;
      case 9:
        if (po(s.branches)) return !0;
        break;
      case 10:
      case 11:
        if (po(s.children)) return !0;
    }
  }
  return !1;
}
function Ql(e) {
  return e.type !== 2 && e.type !== 12 || (e.type === 2 ? !!e.content.trim() : Ql(e.content));
}
const Ay = /* @__PURE__ */ new WeakMap(), Cy = (e, t) => function() {
  if ((e = t.currentNode).type !== 1 || e.tagType !== 0 && e.tagType !== 1) return;
  const { tag: s, props: n } = e, i = e.tagType === 1;
  let o = i ? Pa(e, t) : `"${s}"`;
  const c = ss(o) && o.callee === yi;
  let l, p, d, g, f, x = 0, m = c || o === Ts || o === dn || !i && (s === "svg" || s === "foreignObject" || s === "math");
  if (n.length > 0) {
    const y = pn(e, t, void 0, i, c);
    l = y.props, x = y.patchFlag, g = y.dynamicPropNames;
    const v = y.directives;
    f = v && v.length ? Nr(v.map((b) => dh(b, t))) : void 0, y.shouldUseBlock && (m = !0);
  }
  if (e.children.length > 0)
    if (o === Qn && (m = !0, x |= 1024, e.children.length > 1 && t.onError($e(46, { start: e.children[0].loc.start, end: e.children[e.children.length - 1].loc.end, source: "" }))), i && o !== Ts && o !== Qn) {
      const { slots: y, hasDynamicSlots: v } = Un(e, t);
      p = y, v && (x |= 1024);
    } else if (e.children.length === 1 && o !== Ts) {
      const y = e.children[0], v = y.type, b = v === 5 || v === 8;
      b && jt(y, t) === 0 && (x |= 1), p = b || v === 2 ? y : e.children;
    } else p = e.children;
  g && g.length && (d = (function(y) {
    let v = "[";
    for (let b = 0, E = y.length; b < E; b++) v += JSON.stringify(y[b]), b < E - 1 && (v += ", ");
    return v + "]";
  })(g)), e.codegenNode = on(t, o, l, p, x === 0 ? void 0 : x, d, f, !!m, !1, i, e.loc);
};
function Pa(e, t, s = !1) {
  let { tag: n } = e;
  const i = ep(n), o = Ut(e, "is", !1, !0);
  if (o) if (i) {
    let l;
    if (o.type === 6 ? l = o.value && ue(o.value.content, !0) : (l = o.exp, l || (l = ue("is", !1, o.arg.loc), l = o.exp = yt(l, t))), l) return we(t.helper(yi), [l]);
  } else o.type === 6 && o.value.content.startsWith("vue:") && (n = o.value.content.slice(4));
  const c = th(n) || t.isBuiltInComponent(n);
  if (c) return s || t.helper(c), c;
  {
    const l = Zl(n, t);
    if (l) return l;
    const p = n.indexOf(".");
    if (p > 0) {
      const d = Zl(n.slice(0, p), t);
      if (d) return d + n.slice(p);
    }
  }
  return t.selfName && Yr(Dt(n)) === t.selfName ? (t.helper(Zn), t.components.add(n + "__self"), ni(n, "component")) : (t.helper(Zn), t.components.add(n), ni(n, "component"));
}
function Zl(e, t) {
  const s = t.bindingMetadata;
  if (!s || s.__isScriptSetup === !1) return;
  const n = Dt(e), i = Yr(n), o = (d) => s[e] === d ? e : s[n] === d ? n : s[i] === d ? i : void 0, c = o("setup-const") || o("setup-reactive-const") || o("literal-const");
  if (c) return t.inline ? c : `$setup[${JSON.stringify(c)}]`;
  const l = o("setup-let") || o("setup-ref") || o("setup-maybe-ref");
  if (l) return t.inline ? `${t.helperString(nn)}(${l})` : `$setup[${JSON.stringify(l)}]`;
  const p = o("props");
  return p ? `${t.helperString(nn)}(${t.inline ? "__props" : "$props"}[${JSON.stringify(p)}])` : void 0;
}
function pn(e, t, s = e.props, n, i, o = !1) {
  const { tag: c, loc: l, children: p } = e;
  let d = [];
  const g = [], f = [], x = p.length > 0;
  let m = !1, y = 0, v = !1, b = !1, E = !1, w = !1, C = !1, A = !1;
  const O = [], D = (X) => {
    d.length && (g.push(Ft(j1(d), l)), d = []), X && g.push(X);
  }, N = () => {
    t.scopes.vFor > 0 && d.push(Ve(ue("ref_for", !0), ue("true")));
  }, j = ({ key: X, value: W }) => {
    if (vt(X)) {
      const H = X.content, F = Dg(H);
      if (!F || n && !i || H.toLowerCase() === "onclick" || H === "onUpdate:modelValue" || o1(H) || (w = !0), F && o1(H) && (A = !0), F && W.type === 14 && (W = W.arguments[0]), W.type === 20 || (W.type === 4 || W.type === 8) && jt(W, t) > 0) return;
      H === "ref" ? v = !0 : H === "class" ? b = !0 : H === "style" ? E = !0 : H === "key" || O.includes(H) || O.push(H), !n || H !== "class" && H !== "style" || O.includes(H) || O.push(H);
    } else C = !0;
  };
  for (let X = 0; X < s.length; X++) {
    const W = s[X];
    if (W.type === 6) {
      const { loc: H, name: F, nameLoc: q, value: G } = W;
      let ee = !0;
      if (F === "ref" && (v = !0, N(), G && t.inline)) {
        const ce = t.bindingMetadata[G.content];
        ce !== "setup-let" && ce !== "setup-ref" && ce !== "setup-maybe-ref" || (ee = !1, d.push(Ve(ue("ref_key", !0), ue(G.content, !0, G.loc))));
      }
      if (F === "is" && (ep(c) || G && G.content.startsWith("vue:"))) continue;
      d.push(Ve(ue(F, !0, q), ue(G ? G.content : "", ee, G ? G.loc : H)));
    } else {
      const { name: H, arg: F, exp: q, loc: G, modifiers: ee } = W, ce = H === "bind", Te = H === "on";
      if (H === "slot") {
        n || t.onError($e(40, G));
        continue;
      }
      if (H === "once" || H === "memo" || H === "is" || ce && xr(F, "is") && ep(c) || Te && o) continue;
      if ((ce && xr(F, "key") || Te && x && xr(F, "vue:before-update")) && (m = !0), ce && xr(F, "ref") && N(), !F && (ce || Te)) {
        C = !0, q ? ce ? (N(), D(), g.push(q)) : D({ type: 14, loc: G, callee: t.helper(fa), arguments: n ? [q] : [q, "true"] }) : t.onError($e(ce ? 34 : 35, G));
        continue;
      }
      ce && ee.some((pe) => pe.content === "prop") && (y |= 32);
      const Q = t.directiveTransforms[H];
      if (Q) {
        const { props: pe, needRuntime: J } = Q(W, e, t);
        !o && pe.forEach(j), Te && F && !vt(F) ? D(Ft(pe, l)) : d.push(...pe), J && (f.push(W), rs(J) && Ay.set(W, J));
      } else Up(H) || (f.push(W), x && (m = !0));
    }
  }
  let U;
  if (g.length ? (D(), U = g.length > 1 ? we(t.helper(Es), g, l) : g[0]) : d.length && (U = Ft(j1(d), l)), C ? y |= 16 : (b && !n && (y |= 2), E && !n && (y |= 4), O.length && (y |= 8), w && (y |= 32)), m || y !== 0 && y !== 32 || !(v || A || f.length > 0) || (y |= 512), !t.inSSR && U) switch (U.type) {
    case 15:
      let X = -1, W = -1, H = !1;
      for (let G = 0; G < U.properties.length; G++) {
        const ee = U.properties[G].key;
        vt(ee) ? ee.content === "class" ? X = G : ee.content === "style" && (W = G) : ee.isHandlerKey || (H = !0);
      }
      const F = U.properties[X], q = U.properties[W];
      H ? U = we(t.helper(sn), [U]) : (F && !vt(F.value) && (F.value = we(t.helper(ua), [F.value])), q && (E || q.value.type === 4 && q.value.content.trim()[0] === "[" || q.value.type === 17) && (q.value = we(t.helper(da), [q.value])));
      break;
    case 14:
      break;
    default:
      U = we(t.helper(sn), [we(t.helper(mn), [U])]);
  }
  return { props: U, directives: f, patchFlag: y, dynamicPropNames: O, shouldUseBlock: m };
}
function j1(e) {
  const t = /* @__PURE__ */ new Map(), s = [];
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    if (i.key.type === 8 || !i.key.isStatic) {
      s.push(i);
      continue;
    }
    const o = i.key.content, c = t.get(o);
    c ? (o === "style" || o === "class" || Dg(o)) && Mv(c, i) : (t.set(o, i), s.push(i));
  }
  return s;
}
function Mv(e, t) {
  e.value.type === 17 ? e.value.elements.push(t.value) : e.value = Nr([e.value, t.value], e.loc);
}
function dh(e, t) {
  const s = [], n = Ay.get(e);
  if (n) s.push(t.helperString(n));
  else {
    const o = Zl("v-" + e.name, t);
    o ? s.push(o) : (t.helper(la), t.directives.add(e.name), s.push(ni(e.name, "directive")));
  }
  const { loc: i } = e;
  if (e.exp && s.push(e.exp), e.arg && (e.exp || s.push("void 0"), s.push(e.arg)), Object.keys(e.modifiers).length) {
    e.arg || (e.exp || s.push("void 0"), s.push("void 0"));
    const o = ue("true", !1, i);
    s.push(Ft(e.modifiers.map((c) => Ve(c, o)), i));
  }
  return Nr(s, e.loc);
}
function ep(e) {
  return e === "component" || e === "Component";
}
const Dv = (e, t) => {
  if (cn(e)) {
    const { children: s, loc: n } = e, { slotName: i, slotProps: o } = fh(e, t), c = [t.prefixIdentifiers ? "_ctx.$slots" : "$slots", i, "{}", "undefined", "true"];
    let l = 2;
    o && (c[2] = o, l = 3), s.length && (c[3] = Wt([], s, !1, !1, n), l = 4), t.scopeId && !t.slotted && (l = 5), c.splice(l), e.codegenNode = we(t.helper(Hp), c, n);
  }
};
function fh(e, t) {
  let s, n = '"default"';
  const i = [];
  for (let o = 0; o < e.props.length; o++) {
    const c = e.props[o];
    if (c.type === 6) c.value && (c.name === "name" ? n = JSON.stringify(c.value.content) : (c.name = Dt(c.name), i.push(c)));
    else if (c.name === "bind" && xr(c.arg, "name")) {
      if (c.exp) n = c.exp;
      else if (c.arg && c.arg.type === 4) {
        const l = Dt(c.arg.content);
        n = c.exp = ue(l, !1, c.arg.loc), n = c.exp = yt(c.exp, t);
      }
    } else c.name === "bind" && c.arg && vt(c.arg) && (c.arg.content = Dt(c.arg.content)), i.push(c);
  }
  if (i.length > 0) {
    const { props: o, directives: c } = pn(e, t, i, !1, !1);
    s = o, c.length && t.onError($e(36, c[0].loc));
  }
  return { slotName: n, slotProps: s };
}
const Aa = (e, t, s, n) => {
  const { loc: i, modifiers: o, arg: c } = e;
  let l;
  if (e.exp || o.length || s.onError($e(35, i)), c.type === 4) if (c.isStatic) {
    let f = c.content;
    f.startsWith("vnode") && s.onError($e(51, c.loc)), f.startsWith("vue:") && (f = `vnode-${f.slice(4)}`), l = ue(t.tagType !== 0 || f.startsWith("vnode") || !/[A-Z]/.test(f) ? DT(Dt(f)) : `on:${f}`, !0, c.loc);
  } else l = dt([`${s.helperString(_o)}(`, c, ")"]);
  else l = c, l.children.unshift(`${s.helperString(_o)}(`), l.children.push(")");
  let p = e.exp;
  p && !p.content.trim() && (p = void 0);
  let d = s.cacheHandlers && !p && !s.inVOnce;
  if (p) {
    const f = rh(p, s), x = !(f || hy(p, s)), m = p.content.includes(";");
    s.prefixIdentifiers && (x && s.addIdentifiers("$event"), p = e.exp = yt(p, s, !1, m), x && s.removeIdentifiers("$event"), d = s.cacheHandlers && !s.inVOnce && !(p.type === 4 && p.constType > 0) && !(f && t.tagType === 1) && !_t(p, s.identifiers), d && f && (p.type === 4 ? p.content = `${p.content} && ${p.content}(...args)` : p.children = [...p.children, " && ", ...p.children, "(...args)"])), (x || d && f) && (p = dt([`${x ? s.isTS ? "($event: any)" : "$event" : (s.isTS ? `
//@ts-ignore
` : "") + "(...args)"} => ${m ? "{" : "("}`, p, m ? "}" : ")"]));
  }
  let g = { props: [Ve(l, p || ue("() => {}", !1, i))] };
  return n && (g = n(g)), d && (g.props[0].value = s.cache(g.props[0].value)), g.props.forEach((f) => f.key.isHandlerKey = !0), g;
}, mh = (e, t, s) => {
  const { modifiers: n, loc: i } = e, o = e.arg;
  let { exp: c } = e;
  return c && c.type === 4 && !c.content.trim() ? (s.onError($e(34, i)), { props: [Ve(o, ue("", !0, i))] }) : (o.type !== 4 ? (o.children.unshift("("), o.children.push(') || ""')) : o.isStatic || (o.content = o.content ? `${o.content} || ""` : '""'), n.some((l) => l.content === "camel") && (o.type === 4 ? o.isStatic ? o.content = Dt(o.content) : o.content = `${s.helperString(wo)}(${o.content})` : (o.children.unshift(`${s.helperString(wo)}(`), o.children.push(")"))), s.inSSR || (n.some((l) => l.content === "prop") && B1(o, "."), n.some((l) => l.content === "attr") && B1(o, "^")), { props: [Ve(o, c)] });
}, B1 = (e, t) => {
  e.type === 4 ? e.isStatic ? e.content = t + e.content : e.content = `\`${t}\${${e.content}}\`` : (e.children.unshift(`'${t}' + (`), e.children.push(")"));
}, Fv = (e, t) => {
  if (e.type === 0 || e.type === 1 || e.type === 11 || e.type === 10) return () => {
    const s = e.children;
    let n, i = !1;
    for (let o = 0; o < s.length; o++) {
      const c = s[o];
      if (Bn(c)) {
        i = !0;
        for (let l = o + 1; l < s.length; l++) {
          const p = s[l];
          if (!Bn(p)) {
            n = void 0;
            break;
          }
          n || (n = s[o] = dt([c], c.loc)), n.children.push(" + ", p), s.splice(l, 1), l--;
        }
      }
    }
    if (i && (s.length !== 1 || e.type !== 0 && (e.type !== 1 || e.tagType !== 0 || e.props.find((o) => o.type === 7 && !t.directiveTransforms[o.name])))) for (let o = 0; o < s.length; o++) {
      const c = s[o];
      if (Bn(c) || c.type === 8) {
        const l = [];
        c.type === 2 && c.content === " " || l.push(c), t.ssr || jt(c, t) !== 0 || l.push(`1 /* ${jn[1]} */`), s[o] = { type: 12, content: c, loc: c.loc, codegenNode: we(t.helper(aa), l) };
      }
    }
  };
}, U1 = /* @__PURE__ */ new WeakSet(), jv = (e, t) => {
  if (e.type === 1 && rt(e, "once", !0))
    return U1.has(e) || t.inVOnce || t.inSSR ? void 0 : (U1.add(e), t.inVOnce = !0, t.helper(ei), () => {
      t.inVOnce = !1;
      const s = t.currentNode;
      s.codegenNode && (s.codegenNode = t.cache(s.codegenNode, !0, !0));
    });
}, Ca = (e, t, s) => {
  const { exp: n, arg: i } = e;
  if (!n) return s.onError($e(41, e.loc)), Pn();
  const o = n.loc.source.trim(), c = n.type === 4 ? n.content : o, l = s.bindingMetadata[o];
  if (l === "props" || l === "props-aliased") return s.onError($e(44, n.loc)), Pn();
  const p = s.inline && (l === "setup-let" || l === "setup-ref" || l === "setup-maybe-ref");
  if (!c.trim() || !rh(n, s) && !p) return s.onError($e(42, n.loc)), Pn();
  if (s.prefixIdentifiers && Lr(c) && s.identifiers[c]) return s.onError($e(43, n.loc)), Pn();
  const d = i || ue("modelValue", !0), g = i ? vt(i) ? `onUpdate:${Dt(i.content)}` : dt(['"onUpdate:" + ', i]) : "onUpdate:modelValue";
  let f;
  const x = s.isTS ? "($event: any)" : "$event";
  if (p) if (l === "setup-ref") f = dt([`${x} => ((`, ue(o, !1, n.loc), ").value = $event)"]);
  else {
    const y = l === "setup-let" ? `${o} = $event` : "null";
    f = dt([`${x} => (${s.helperString(ti)}(${o}) ? (`, ue(o, !1, n.loc), `).value = $event : ${y})`]);
  }
  else f = dt([`${x} => ((`, n, ") = $event)"]);
  const m = [Ve(d, e.exp), Ve(g, f)];
  if (s.prefixIdentifiers && !s.inVOnce && s.cacheHandlers && !_t(n, s.identifiers) && (m[1].value = s.cache(m[1].value)), e.modifiers.length && t.tagType === 1) {
    const y = e.modifiers.map((b) => b.content).map((b) => (Lr(b) ? b : JSON.stringify(b)) + ": true").join(", "), v = i ? vt(i) ? `${i.content}Modifiers` : dt([i, ' + "Modifiers"']) : "modelModifiers";
    m.push(Ve(v, ue(`{ ${y} }`, !1, e.loc, 2)));
  }
  return Pn(m);
};
function Pn(e = []) {
  return { props: e };
}
const $1 = /* @__PURE__ */ new WeakSet(), Bv = (e, t) => {
  if (e.type === 1) {
    const s = rt(e, "memo");
    return !s || $1.has(e) || t.inSSR ? void 0 : ($1.add(e), () => {
      const n = e.codegenNode || t.currentNode.codegenNode;
      n && n.type === 13 && (e.tagType !== 1 && ya(n, t), e.codegenNode = we(t.helper(ga), [s.exp, Wt(void 0, n), "_cache", String(t.cached.length)]), t.cached.push(null));
    });
  }
}, gh = (e, t) => {
  if (e.type === 1) {
    for (const s of e.props) if (s.type === 7 && s.name === "bind" && !s.exp) {
      const n = s.arg;
      if (n.type === 4 && n.isStatic) {
        const i = Dt(n.content);
        (Wl.test(i[0]) || i[0] === "-") && (s.exp = ue(i, !1, n.loc));
      } else t.onError($e(52, n.loc)), s.exp = ue("", !0, n.loc);
    }
  }
};
function yh(e) {
  return [[gh, jv, Nv, Bv, Lv, ...e ? [uh, ah] : [], Dv, Cy, hh, Fv], { on: Aa, bind: mh, model: Ca }];
}
function q1(e, t = {}) {
  const s = t.onError || Kp, n = t.mode === "module", i = t.prefixIdentifiers === !0 || n;
  !i && t.cacheHandlers && s($e(49)), t.scopeId && !n && s($e(50));
  const o = kr({}, t, { prefixIdentifiers: i }), c = De(e) ? Oo(e, o) : e, [l, p] = yh(i);
  if (t.isTS) {
    const { expressionPlugins: d } = t;
    d && d.includes("typescript") || (t.expressionPlugins = [...d || [], "typescript"]);
  }
  return ih(c, kr({}, o, { nodeTransforms: [...l, ...t.nodeTransforms || []], directiveTransforms: kr({}, p, t.directiveTransforms || {}) })), oh(c, o);
}
const $n = () => ({ props: [] }), xh = Symbol("vModelRadio"), bh = Symbol("vModelCheckbox"), Th = Symbol("vModelText"), vh = Symbol("vModelSelect"), Lo = Symbol("vModelDynamic"), kh = Symbol("vOnModifiersGuard"), Sh = Symbol("vOnKeysGuard"), Eh = Symbol("vShow"), Os = Symbol("Transition"), gn = Symbol("TransitionGroup");
Gp({ [xh]: "vModelRadio", [bh]: "vModelCheckbox", [Th]: "vModelText", [vh]: "vModelSelect", [Lo]: "vModelDynamic", [kh]: "withModifiers", [Sh]: "withKeys", [Eh]: "vShow", [Os]: "Transition", [gn]: "TransitionGroup" });
const Js = { parseMode: "html", isVoidTag: Vg, isNativeTag: (e) => VT(e) || HT(e) || zT(e), isPreTag: (e) => e === "pre", isIgnoreNewlineTag: (e) => e === "pre" || e === "textarea", decodeEntities: void 0, isBuiltInComponent: (e) => e === "Transition" || e === "transition" ? Os : e === "TransitionGroup" || e === "transition-group" ? gn : void 0, getNamespace(e, t, s) {
  let n = t ? t.ns : s;
  if (t && n === 2) if (t.tag === "annotation-xml") {
    if (e === "svg") return 1;
    t.props.some((i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")) && (n = 0);
  } else /^m(?:[ions]|text)$/.test(t.tag) && e !== "mglyph" && e !== "malignmark" && (n = 0);
  else t && n === 1 && (t.tag !== "foreignObject" && t.tag !== "desc" && t.tag !== "title" || (n = 0));
  if (n === 0) {
    if (e === "svg") return 1;
    if (e === "math") return 2;
  }
  return n;
} }, wh = (e) => {
  e.type === 1 && e.props.forEach((t, s) => {
    t.type === 6 && t.name === "style" && t.value && (e.props[s] = { type: 7, name: "bind", arg: ue("style", !0, t.loc), exp: Uv(t.value.content, t.loc), modifiers: [], loc: t.loc });
  });
}, Uv = (e, t) => {
  const s = $g(e);
  return ue(JSON.stringify(s), !1, t, 3);
};
function At(e, t) {
  return $e(e, t, _h);
}
const _h = { 53: "v-html is missing expression.", 54: "v-html will override element children.", 55: "v-text is missing expression.", 56: "v-text will override element children.", 57: "v-model can only be used on <input>, <textarea> and <select> elements.", 58: "v-model argument is not supported on plain elements.", 59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 61: "v-show is missing expression.", 62: "<Transition> expects exactly one child element or component.", 63: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, $v = kt("passive,once,capture"), qv = kt("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), Vv = kt("left,right"), V1 = kt("onkeyup,onkeydown,onkeypress"), H1 = (e, t) => vt(e) && e.content.toLowerCase() === "onclick" ? ue(t, !0) : e.type !== 4 ? dt(["(", e, `) === "onClick" ? "${t}" : (`, e, ")"]) : e;
function Iy(e) {
  const t = e.children = e.children.filter((n) => n.type !== 3 && !(n.type === 2 && !n.content.trim())), s = t[0];
  return t.length !== 1 || s.type === 11 || s.type === 9 && s.branches.some(Iy);
}
const Hv = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, zv = (e, t, s) => {
  if (t.scopes.vSlot > 0) return;
  const n = s.type === 1 && s.codegenNode && s.codegenNode.type === 13 && s.codegenNode.children && !gt(s.codegenNode.children) && s.codegenNode.children.type === 20;
  let i = 0, o = 0;
  const c = [], l = (d) => {
    if (i >= 20 || o >= 5) {
      const g = we(t.helper(ca), [JSON.stringify(c.map((x) => tp(x, t)).join("")).replace(Hv, '" + $1 + "'), String(c.length)]), f = c.length - 1;
      if (n) e.splice(d - c.length, c.length, g);
      else if (c[0].codegenNode.value = g, c.length > 1) {
        e.splice(d - c.length + 1, f);
        const x = t.cached.indexOf(c[c.length - 1].codegenNode);
        if (x > -1) {
          for (let m = x; m < t.cached.length; m++) {
            const y = t.cached[m];
            y && (y.index -= f);
          }
          t.cached.splice(x - f + 1, f);
        }
      }
      return f;
    }
    return 0;
  };
  let p = 0;
  for (; p < e.length; p++) {
    const d = e[p];
    if (n || Wv(d)) {
      const g = Kv(d);
      if (g) {
        i += g[0], o += g[1], c.push(d);
        continue;
      }
    }
    p -= l(p), i = 0, o = 0, c.length = 0;
  }
  l(p);
}, Wv = (e) => {
  if ((e.type === 1 && e.tagType === 0 || e.type === 12) && e.codegenNode && e.codegenNode.type === 20) return e.codegenNode;
}, Gv = /^(?:data|aria)-/, z1 = (e, t) => (t === 0 ? KT(e) : t === 1 ? JT(e) : t === 2 && YT(e)) || Gv.test(e), Xv = kt("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
function Kv(e) {
  if (e.type === 1 && Xv(e.tag) || e.type === 1 && rt(e, "once", !0)) return !1;
  if (e.type === 12) return [1, 0];
  let t = 1, s = e.props.length > 0 ? 1 : 0, n = !1;
  const i = () => (n = !0, !1);
  return !!(function o(c) {
    const l = c.tag === "option" && c.ns === 0;
    for (let p = 0; p < c.props.length; p++) {
      const d = c.props[p];
      if (d.type === 6 && !z1(d.name, c.ns) || d.type === 7 && d.name === "bind" && (d.arg && (d.arg.type === 8 || d.arg.isStatic && !z1(d.arg.content, c.ns)) || d.exp && (d.exp.type === 8 || d.exp.constType < 3) || l && xr(d.arg, "value") && d.exp && !d.exp.isStatic))
        return i();
    }
    for (let p = 0; p < c.children.length; p++) {
      t++;
      const d = c.children[p];
      if (d.type === 1 && (d.props.length > 0 && s++, o(d), n)) return !1;
    }
    return !0;
  })(e) && [t, s];
}
function tp(e, t) {
  if (De(e)) return e;
  if (rs(e)) return "";
  switch (e.type) {
    case 1:
      return (function(s, n) {
        let i = `<${s.tag}`, o = "";
        for (let c = 0; c < s.props.length; c++) {
          const l = s.props[c];
          if (l.type === 6) i += ` ${l.name}`, l.value && (i += `="${ur(l.value.content)}"`);
          else if (l.type === 7) if (l.name === "bind") {
            const p = l.exp;
            if (p.content[0] === "_") {
              i += ` ${l.arg.content}="__VUE_EXP_START__${p.content}__VUE_EXP_END__"`;
              continue;
            }
            if (Hg(l.arg.content) && p.content === "false") continue;
            let d = ds(p);
            if (d != null) {
              const g = l.arg && l.arg.content;
              g === "class" ? d = qg(d) : g === "style" && (d = qT(Ug(d))), i += ` ${l.arg.content}="${ur(d)}"`;
            }
          } else l.name === "html" ? o = ds(l.exp) : l.name === "text" && (o = ur(Eo(ds(l.exp))));
        }
        if (n.scopeId && (i += ` ${n.scopeId}`), i += ">", o) i += o;
        else for (let c = 0; c < s.children.length; c++) i += tp(s.children[c], n);
        return Vg(s.tag) || (i += `</${s.tag}>`), i;
      })(e, t);
    case 2:
      return ur(e.content);
    case 3:
      return `<!--${ur(e.content)}-->`;
    case 5:
      return ur(Eo(ds(e.content)));
    case 8:
      return ur(ds(e));
    case 12:
      return tp(e.content, t);
    default:
      return "";
  }
}
function ds(e) {
  if (e.type === 4) return new Function(`return (${e.content})`)();
  {
    let t = "";
    return e.children.forEach((s) => {
      De(s) || rs(s) || (s.type === 2 ? t += s.content : s.type === 5 ? t += Eo(ds(s.content)) : t += ds(s));
    }), t;
  }
}
const Jv = (e, t) => {
  e.type !== 1 || e.tagType !== 0 || e.tag !== "script" && e.tag !== "style" || (t.onError(At(63, e.loc)), t.removeNode());
}, Bs = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]), hs = /* @__PURE__ */ new Set([]), W1 = { head: /* @__PURE__ */ new Set(["base", "basefront", "bgsound", "link", "meta", "title", "noscript", "noframes", "style", "script", "template"]), optgroup: /* @__PURE__ */ new Set(["option"]), select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]), table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]), tr: /* @__PURE__ */ new Set(["td", "th"]), colgroup: /* @__PURE__ */ new Set(["col"]), tbody: /* @__PURE__ */ new Set(["tr"]), thead: /* @__PURE__ */ new Set(["tr"]), tfoot: /* @__PURE__ */ new Set(["tr"]), script: hs, iframe: hs, option: hs, textarea: hs, style: hs, title: hs }, G1 = { html: hs, body: /* @__PURE__ */ new Set(["html"]), head: /* @__PURE__ */ new Set(["html"]), td: /* @__PURE__ */ new Set(["tr"]), colgroup: /* @__PURE__ */ new Set(["table"]), caption: /* @__PURE__ */ new Set(["table"]), tbody: /* @__PURE__ */ new Set(["table"]), tfoot: /* @__PURE__ */ new Set(["table"]), col: /* @__PURE__ */ new Set(["colgroup"]), th: /* @__PURE__ */ new Set(["tr"]), thead: /* @__PURE__ */ new Set(["table"]), tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]), dd: /* @__PURE__ */ new Set(["dl", "div"]), dt: /* @__PURE__ */ new Set(["dl", "div"]), figcaption: /* @__PURE__ */ new Set(["figure"]), summary: /* @__PURE__ */ new Set(["details"]), area: /* @__PURE__ */ new Set(["map"]) }, X1 = { p: /* @__PURE__ */ new Set(["address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "main", "nav", "menu", "ol", "p", "pre", "section", "table", "ul"]), svg: /* @__PURE__ */ new Set(["b", "blockquote", "br", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "menu", "meta", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "sub", "sup", "table", "u", "ul", "var"]) }, K1 = { a: /* @__PURE__ */ new Set(["a"]), button: /* @__PURE__ */ new Set(["button"]), dd: /* @__PURE__ */ new Set(["dd", "dt"]), dt: /* @__PURE__ */ new Set(["dd", "dt"]), form: /* @__PURE__ */ new Set(["form"]), li: /* @__PURE__ */ new Set(["li"]), h1: Bs, h2: Bs, h3: Bs, h4: Bs, h5: Bs, h6: Bs }, rp = [wh, (e, t) => {
  if (e.type === 1 && e.tagType === 1 && t.isBuiltInComponent(e.tag) === Os)
    return () => {
      if (!e.children.length) return;
      Iy(e) && t.onError(At(62, { start: e.children[0].loc.start, end: e.children[e.children.length - 1].loc.end, source: "" }));
      const s = e.children[0];
      if (s.type === 1) for (const n of s.props) n.type === 7 && n.name === "show" && e.props.push({ type: 6, name: "persisted", nameLoc: e.loc, value: void 0, loc: e.loc });
    };
}, (e, t) => {
  if (e.type === 1 && e.tagType === 0 && t.parent && t.parent.type === 1 && t.parent.tagType === 0 && (s = t.parent.tag, n = e.tag, s !== "template" && (s in W1 ? !W1[s].has(n) : n in G1 ? !G1[n].has(s) : s in X1 && X1[s].has(n) || n in K1 && K1[n].has(s)))) {
    const i = new SyntaxError(`<${e.tag}> cannot be child of <${t.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`);
    i.loc = e.loc, t.onWarn(i);
  }
  var s, n;
}], sp = { cloak: $n, html: (e, t, s) => {
  const { exp: n, loc: i } = e;
  return n || s.onError(At(53, i)), t.children.length && (s.onError(At(54, i)), t.children.length = 0), { props: [Ve(ue("innerHTML", !0, i), n || ue("", !0))] };
}, text: (e, t, s) => {
  const { exp: n, loc: i } = e;
  return n || s.onError(At(55, i)), t.children.length && (s.onError(At(56, i)), t.children.length = 0), { props: [Ve(ue("textContent", !0), n ? jt(n, s) > 0 ? n : we(s.helperString(xi), [n], i) : ue("", !0))] };
}, model: (e, t, s) => {
  const n = Ca(e, t, s);
  if (!n.props.length || t.tagType === 1) return n;
  function i() {
    const l = rt(t, "bind");
    l && xr(l.arg, "value") && s.onError(At(60, l.loc));
  }
  e.arg && s.onError(At(58, e.arg.loc));
  const { tag: o } = t, c = s.isCustomElement(o);
  if (o === "input" || o === "textarea" || o === "select" || c) {
    let l = Th, p = !1;
    if (o === "input" || c) {
      const d = Ut(t, "type");
      if (d) {
        if (d.type === 7) l = Lo;
        else if (d.value) switch (d.value.content) {
          case "radio":
            l = xh;
            break;
          case "checkbox":
            l = bh;
            break;
          case "file":
            p = !0, s.onError(At(59, e.loc));
            break;
          default:
            i();
        }
      } else Sa(t) ? l = Lo : i();
    } else o === "select" ? l = vh : i();
    p || (n.needRuntime = s.helper(l));
  } else s.onError(At(57, e.loc));
  return n.props = n.props.filter((l) => !(l.key.type === 4 && l.key.content === "modelValue")), n;
}, on: (e, t, s) => Aa(e, t, s, (n) => {
  const { modifiers: i } = e;
  if (!i.length) return n;
  let { key: o, value: c } = n.props[0];
  const { keyModifiers: l, nonKeyModifiers: p, eventOptionModifiers: d } = ((g, f) => {
    const x = [], m = [], y = [];
    for (let v = 0; v < f.length; v++) {
      const b = f[v].content;
      $v(b) ? y.push(b) : Vv(b) ? vt(g) ? V1(g.content.toLowerCase()) ? x.push(b) : m.push(b) : (x.push(b), m.push(b)) : qv(b) ? m.push(b) : x.push(b);
    }
    return { keyModifiers: x, nonKeyModifiers: m, eventOptionModifiers: y };
  })(o, i, 0, e.loc);
  if (p.includes("right") && (o = H1(o, "onContextmenu")), p.includes("middle") && (o = H1(o, "onMouseup")), p.length && (c = we(s.helper(kh), [c, JSON.stringify(p)])), !l.length || vt(o) && !V1(o.content.toLowerCase()) || (c = we(s.helper(Sh), [c, JSON.stringify(l)])), d.length) {
    const g = d.map(Yr).join("");
    o = vt(o) ? ue(`${o.content}${g}`, !0) : dt(["(", o, `) + "${g}"`]);
  }
  return { props: [Ve(o, c)] };
}), show: (e, t, s) => {
  const { exp: n, loc: i } = e;
  return n || s.onError(At(61, i)), { props: [], needRuntime: s.helper(Eh) };
} };
var gc, J1, np = Object.freeze({ __proto__: null, BASE_TRANSITION: $p, BindingTypes: { DATA: "data", PROPS: "props", PROPS_ALIASED: "props-aliased", SETUP_LET: "setup-let", SETUP_CONST: "setup-const", SETUP_REACTIVE_CONST: "setup-reactive-const", SETUP_MAYBE_REF: "setup-maybe-ref", SETUP_REF: "setup-ref", OPTIONS: "options", LITERAL_CONST: "literal-const" }, CAMELIZE: wo, CAPITALIZE: Xg, CREATE_BLOCK: qp, CREATE_COMMENT: fn, CREATE_ELEMENT_BLOCK: Vp, CREATE_ELEMENT_VNODE: oa, CREATE_SLOTS: zp, CREATE_STATIC: ca, CREATE_TEXT: aa, CREATE_VNODE: gi, CompilerDeprecationTypes: { COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT", COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC", COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER", COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE", COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE", COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE", COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE", COMPILER_FILTERS: "COMPILER_FILTERS" }, ConstantTypes: { NOT_CONSTANT: 0, 0: "NOT_CONSTANT", CAN_SKIP_PATCH: 1, 1: "CAN_SKIP_PATCH", CAN_CACHE: 2, 2: "CAN_CACHE", CAN_STRINGIFY: 3, 3: "CAN_STRINGIFY" }, DOMDirectiveTransforms: sp, DOMErrorCodes: { X_V_HTML_NO_EXPRESSION: 53, 53: "X_V_HTML_NO_EXPRESSION", X_V_HTML_WITH_CHILDREN: 54, 54: "X_V_HTML_WITH_CHILDREN", X_V_TEXT_NO_EXPRESSION: 55, 55: "X_V_TEXT_NO_EXPRESSION", X_V_TEXT_WITH_CHILDREN: 56, 56: "X_V_TEXT_WITH_CHILDREN", X_V_MODEL_ON_INVALID_ELEMENT: 57, 57: "X_V_MODEL_ON_INVALID_ELEMENT", X_V_MODEL_ARG_ON_ELEMENT: 58, 58: "X_V_MODEL_ARG_ON_ELEMENT", X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59, 59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT", X_V_MODEL_UNNECESSARY_VALUE: 60, 60: "X_V_MODEL_UNNECESSARY_VALUE", X_V_SHOW_NO_EXPRESSION: 61, 61: "X_V_SHOW_NO_EXPRESSION", X_TRANSITION_INVALID_CHILDREN: 62, 62: "X_TRANSITION_INVALID_CHILDREN", X_IGNORED_SIDE_EFFECT_TAG: 63, 63: "X_IGNORED_SIDE_EFFECT_TAG", __EXTEND_POINT__: 64, 64: "__EXTEND_POINT__" }, DOMErrorMessages: _h, DOMNodeTransforms: rp, ElementTypes: { ELEMENT: 0, 0: "ELEMENT", COMPONENT: 1, 1: "COMPONENT", SLOT: 2, 2: "SLOT", TEMPLATE: 3, 3: "TEMPLATE" }, ErrorCodes: { ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0, 0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT", CDATA_IN_HTML_CONTENT: 1, 1: "CDATA_IN_HTML_CONTENT", DUPLICATE_ATTRIBUTE: 2, 2: "DUPLICATE_ATTRIBUTE", END_TAG_WITH_ATTRIBUTES: 3, 3: "END_TAG_WITH_ATTRIBUTES", END_TAG_WITH_TRAILING_SOLIDUS: 4, 4: "END_TAG_WITH_TRAILING_SOLIDUS", EOF_BEFORE_TAG_NAME: 5, 5: "EOF_BEFORE_TAG_NAME", EOF_IN_CDATA: 6, 6: "EOF_IN_CDATA", EOF_IN_COMMENT: 7, 7: "EOF_IN_COMMENT", EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8, 8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT", EOF_IN_TAG: 9, 9: "EOF_IN_TAG", INCORRECTLY_CLOSED_COMMENT: 10, 10: "INCORRECTLY_CLOSED_COMMENT", INCORRECTLY_OPENED_COMMENT: 11, 11: "INCORRECTLY_OPENED_COMMENT", INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12, 12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME", MISSING_ATTRIBUTE_VALUE: 13, 13: "MISSING_ATTRIBUTE_VALUE", MISSING_END_TAG_NAME: 14, 14: "MISSING_END_TAG_NAME", MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15, 15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES", NESTED_COMMENT: 16, 16: "NESTED_COMMENT", UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17, 17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME", UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18, 18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE", UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19, 19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME", UNEXPECTED_NULL_CHARACTER: 20, 20: "UNEXPECTED_NULL_CHARACTER", UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21, 21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME", UNEXPECTED_SOLIDUS_IN_TAG: 22, 22: "UNEXPECTED_SOLIDUS_IN_TAG", X_INVALID_END_TAG: 23, 23: "X_INVALID_END_TAG", X_MISSING_END_TAG: 24, 24: "X_MISSING_END_TAG", X_MISSING_INTERPOLATION_END: 25, 25: "X_MISSING_INTERPOLATION_END", X_MISSING_DIRECTIVE_NAME: 26, 26: "X_MISSING_DIRECTIVE_NAME", X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27, 27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END", X_V_IF_NO_EXPRESSION: 28, 28: "X_V_IF_NO_EXPRESSION", X_V_IF_SAME_KEY: 29, 29: "X_V_IF_SAME_KEY", X_V_ELSE_NO_ADJACENT_IF: 30, 30: "X_V_ELSE_NO_ADJACENT_IF", X_V_FOR_NO_EXPRESSION: 31, 31: "X_V_FOR_NO_EXPRESSION", X_V_FOR_MALFORMED_EXPRESSION: 32, 32: "X_V_FOR_MALFORMED_EXPRESSION", X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33, 33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT", X_V_BIND_NO_EXPRESSION: 34, 34: "X_V_BIND_NO_EXPRESSION", X_V_ON_NO_EXPRESSION: 35, 35: "X_V_ON_NO_EXPRESSION", X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36, 36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET", X_V_SLOT_MIXED_SLOT_USAGE: 37, 37: "X_V_SLOT_MIXED_SLOT_USAGE", X_V_SLOT_DUPLICATE_SLOT_NAMES: 38, 38: "X_V_SLOT_DUPLICATE_SLOT_NAMES", X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39, 39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN", X_V_SLOT_MISPLACED: 40, 40: "X_V_SLOT_MISPLACED", X_V_MODEL_NO_EXPRESSION: 41, 41: "X_V_MODEL_NO_EXPRESSION", X_V_MODEL_MALFORMED_EXPRESSION: 42, 42: "X_V_MODEL_MALFORMED_EXPRESSION", X_V_MODEL_ON_SCOPE_VARIABLE: 43, 43: "X_V_MODEL_ON_SCOPE_VARIABLE", X_V_MODEL_ON_PROPS: 44, 44: "X_V_MODEL_ON_PROPS", X_INVALID_EXPRESSION: 45, 45: "X_INVALID_EXPRESSION", X_KEEP_ALIVE_INVALID_CHILDREN: 46, 46: "X_KEEP_ALIVE_INVALID_CHILDREN", X_PREFIX_ID_NOT_SUPPORTED: 47, 47: "X_PREFIX_ID_NOT_SUPPORTED", X_MODULE_MODE_NOT_SUPPORTED: 48, 48: "X_MODULE_MODE_NOT_SUPPORTED", X_CACHE_HANDLER_NOT_SUPPORTED: 49, 49: "X_CACHE_HANDLER_NOT_SUPPORTED", X_SCOPE_ID_NOT_SUPPORTED: 50, 50: "X_SCOPE_ID_NOT_SUPPORTED", X_VNODE_HOOKS: 51, 51: "X_VNODE_HOOKS", X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52, 52: "X_V_BIND_INVALID_SAME_NAME_ARGUMENT", __EXTEND_POINT__: 53, 53: "__EXTEND_POINT__" }, FRAGMENT: rn, GUARD_REACTIVE_PROPS: mn, IS_MEMO_SAME: Wp, IS_REF: ti, KEEP_ALIVE: Qn, MERGE_PROPS: Es, NORMALIZE_CLASS: ua, NORMALIZE_PROPS: sn, NORMALIZE_STYLE: da, Namespaces: { HTML: 0, 0: "HTML", SVG: 1, 1: "SVG", MATH_ML: 2, 2: "MATH_ML" }, NodeTypes: { ROOT: 0, 0: "ROOT", ELEMENT: 1, 1: "ELEMENT", TEXT: 2, 2: "TEXT", COMMENT: 3, 3: "COMMENT", SIMPLE_EXPRESSION: 4, 4: "SIMPLE_EXPRESSION", INTERPOLATION: 5, 5: "INTERPOLATION", ATTRIBUTE: 6, 6: "ATTRIBUTE", DIRECTIVE: 7, 7: "DIRECTIVE", COMPOUND_EXPRESSION: 8, 8: "COMPOUND_EXPRESSION", IF: 9, 9: "IF", IF_BRANCH: 10, 10: "IF_BRANCH", FOR: 11, 11: "FOR", TEXT_CALL: 12, 12: "TEXT_CALL", VNODE_CALL: 13, 13: "VNODE_CALL", JS_CALL_EXPRESSION: 14, 14: "JS_CALL_EXPRESSION", JS_OBJECT_EXPRESSION: 15, 15: "JS_OBJECT_EXPRESSION", JS_PROPERTY: 16, 16: "JS_PROPERTY", JS_ARRAY_EXPRESSION: 17, 17: "JS_ARRAY_EXPRESSION", JS_FUNCTION_EXPRESSION: 18, 18: "JS_FUNCTION_EXPRESSION", JS_CONDITIONAL_EXPRESSION: 19, 19: "JS_CONDITIONAL_EXPRESSION", JS_CACHE_EXPRESSION: 20, 20: "JS_CACHE_EXPRESSION", JS_BLOCK_STATEMENT: 21, 21: "JS_BLOCK_STATEMENT", JS_TEMPLATE_LITERAL: 22, 22: "JS_TEMPLATE_LITERAL", JS_IF_STATEMENT: 23, 23: "JS_IF_STATEMENT", JS_ASSIGNMENT_EXPRESSION: 24, 24: "JS_ASSIGNMENT_EXPRESSION", JS_SEQUENCE_EXPRESSION: 25, 25: "JS_SEQUENCE_EXPRESSION", JS_RETURN_STATEMENT: 26, 26: "JS_RETURN_STATEMENT" }, OPEN_BLOCK: Qr, POP_SCOPE_ID: Jg, PUSH_SCOPE_ID: Kg, RENDER_LIST: ha, RENDER_SLOT: Hp, RESOLVE_COMPONENT: Zn, RESOLVE_DIRECTIVE: la, RESOLVE_DYNAMIC_COMPONENT: yi, RESOLVE_FILTER: Gg, SET_BLOCK_TRACKING: ei, SUSPENSE: dn, TELEPORT: Ts, TO_DISPLAY_STRING: xi, TO_HANDLERS: fa, TO_HANDLER_KEY: _o, TRANSITION: Os, TRANSITION_GROUP: gn, TS_NODE_TYPES: ka, UNREF: nn, V_MODEL_CHECKBOX: bh, V_MODEL_DYNAMIC: Lo, V_MODEL_RADIO: xh, V_MODEL_SELECT: vh, V_MODEL_TEXT: Th, V_ON_WITH_KEYS: Sh, V_ON_WITH_MODIFIERS: kh, V_SHOW: Eh, WITH_CTX: ma, WITH_DIRECTIVES: pa, WITH_MEMO: ga, advancePositionWithClone: Gl, advancePositionWithMutation: sh, assert: Xl, baseCompile: q1, baseParse: Oo, buildDirectiveArgs: dh, buildProps: pn, buildSlots: Un, checkCompatEnabled: function(e, t, s, ...n) {
  const i = (function(o, c) {
    const l = zl("MODE", c), p = zl(o, c);
    return l === 3 ? p === !0 : p !== !1;
  })(e, t);
  return i && h1(e, t, s, ...n), i;
}, compile: function(e, t = {}) {
  return q1(e, kr({}, Js, t, { nodeTransforms: [Jv, ...rp, ...t.nodeTransforms || []], directiveTransforms: kr({}, sp, t.directiveTransforms || {}), transformHoist: zv }));
}, convertToBlock: ya, createArrayExpression: Nr, createAssignmentExpression: oo, createBlockStatement: bi, createCacheExpression: Yg, createCallExpression: we, createCompilerError: $e, createCompoundExpression: dt, createConditionalExpression: or, createDOMCompilerError: At, createForLoopParams: ii, createFunctionExpression: Wt, createIfStatement: Ao, createInterpolation: Po, createObjectExpression: Ft, createObjectProperty: Ve, createReturnStatement: Zg, createRoot: Ns, createSequenceExpression: Qg, createSimpleExpression: ue, createStructuralDirectiveTransform: vi, createTemplateLiteral: Xp, createTransformContext: Ti, createVNodeCall: on, errorMessages: Jp, extractIdentifiers: Yt, findDir: rt, findProp: Ut, forAliasRE: fy, generate: oh, generateCodeFrame: mi, getBaseTransformPreset: yh, getConstantType: jt, getMemoedVNodeCall: dy, getVNodeBlockHelper: _s, getVNodeHelper: ws, hasDynamicKeyVBind: Sa, hasScopeRef: _t, helperNameMap: Mt, injectProp: si, isCoreComponent: th, isFnExpression: hy, isFnExpressionBrowser: (e) => dv.test(Io(e)), isFnExpressionNode: py, isFunctionType: Wr, isInDestructureAssignment: ri, isInNewExpression: ny, isMemberExpression: rh, isMemberExpressionBrowser: (e) => {
  const t = Io(e).trim().replace(uv, (l) => l.trim());
  let s = 0, n = [], i = 0, o = 0, c = null;
  for (let l = 0; l < t.length; l++) {
    const p = t.charAt(l);
    switch (s) {
      case 0:
        if (p === "[") n.push(s), s = 1, i++;
        else if (p === "(") n.push(s), s = 2, o++;
        else if (!(l === 0 ? Wl : hv).test(p)) return !1;
        break;
      case 1:
        p === "'" || p === '"' || p === "`" ? (n.push(s), s = 3, c = p) : p === "[" ? i++ : p === "]" && (--i || (s = n.pop()));
        break;
      case 2:
        if (p === "'" || p === '"' || p === "`") n.push(s), s = 3, c = p;
        else if (p === "(") o++;
        else if (p === ")") {
          if (l === t.length - 1) return !1;
          --o || (s = n.pop());
        }
        break;
      case 3:
        p === c && (s = n.pop(), c = null);
    }
  }
  return !i && !o;
}, isMemberExpressionNode: ly, isReferencedIdentifier: Qp, isSimpleIdentifier: Lr, isSlotOutlet: cn, isStaticArgOf: xr, isStaticExp: vt, isStaticProperty: va, isStaticPropertyKey: cy, isTemplateNode: an, isText: Bn, isVPre: Kl, isVSlot: Ea, locStub: tt, noopDirectiveTransform: $n, parse: function(e, t = {}) {
  return Oo(e, kr({}, Js, t));
}, parserOptions: Js, processExpression: yt, processFor: lh, processIf: ch, processSlotOutlet: fh, registerRuntimeHelpers: Gp, resolveComponentType: Pa, stringifyExpression: _a, toValidAssetId: ni, trackSlotScopes: hh, trackVForSlotScopes: uh, transform: ih, transformBind: mh, transformElement: Cy, transformExpression: ah, transformModel: Ca, transformOn: Aa, transformStyle: wh, transformVBindShorthand: gh, traverseNode: ln, unwrapTSNode: Gt, validFirstIdentCharRE: Wl, walkBlockDeclarations: eh, walkFunctionParams: Zp, walkIdentifiers: Ta, warnDeprecation: h1 });
function Yv() {
  if (J1) return gc;
  function e(s, n) {
    var i, o;
    if (n.length === 0) return s;
    for (i = 0, o = n.length; i < o; i++) s = (s << 5) - s + n.charCodeAt(i), s |= 0;
    return s < 0 ? -2 * s : s;
  }
  function t(s, n, i, o) {
    var c, l = e(e(e(s, i), (c = n, Object.prototype.toString.call(c))), typeof n);
    if (n === null) return e(l, "null");
    if (n === void 0) return e(l, "undefined");
    if (typeof n == "object" || typeof n == "function") {
      if (o.indexOf(n) !== -1) return e(l, "[Circular]" + i);
      o.push(n);
      var p = (function(d, g, f) {
        return Object.keys(g).sort().reduce(function(x, m) {
          return t(x, g[m], m, f);
        }, d);
      })(l, n, o);
      if (!("valueOf" in n) || typeof n.valueOf != "function") return p;
      try {
        return e(p, String(n.valueOf()));
      } catch (d) {
        return e(p, "[valueOf exception]" + (d.stack || d.message));
      }
    }
    return e(l, n.toString());
  }
  return J1 = 1, gc = function(s) {
    return (function(n, i) {
      for (; n.length < i; ) n = "0" + n;
      return n;
    })(t(0, s, "", []).toString(16), 8);
  }, gc;
}
var Qv = xa(Yv());
const Ro = "useCssVars";
function Ny(e, t, s, n = !1) {
  return `{
  ${e.map((i) => `"${n ? ":--" : ""}${Oy(t, i, s, n)}": (${i})`).join(`,
  `)}
}`;
}
function Oy(e, t, s, n = !1) {
  return s ? Qv(e + t).replace(/^\d/, (c) => `v${c}`) : `${e}-${i = t, o = n, i.replace(ZT, (c) => o ? c === '"' ? '\\\\\\"' : `\\\\${c}` : `\\${c}`)}`;
  var i, o;
}
function Ly(e) {
  return (e = e.trim())[0] === "'" && e[e.length - 1] === "'" || e[0] === '"' && e[e.length - 1] === '"' ? e.slice(1, -1) : e;
}
const ho = /v-bind\s*\(/g;
function Ry(e, t) {
  let s = 0, n = 0;
  for (let i = t; i < e.length; i++) {
    const o = e.charAt(i);
    switch (s) {
      case 0:
        if (o === "'") s = 1;
        else if (o === '"') s = 2;
        else if (o === "(") n++;
        else if (o === ")") {
          if (!(n > 0)) return i;
          n--;
        }
        break;
      case 1:
        o === "'" && (s = 0);
        break;
      case 2:
        o === '"' && (s = 0);
    }
  }
  return null;
}
const My = (e) => {
  const { id: t, isProd: s } = e;
  return { postcssPlugin: "vue-sfc-vars", Declaration(n) {
    const i = n.value;
    if (ho.test(i)) {
      ho.lastIndex = 0;
      let o, c = "", l = 0;
      for (; o = ho.exec(i); ) {
        const p = o.index + o[0].length, d = Ry(i, p);
        if (d !== null) {
          const g = Ly(i.slice(p, d));
          c += i.slice(l, o.index) + `var(--${Oy(t, g, s)})`, l = d + 1;
        }
      }
      n.value = c + i.slice(l);
    }
  } };
};
function Dy(e, t, s, n) {
  const i = yt(ue(Ny(e, s, n), !1), Ti(Ns([]), { prefixIdentifiers: !0, inline: !0, bindingMetadata: t.__isScriptSetup === !1 ? void 0 : t })), o = i.type === 4 ? i.content : i.children.map((c) => typeof c == "string" ? c : c.content).join("");
  return `_${Ro}(_ctx => (${o}))`;
}
My.postcss = !0;
var Zr = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function Fy() {
  throw new Error("setTimeout has not been defined");
}
function jy() {
  throw new Error("clearTimeout has not been defined");
}
var qr = Fy, Vr = jy;
function By(e) {
  if (qr === setTimeout) return setTimeout(e, 0);
  if ((qr === Fy || !qr) && setTimeout) return qr = setTimeout, setTimeout(e, 0);
  try {
    return qr(e, 0);
  } catch {
    try {
      return qr.call(null, e, 0);
    } catch {
      return qr.call(this, e, 0);
    }
  }
}
typeof Zr.setTimeout == "function" && (qr = setTimeout), typeof Zr.clearTimeout == "function" && (Vr = clearTimeout);
var xs, Ar = [], Ys = !1, uo = -1;
function Zv() {
  Ys && xs && (Ys = !1, xs.length ? Ar = xs.concat(Ar) : uo = -1, Ar.length && Uy());
}
function Uy() {
  if (!Ys) {
    var e = By(Zv);
    Ys = !0;
    for (var t = Ar.length; t; ) {
      for (xs = Ar, Ar = []; ++uo < t; ) xs && xs[uo].run();
      uo = -1, t = Ar.length;
    }
    xs = null, Ys = !1, (function(s) {
      if (Vr === clearTimeout) return clearTimeout(s);
      if ((Vr === jy || !Vr) && clearTimeout) return Vr = clearTimeout, clearTimeout(s);
      try {
        return Vr(s);
      } catch {
        try {
          return Vr.call(null, s);
        } catch {
          return Vr.call(this, s);
        }
      }
    })(e);
  }
}
function $y(e, t) {
  this.fun = e, this.array = t;
}
$y.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Ls() {
}
var ek = Ls, tk = Ls, rk = Ls, sk = Ls, nk = Ls, ik = Ls, ok = Ls, zs = Zr.performance || {}, ak = zs.now || zs.mozNow || zs.msNow || zs.oNow || zs.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
}, ck = /* @__PURE__ */ new Date(), $t = { nextTick: function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var s = 1; s < arguments.length; s++) t[s - 1] = arguments[s];
  Ar.push(new $y(e, t)), Ar.length !== 1 || Ys || By(Uy);
}, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: ek, addListener: tk, once: rk, off: sk, removeListener: nk, removeAllListeners: ik, emit: ok, binding: function(e) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e) {
  var t = 1e-3 * ak.call(zs), s = Math.floor(t), n = Math.floor(t % 1 * 1e9);
  return e && (s -= e[0], (n -= e[1]) < 0 && (s--, n += 1e9)), [s, n];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - ck) / 1e3;
} };
function Ph(e = 500) {
  return /* @__PURE__ */ new Map();
}
function qy(e, t) {
  return (function(s) {
    const { content: n, ast: i } = s.template, o = Y1.get(n);
    if (o) return o;
    const c = /* @__PURE__ */ new Set();
    function l(p) {
      var d;
      switch (p.type) {
        case 1:
          let g = p.tag;
          g.includes(".") && (g = g.split(".")[0].trim()), Js.isNativeTag(g) || Js.isBuiltInComponent(g) || (c.add(Dt(g)), c.add(Yr(Dt(g))));
          for (let f = 0; f < p.props.length; f++) {
            const x = p.props[f];
            x.type === 7 && (Up(x.name) || c.add(`v${Yr(Dt(x.name))}`), x.arg && !x.arg.isStatic && qi(c, x.arg), x.name === "for" ? qi(c, x.forParseResult.source) : x.exp ? qi(c, x.exp) : x.name !== "bind" || x.exp || c.add(Dt(x.arg.content))), x.type === 6 && x.name === "ref" && ((d = x.value) != null && d.content) && c.add(x.value.content);
          }
          p.children.forEach(l);
          break;
        case 5:
          qi(c, p.content);
      }
    }
    return i.children.forEach(l), Y1.set(n, c), c;
  })(t).has(e);
}
const Y1 = Ph();
function qi(e, t) {
  t.ast ? Ta(t.ast, (s) => e.add(s.name)) : t.ast === null && e.add(t.content);
}
var lk = Object.defineProperty, pk = Object.defineProperties, hk = Object.getOwnPropertyDescriptors, Q1 = Object.getOwnPropertySymbols, uk = Object.prototype.hasOwnProperty, dk = Object.prototype.propertyIsEnumerable, Z1 = (e, t, s) => t in e ? lk(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, ed = (e, t) => {
  for (var s in t || (t = {})) uk.call(t, s) && Z1(e, s, t[s]);
  if (Q1) for (var s of Q1(t)) dk.call(t, s) && Z1(e, s, t[s]);
  return e;
}, td = (e, t) => pk(e, hk(t));
const Vy = "anonymous.vue", rd = Ph();
function Hy(e, t = {}) {
  var s;
  const n = (function(E, w) {
    return E + JSON.stringify(w, (C, A) => typeof A == "function" ? A.toString() : A);
  })(e, td(ed({}, t), { compiler: { parse: (s = t.compiler) == null ? void 0 : s.parse } })), i = rd.get(n);
  if (i) return i;
  const { sourceMap: o = !0, filename: c = Vy, sourceRoot: l = "", pad: p = !1, ignoreEmpty: d = !0, compiler: g = np, templateParseOptions: f = {} } = t, x = { filename: c, source: e, template: null, script: null, scriptSetup: null, styles: [], customBlocks: [], cssVars: [], slotted: !1, shouldForceReload: (E) => (function(w, C) {
    if (!C.scriptSetup || C.scriptSetup.lang !== "ts" && C.scriptSetup.lang !== "tsx") return !1;
    for (const A in w) if (!w[A].isUsedInTemplate && qy(A, C)) return !0;
    return !1;
  })(E, x) }, m = [];
  g.parse(e, td(ed({ parseMode: "sfc", prefixIdentifiers: !0 }, f), { onError: (E) => {
    m.push(E);
  } })).children.forEach((E) => {
    if (E.type === 1 && (!d || E.tag === "template" || !(function(w) {
      for (let C = 0; C < w.children.length; C++) {
        const A = w.children[C];
        if (A.type !== 2 || A.content.trim() !== "") return !1;
      }
      return !0;
    })(E) || (function(w) {
      return w.props.some((C) => C.type === 6 && C.name === "src");
    })(E))) switch (E.tag) {
      case "template":
        if (x.template) m.push(sd(E));
        else {
          const O = x.template = Vi(E, e, !1);
          if (O.attrs.src || (O.ast = Ns(E.children, e)), O.attrs.functional) {
            const D = new SyntaxError("<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.");
            D.loc = E.props.find((N) => N.type === 6 && N.name === "functional").loc, m.push(D);
          }
        }
        break;
      case "script":
        const w = Vi(E, e, p), C = !!w.attrs.setup;
        if (C && !x.scriptSetup) {
          x.scriptSetup = w;
          break;
        }
        if (!C && !x.script) {
          x.script = w;
          break;
        }
        m.push(sd(E, C));
        break;
      case "style":
        const A = Vi(E, e, p);
        A.attrs.vars && m.push(new SyntaxError("<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231")), x.styles.push(A);
        break;
      default:
        x.customBlocks.push(Vi(E, e, p));
    }
  }), x.template || x.script || x.scriptSetup || m.push(new SyntaxError(`At least one <template> or <script> is required in a single file component. ${x.filename}`)), x.scriptSetup && (x.scriptSetup.src && (m.push(new SyntaxError('<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.')), x.scriptSetup = null), x.script && x.script.src && (m.push(new SyntaxError('<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.')), x.script = null));
  let y = 0;
  if (!x.template || x.template.lang !== "pug" && x.template.lang !== "jade" || ([x.template.content, y] = (function(E) {
    const w = E.split(`
`), C = w.reduce(function(A, O) {
      var D, N;
      if (O.trim() === "") return A;
      const j = ((N = (D = O.match(/^\s*/)) == null ? void 0 : D[0]) == null ? void 0 : N.length) || 0;
      return Math.min(j, A);
    }, 1 / 0);
    return C === 0 ? [E, C] : [w.map(function(A) {
      return A.slice(C);
    }).join(`
`), C];
  })(x.template.content)), o) {
    const E = (w, C = 0) => {
      w && !w.src && (w.map = (function(A, O, D, N, j, U) {
        const X = new vs.SourceMapGenerator({ file: A.replace(/\\/g, "/"), sourceRoot: N.replace(/\\/g, "/") });
        return X.setSourceContent(A, O), X._sources.add(A), D.split(zy).forEach((W, H) => {
          if (!fk.test(W)) {
            const F = H + 1 + j, q = H + 1;
            for (let G = 0; G < W.length; G++) /\s/.test(W[G]) || X._mappings.add({ originalLine: F, originalColumn: G + U, generatedLine: q, generatedColumn: G, source: A, name: null });
          }
        }), X.toJSON();
      })(c, e, w.content, l, p && w.type !== "template" ? 0 : w.loc.start.line - 1, C));
    };
    E(x.template, y), E(x.script), x.styles.forEach((w) => E(w)), x.customBlocks.forEach((w) => E(w));
  }
  x.cssVars = (function(E) {
    const w = [];
    return E.styles.forEach((C) => {
      let A;
      const O = C.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
      for (; A = ho.exec(O); ) {
        const D = A.index + A[0].length, N = Ry(O, D);
        if (N !== null) {
          const j = Ly(O.slice(D, N));
          w.includes(j) || w.push(j);
        }
      }
    }), w;
  })(x);
  const v = /(?:::v-|:)slotted\(/;
  x.slotted = x.styles.some((E) => E.scoped && v.test(E.content));
  const b = { descriptor: x, errors: m };
  return rd.set(n, b), b;
}
function sd(e, t = !1) {
  const s = new SyntaxError(`Single file component can contain only one <${e.tag}${t ? " setup" : ""}> element`);
  return s.loc = e.loc, s;
}
function Vi(e, t, s) {
  const n = e.tag, i = e.innerLoc, o = {}, c = { type: n, content: t.slice(i.start.offset, i.end.offset), loc: i, attrs: o };
  return s && (c.content = (function(l, p, d) {
    if (l = l.slice(0, p.loc.start.offset), d === "space") return l.replace(mk, " ");
    {
      const g = l.split(zy).length, f = p.type !== "script" || p.lang ? `
` : `//
`;
      return Array(g).join(f);
    }
  })(t, c, s) + c.content), e.props.forEach((l) => {
    if (l.type === 6) {
      const p = l.name;
      o[p] = l.value && l.value.content || !0, p === "lang" ? c.lang = l.value && l.value.content : p === "src" ? c.src = l.value && l.value.content : n === "style" ? p === "scoped" ? c.scoped = !0 : p === "module" && (c.module = o[p]) : n === "script" && p === "setup" && (c.setup = o.setup);
    }
  }), c;
}
const zy = /\r?\n/g, fk = /^(?:\/\/)?\s*$/, mk = /./g;
function Wy(e, t) {
  for (var s = 0, n = e.length - 1; n >= 0; n--) {
    var i = e[n];
    i === "." ? e.splice(n, 1) : i === ".." ? (e.splice(n, 1), s++) : s && (e.splice(n, 1), s--);
  }
  if (t) for (; s--; s) e.unshift("..");
  return e;
}
var gk = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ah = function(e) {
  return gk.exec(e).slice(1);
};
function Mo() {
  for (var e = "", t = !1, s = arguments.length - 1; s >= -1 && !t; s--) {
    var n = s >= 0 ? arguments[s] : "/";
    if (typeof n != "string") throw new TypeError("Arguments to path.resolve must be strings");
    n && (e = n + "/" + e, t = n.charAt(0) === "/");
  }
  return (t ? "/" : "") + (e = Wy(Oh(e.split("/"), function(i) {
    return !!i;
  }), !t).join("/")) || ".";
}
function Ch(e) {
  var t = Ih(e), s = yk(e, -1) === "/";
  return (e = Wy(Oh(e.split("/"), function(n) {
    return !!n;
  }), !t).join("/")) || t || (e = "."), e && s && (e += "/"), (t ? "/" : "") + e;
}
function Ih(e) {
  return e.charAt(0) === "/";
}
function Gy() {
  return Ch(Oh(Array.prototype.slice.call(arguments, 0), function(e, t) {
    if (typeof e != "string") throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function Xy(e, t) {
  function s(d) {
    for (var g = 0; g < d.length && d[g] === ""; g++) ;
    for (var f = d.length - 1; f >= 0 && d[f] === ""; f--) ;
    return g > f ? [] : d.slice(g, f - g + 1);
  }
  e = Mo(e).substr(1), t = Mo(t).substr(1);
  for (var n = s(e.split("/")), i = s(t.split("/")), o = Math.min(n.length, i.length), c = o, l = 0; l < o; l++) if (n[l] !== i[l]) {
    c = l;
    break;
  }
  var p = [];
  for (l = c; l < n.length; l++) p.push("..");
  return (p = p.concat(i.slice(c))).join("/");
}
function Do(e) {
  var t = Ah(e), s = t[0], n = t[1];
  return s || n ? (n && (n = n.substr(0, n.length - 1)), s + n) : ".";
}
function Ky(e, t) {
  var s = Ah(e)[2];
  return t && s.substr(-1 * t.length) === t && (s = s.substr(0, s.length - t.length)), s;
}
function Nh(e) {
  return Ah(e)[3];
}
var Rr = { extname: Nh, basename: Ky, dirname: Do, sep: "/", delimiter: ":", relative: Xy, join: Gy, isAbsolute: Ih, normalize: Ch, resolve: Mo };
function Oh(e, t) {
  if (e.filter) return e.filter(t);
  for (var s = [], n = 0; n < e.length; n++) t(e[n], n, e) && s.push(e[n]);
  return s;
}
var yk = "ab".substr(-1) === "b" ? function(e, t, s) {
  return e.substr(t, s);
} : function(e, t, s) {
  return t < 0 && (t = e.length + t), e.substr(t, s);
}, xk = Object.freeze({ __proto__: null, basename: Ky, default: Rr, delimiter: ":", dirname: Do, extname: Nh, isAbsolute: Ih, join: Gy, normalize: Ch, relative: Xy, resolve: Mo, sep: "/" }), yc = 2147483647, bk = /[^\x20-\x7E]/, Tk = /[\x2E\u3002\uFF0E\uFF61]/g, vk = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, Xs = Math.floor, xc = String.fromCharCode;
function nd(e) {
  throw new RangeError(vk[e]);
}
function id(e, t) {
  return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
}
function kk(e, t, s) {
  var n = 0;
  for (e = s ? Xs(e / 700) : e >> 1, e += Xs(e / t); e > 455; n += 36) e = Xs(e / 35);
  return Xs(n + 36 * e / (e + 38));
}
function Sk(e) {
  return (function(t, s) {
    var n = t.split("@"), i = "";
    n.length > 1 && (i = n[0] + "@", t = n[1]);
    var o = (function(c, l) {
      for (var p = c.length, d = []; p--; ) d[p] = l(c[p]);
      return d;
    })((t = t.replace(Tk, ".")).split("."), s).join(".");
    return i + o;
  })(e, function(t) {
    return bk.test(t) ? "xn--" + (function(s) {
      var n, i, o, c, l, p, d, g, f, x, m, y, v, b, E, w = [];
      for (s = (function(C) {
        for (var A, O, D = [], N = 0, j = C.length; N < j; ) (A = C.charCodeAt(N++)) >= 55296 && A <= 56319 && N < j ? (64512 & (O = C.charCodeAt(N++))) == 56320 ? D.push(((1023 & A) << 10) + (1023 & O) + 65536) : (D.push(A), N--) : D.push(A);
        return D;
      })(s), y = s.length, n = 128, i = 0, l = 72, p = 0; p < y; ++p) (m = s[p]) < 128 && w.push(xc(m));
      for (o = c = w.length, c && w.push("-"); o < y; ) {
        for (d = yc, p = 0; p < y; ++p) (m = s[p]) >= n && m < d && (d = m);
        for (d - n > Xs((yc - i) / (v = o + 1)) && nd("overflow"), i += (d - n) * v, n = d, p = 0; p < y; ++p) if ((m = s[p]) < n && ++i > yc && nd("overflow"), m == n) {
          for (g = i, f = 36; !(g < (x = f <= l ? 1 : f >= l + 26 ? 26 : f - l)); f += 36) E = g - x, b = 36 - x, w.push(xc(id(x + E % b, 0))), g = Xs(E / b);
          w.push(xc(id(g, 0))), l = kk(i, v, o == c), i = 0, ++o;
        }
        ++i, ++n;
      }
      return w.join("");
    })(t) : t;
  });
}
var gr = [], Kt = [], Ek = typeof Uint8Array < "u" ? Uint8Array : Array, Lh = !1;
function Jy() {
  Lh = !0;
  for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0; t < 64; ++t) gr[t] = e[t], Kt[e.charCodeAt(t)] = t;
  Kt[45] = 62, Kt[95] = 63;
}
function wk(e) {
  return gr[e >> 18 & 63] + gr[e >> 12 & 63] + gr[e >> 6 & 63] + gr[63 & e];
}
function _k(e, t, s) {
  for (var n, i = [], o = t; o < s; o += 3) n = (e[o] << 16) + (e[o + 1] << 8) + e[o + 2], i.push(wk(n));
  return i.join("");
}
function od(e) {
  var t;
  Lh || Jy();
  for (var s = e.length, n = s % 3, i = "", o = [], c = 16383, l = 0, p = s - n; l < p; l += c) o.push(_k(e, l, l + c > p ? p : l + c));
  return n === 1 ? (t = e[s - 1], i += gr[t >> 2], i += gr[t << 4 & 63], i += "==") : n === 2 && (t = (e[s - 2] << 8) + e[s - 1], i += gr[t >> 10], i += gr[t >> 4 & 63], i += gr[t << 2 & 63], i += "="), o.push(i), o.join("");
}
function Hi(e, t, s, n, i) {
  var o, c, l = 8 * i - n - 1, p = (1 << l) - 1, d = p >> 1, g = -7, f = s ? i - 1 : 0, x = s ? -1 : 1, m = e[t + f];
  for (f += x, o = m & (1 << -g) - 1, m >>= -g, g += l; g > 0; o = 256 * o + e[t + f], f += x, g -= 8) ;
  for (c = o & (1 << -g) - 1, o >>= -g, g += n; g > 0; c = 256 * c + e[t + f], f += x, g -= 8) ;
  if (o === 0) o = 1 - d;
  else {
    if (o === p) return c ? NaN : 1 / 0 * (m ? -1 : 1);
    c += Math.pow(2, n), o -= d;
  }
  return (m ? -1 : 1) * c * Math.pow(2, o - n);
}
function Yy(e, t, s, n, i, o) {
  var c, l, p, d = 8 * o - i - 1, g = (1 << d) - 1, f = g >> 1, x = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : o - 1, y = n ? 1 : -1, v = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, c = g) : (c = Math.floor(Math.log(t) / Math.LN2), t * (p = Math.pow(2, -c)) < 1 && (c--, p *= 2), (t += c + f >= 1 ? x / p : x * Math.pow(2, 1 - f)) * p >= 2 && (c++, p /= 2), c + f >= g ? (l = 0, c = g) : c + f >= 1 ? (l = (t * p - 1) * Math.pow(2, i), c += f) : (l = t * Math.pow(2, f - 1) * Math.pow(2, i), c = 0)); i >= 8; e[s + m] = 255 & l, m += y, l /= 256, i -= 8) ;
  for (c = c << i | l, d += i; d > 0; e[s + m] = 255 & c, m += y, c /= 256, d -= 8) ;
  e[s + m - y] |= 128 * v;
}
var Pk = {}.toString, Qy = Array.isArray || function(e) {
  return Pk.call(e) == "[object Array]";
};
function Fo() {
  return le.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Cr(e, t) {
  if (Fo() < t) throw new RangeError("Invalid typed array length");
  return le.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = le.prototype : (e === null && (e = new le(t)), e.length = t), e;
}
function le(e, t, s) {
  if (!(le.TYPED_ARRAY_SUPPORT || this instanceof le)) return new le(e, t, s);
  if (typeof e == "number") {
    if (typeof t == "string") throw new Error("If encoding is specified then the first argument must be a string");
    return ip(this, e);
  }
  return Zy(this, e, t, s);
}
function Zy(e, t, s, n) {
  if (typeof t == "number") throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer ? (function(i, o, c, l) {
    if (o.byteLength, c < 0 || o.byteLength < c) throw new RangeError("'offset' is out of bounds");
    if (o.byteLength < c + (l || 0)) throw new RangeError("'length' is out of bounds");
    return o = c === void 0 && l === void 0 ? new Uint8Array(o) : l === void 0 ? new Uint8Array(o, c) : new Uint8Array(o, c, l), le.TYPED_ARRAY_SUPPORT ? (i = o).__proto__ = le.prototype : i = bc(i, o), i;
  })(e, t, s, n) : typeof t == "string" ? (function(i, o, c) {
    if (typeof c == "string" && c !== "" || (c = "utf8"), !le.isEncoding(c)) throw new TypeError('"encoding" must be a valid string encoding');
    var l = 0 | tx(o, c);
    i = Cr(i, l);
    var p = i.write(o, c);
    return p !== l && (i = i.slice(0, p)), i;
  })(e, t, s) : (function(i, o) {
    if (yr(o)) {
      var c = 0 | Rh(o.length);
      return (i = Cr(i, c)).length === 0 || o.copy(i, 0, 0, c), i;
    }
    if (o) {
      if (typeof ArrayBuffer < "u" && o.buffer instanceof ArrayBuffer || "length" in o) return typeof o.length != "number" || (l = o.length) != l ? Cr(i, 0) : bc(i, o);
      if (o.type === "Buffer" && Qy(o.data)) return bc(i, o.data);
    }
    var l;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  })(e, t);
}
function ex(e) {
  if (typeof e != "number") throw new TypeError('"size" argument must be a number');
  if (e < 0) throw new RangeError('"size" argument must not be negative');
}
function ip(e, t) {
  if (ex(t), e = Cr(e, t < 0 ? 0 : 0 | Rh(t)), !le.TYPED_ARRAY_SUPPORT) for (var s = 0; s < t; ++s) e[s] = 0;
  return e;
}
function bc(e, t) {
  var s = t.length < 0 ? 0 : 0 | Rh(t.length);
  e = Cr(e, s);
  for (var n = 0; n < s; n += 1) e[n] = 255 & t[n];
  return e;
}
function Rh(e) {
  if (e >= Fo()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Fo().toString(16) + " bytes");
  return 0 | e;
}
function yr(e) {
  return !(e == null || !e._isBuffer);
}
function tx(e, t) {
  if (yr(e)) return e.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
  typeof e != "string" && (e = "" + e);
  var s = e.length;
  if (s === 0) return 0;
  for (var n = !1; ; ) switch (t) {
    case "ascii":
    case "latin1":
    case "binary":
      return s;
    case "utf8":
    case "utf-8":
    case void 0:
      return jo(e).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * s;
    case "hex":
      return s >>> 1;
    case "base64":
      return ix(e).length;
    default:
      if (n) return jo(e).length;
      t = ("" + t).toLowerCase(), n = !0;
  }
}
function Ak(e, t, s) {
  var n = !1;
  if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((s === void 0 || s > this.length) && (s = this.length), s <= 0) || (s >>>= 0) <= (t >>>= 0)) return "";
  for (e || (e = "utf8"); ; ) switch (e) {
    case "hex":
      return Fk(this, t, s);
    case "utf8":
    case "utf-8":
      return sx(this, t, s);
    case "ascii":
      return Mk(this, t, s);
    case "latin1":
    case "binary":
      return Dk(this, t, s);
    case "base64":
      return Rk(this, t, s);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return jk(this, t, s);
    default:
      if (n) throw new TypeError("Unknown encoding: " + e);
      e = (e + "").toLowerCase(), n = !0;
  }
}
function ls(e, t, s) {
  var n = e[t];
  e[t] = e[s], e[s] = n;
}
function ad(e, t, s, n, i) {
  if (e.length === 0) return -1;
  if (typeof s == "string" ? (n = s, s = 0) : s > 2147483647 ? s = 2147483647 : s < -2147483648 && (s = -2147483648), s = +s, isNaN(s) && (s = i ? 0 : e.length - 1), s < 0 && (s = e.length + s), s >= e.length) {
    if (i) return -1;
    s = e.length - 1;
  } else if (s < 0) {
    if (!i) return -1;
    s = 0;
  }
  if (typeof t == "string" && (t = le.from(t, n)), yr(t)) return t.length === 0 ? -1 : cd(e, t, s, n, i);
  if (typeof t == "number") return t &= 255, le.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, s) : Uint8Array.prototype.lastIndexOf.call(e, t, s) : cd(e, [t], s, n, i);
  throw new TypeError("val must be string, number or Buffer");
}
function cd(e, t, s, n, i) {
  var o, c = 1, l = e.length, p = t.length;
  if (n !== void 0 && ((n = String(n).toLowerCase()) === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
    if (e.length < 2 || t.length < 2) return -1;
    c = 2, l /= 2, p /= 2, s /= 2;
  }
  function d(m, y) {
    return c === 1 ? m[y] : m.readUInt16BE(y * c);
  }
  if (i) {
    var g = -1;
    for (o = s; o < l; o++) if (d(e, o) === d(t, g === -1 ? 0 : o - g)) {
      if (g === -1 && (g = o), o - g + 1 === p) return g * c;
    } else g !== -1 && (o -= o - g), g = -1;
  } else for (s + p > l && (s = l - p), o = s; o >= 0; o--) {
    for (var f = !0, x = 0; x < p; x++) if (d(e, o + x) !== d(t, x)) {
      f = !1;
      break;
    }
    if (f) return o;
  }
  return -1;
}
function Ck(e, t, s, n) {
  s = Number(s) || 0;
  var i = e.length - s;
  n ? (n = Number(n)) > i && (n = i) : n = i;
  var o = t.length;
  if (o % 2 != 0) throw new TypeError("Invalid hex string");
  n > o / 2 && (n = o / 2);
  for (var c = 0; c < n; ++c) {
    var l = parseInt(t.substr(2 * c, 2), 16);
    if (isNaN(l)) return c;
    e[s + c] = l;
  }
  return c;
}
function Ik(e, t, s, n) {
  return Ia(jo(t, e.length - s), e, s, n);
}
function rx(e, t, s, n) {
  return Ia((function(i) {
    for (var o = [], c = 0; c < i.length; ++c) o.push(255 & i.charCodeAt(c));
    return o;
  })(t), e, s, n);
}
function Nk(e, t, s, n) {
  return rx(e, t, s, n);
}
function Ok(e, t, s, n) {
  return Ia(ix(t), e, s, n);
}
function Lk(e, t, s, n) {
  return Ia((function(i, o) {
    for (var c, l, p, d = [], g = 0; g < i.length && !((o -= 2) < 0); ++g) l = (c = i.charCodeAt(g)) >> 8, p = c % 256, d.push(p), d.push(l);
    return d;
  })(t, e.length - s), e, s, n);
}
function Rk(e, t, s) {
  return t === 0 && s === e.length ? od(e) : od(e.slice(t, s));
}
function sx(e, t, s) {
  s = Math.min(e.length, s);
  for (var n = [], i = t; i < s; ) {
    var o, c, l, p, d = e[i], g = null, f = d > 239 ? 4 : d > 223 ? 3 : d > 191 ? 2 : 1;
    if (i + f <= s) switch (f) {
      case 1:
        d < 128 && (g = d);
        break;
      case 2:
        (192 & (o = e[i + 1])) == 128 && (p = (31 & d) << 6 | 63 & o) > 127 && (g = p);
        break;
      case 3:
        o = e[i + 1], c = e[i + 2], (192 & o) == 128 && (192 & c) == 128 && (p = (15 & d) << 12 | (63 & o) << 6 | 63 & c) > 2047 && (p < 55296 || p > 57343) && (g = p);
        break;
      case 4:
        o = e[i + 1], c = e[i + 2], l = e[i + 3], (192 & o) == 128 && (192 & c) == 128 && (192 & l) == 128 && (p = (15 & d) << 18 | (63 & o) << 12 | (63 & c) << 6 | 63 & l) > 65535 && p < 1114112 && (g = p);
    }
    g === null ? (g = 65533, f = 1) : g > 65535 && (g -= 65536, n.push(g >>> 10 & 1023 | 55296), g = 56320 | 1023 & g), n.push(g), i += f;
  }
  return (function(x) {
    var m = x.length;
    if (m <= ld) return String.fromCharCode.apply(String, x);
    for (var y = "", v = 0; v < m; ) y += String.fromCharCode.apply(String, x.slice(v, v += ld));
    return y;
  })(n);
}
le.TYPED_ARRAY_SUPPORT = Zr.TYPED_ARRAY_SUPPORT === void 0 || Zr.TYPED_ARRAY_SUPPORT, Fo(), le.poolSize = 8192, le._augment = function(e) {
  return e.__proto__ = le.prototype, e;
}, le.from = function(e, t, s) {
  return Zy(null, e, t, s);
}, le.TYPED_ARRAY_SUPPORT && (le.prototype.__proto__ = Uint8Array.prototype, le.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && le[Symbol.species]), le.alloc = function(e, t, s) {
  return (function(n, i, o, c) {
    return ex(i), i <= 0 ? Cr(n, i) : o !== void 0 ? typeof c == "string" ? Cr(n, i).fill(o, c) : Cr(n, i).fill(o) : Cr(n, i);
  })(null, e, t, s);
}, le.allocUnsafe = function(e) {
  return ip(null, e);
}, le.allocUnsafeSlow = function(e) {
  return ip(null, e);
}, le.isBuffer = function(e) {
  return e != null && (!!e._isBuffer || ud(e) || (function(t) {
    return typeof t.readFloatLE == "function" && typeof t.slice == "function" && ud(t.slice(0, 0));
  })(e));
}, le.compare = function(e, t) {
  if (!yr(e) || !yr(t)) throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var s = e.length, n = t.length, i = 0, o = Math.min(s, n); i < o; ++i) if (e[i] !== t[i]) {
    s = e[i], n = t[i];
    break;
  }
  return s < n ? -1 : n < s ? 1 : 0;
}, le.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, le.concat = function(e, t) {
  if (!Qy(e)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0) return le.alloc(0);
  var s;
  if (t === void 0) for (t = 0, s = 0; s < e.length; ++s) t += e[s].length;
  var n = le.allocUnsafe(t), i = 0;
  for (s = 0; s < e.length; ++s) {
    var o = e[s];
    if (!yr(o)) throw new TypeError('"list" argument must be an Array of Buffers');
    o.copy(n, i), i += o.length;
  }
  return n;
}, le.byteLength = tx, le.prototype._isBuffer = !0, le.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2) ls(this, t, t + 1);
  return this;
}, le.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4) ls(this, t, t + 3), ls(this, t + 1, t + 2);
  return this;
}, le.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8) ls(this, t, t + 7), ls(this, t + 1, t + 6), ls(this, t + 2, t + 5), ls(this, t + 3, t + 4);
  return this;
}, le.prototype.toString = function() {
  var e = 0 | this.length;
  return e === 0 ? "" : arguments.length === 0 ? sx(this, 0, e) : Ak.apply(this, arguments);
}, le.prototype.equals = function(e) {
  if (!yr(e)) throw new TypeError("Argument must be a Buffer");
  return this === e || le.compare(this, e) === 0;
}, le.prototype.inspect = function() {
  var e = "";
  return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">";
}, le.prototype.compare = function(e, t, s, n, i) {
  if (!yr(e)) throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), s === void 0 && (s = e ? e.length : 0), n === void 0 && (n = 0), i === void 0 && (i = this.length), t < 0 || s > e.length || n < 0 || i > this.length) throw new RangeError("out of range index");
  if (n >= i && t >= s) return 0;
  if (n >= i) return -1;
  if (t >= s) return 1;
  if (this === e) return 0;
  for (var o = (i >>>= 0) - (n >>>= 0), c = (s >>>= 0) - (t >>>= 0), l = Math.min(o, c), p = this.slice(n, i), d = e.slice(t, s), g = 0; g < l; ++g) if (p[g] !== d[g]) {
    o = p[g], c = d[g];
    break;
  }
  return o < c ? -1 : c < o ? 1 : 0;
}, le.prototype.includes = function(e, t, s) {
  return this.indexOf(e, t, s) !== -1;
}, le.prototype.indexOf = function(e, t, s) {
  return ad(this, e, t, s, !0);
}, le.prototype.lastIndexOf = function(e, t, s) {
  return ad(this, e, t, s, !1);
}, le.prototype.write = function(e, t, s, n) {
  if (t === void 0) n = "utf8", s = this.length, t = 0;
  else if (s === void 0 && typeof t == "string") n = t, s = this.length, t = 0;
  else {
    if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t |= 0, isFinite(s) ? (s |= 0, n === void 0 && (n = "utf8")) : (n = s, s = void 0);
  }
  var i = this.length - t;
  if ((s === void 0 || s > i) && (s = i), e.length > 0 && (s < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var o = !1; ; ) switch (n) {
    case "hex":
      return Ck(this, e, t, s);
    case "utf8":
    case "utf-8":
      return Ik(this, e, t, s);
    case "ascii":
      return rx(this, e, t, s);
    case "latin1":
    case "binary":
      return Nk(this, e, t, s);
    case "base64":
      return Ok(this, e, t, s);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return Lk(this, e, t, s);
    default:
      if (o) throw new TypeError("Unknown encoding: " + n);
      n = ("" + n).toLowerCase(), o = !0;
  }
}, le.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var ld = 4096;
function Mk(e, t, s) {
  var n = "";
  s = Math.min(e.length, s);
  for (var i = t; i < s; ++i) n += String.fromCharCode(127 & e[i]);
  return n;
}
function Dk(e, t, s) {
  var n = "";
  s = Math.min(e.length, s);
  for (var i = t; i < s; ++i) n += String.fromCharCode(e[i]);
  return n;
}
function Fk(e, t, s) {
  var n = e.length;
  (!t || t < 0) && (t = 0), (!s || s < 0 || s > n) && (s = n);
  for (var i = "", o = t; o < s; ++o) i += Uk(e[o]);
  return i;
}
function jk(e, t, s) {
  for (var n = e.slice(t, s), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
  return i;
}
function ht(e, t, s) {
  if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + t > s) throw new RangeError("Trying to access beyond buffer length");
}
function Rt(e, t, s, n, i, o) {
  if (!yr(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
  if (s + n > e.length) throw new RangeError("Index out of range");
}
function zi(e, t, s, n) {
  t < 0 && (t = 65535 + t + 1);
  for (var i = 0, o = Math.min(e.length - s, 2); i < o; ++i) e[s + i] = (t & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i);
}
function Wi(e, t, s, n) {
  t < 0 && (t = 4294967295 + t + 1);
  for (var i = 0, o = Math.min(e.length - s, 4); i < o; ++i) e[s + i] = t >>> 8 * (n ? i : 3 - i) & 255;
}
function nx(e, t, s, n, i, o) {
  if (s + n > e.length) throw new RangeError("Index out of range");
  if (s < 0) throw new RangeError("Index out of range");
}
function pd(e, t, s, n, i) {
  return i || nx(e, 0, s, 4), Yy(e, t, s, n, 23, 4), s + 4;
}
function hd(e, t, s, n, i) {
  return i || nx(e, 0, s, 8), Yy(e, t, s, n, 52, 8), s + 8;
}
le.prototype.slice = function(e, t) {
  var s, n = this.length;
  if ((e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = t === void 0 ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), le.TYPED_ARRAY_SUPPORT) (s = this.subarray(e, t)).__proto__ = le.prototype;
  else {
    var i = t - e;
    s = new le(i, void 0);
    for (var o = 0; o < i; ++o) s[o] = this[o + e];
  }
  return s;
}, le.prototype.readUIntLE = function(e, t, s) {
  e |= 0, t |= 0, s || ht(e, t, this.length);
  for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256); ) n += this[e + o] * i;
  return n;
}, le.prototype.readUIntBE = function(e, t, s) {
  e |= 0, t |= 0, s || ht(e, t, this.length);
  for (var n = this[e + --t], i = 1; t > 0 && (i *= 256); ) n += this[e + --t] * i;
  return n;
}, le.prototype.readUInt8 = function(e, t) {
  return t || ht(e, 1, this.length), this[e];
}, le.prototype.readUInt16LE = function(e, t) {
  return t || ht(e, 2, this.length), this[e] | this[e + 1] << 8;
}, le.prototype.readUInt16BE = function(e, t) {
  return t || ht(e, 2, this.length), this[e] << 8 | this[e + 1];
}, le.prototype.readUInt32LE = function(e, t) {
  return t || ht(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
}, le.prototype.readUInt32BE = function(e, t) {
  return t || ht(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
}, le.prototype.readIntLE = function(e, t, s) {
  e |= 0, t |= 0, s || ht(e, t, this.length);
  for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256); ) n += this[e + o] * i;
  return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n;
}, le.prototype.readIntBE = function(e, t, s) {
  e |= 0, t |= 0, s || ht(e, t, this.length);
  for (var n = t, i = 1, o = this[e + --n]; n > 0 && (i *= 256); ) o += this[e + --n] * i;
  return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o;
}, le.prototype.readInt8 = function(e, t) {
  return t || ht(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
}, le.prototype.readInt16LE = function(e, t) {
  t || ht(e, 2, this.length);
  var s = this[e] | this[e + 1] << 8;
  return 32768 & s ? 4294901760 | s : s;
}, le.prototype.readInt16BE = function(e, t) {
  t || ht(e, 2, this.length);
  var s = this[e + 1] | this[e] << 8;
  return 32768 & s ? 4294901760 | s : s;
}, le.prototype.readInt32LE = function(e, t) {
  return t || ht(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
}, le.prototype.readInt32BE = function(e, t) {
  return t || ht(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
}, le.prototype.readFloatLE = function(e, t) {
  return t || ht(e, 4, this.length), Hi(this, e, !0, 23, 4);
}, le.prototype.readFloatBE = function(e, t) {
  return t || ht(e, 4, this.length), Hi(this, e, !1, 23, 4);
}, le.prototype.readDoubleLE = function(e, t) {
  return t || ht(e, 8, this.length), Hi(this, e, !0, 52, 8);
}, le.prototype.readDoubleBE = function(e, t) {
  return t || ht(e, 8, this.length), Hi(this, e, !1, 52, 8);
}, le.prototype.writeUIntLE = function(e, t, s, n) {
  e = +e, t |= 0, s |= 0, n || Rt(this, e, t, s, Math.pow(2, 8 * s) - 1, 0);
  var i = 1, o = 0;
  for (this[t] = 255 & e; ++o < s && (i *= 256); ) this[t + o] = e / i & 255;
  return t + s;
}, le.prototype.writeUIntBE = function(e, t, s, n) {
  e = +e, t |= 0, s |= 0, n || Rt(this, e, t, s, Math.pow(2, 8 * s) - 1, 0);
  var i = s - 1, o = 1;
  for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); ) this[t + i] = e / o & 255;
  return t + s;
}, le.prototype.writeUInt8 = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 1, 255, 0), le.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1;
}, le.prototype.writeUInt16LE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 2, 65535, 0), le.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : zi(this, e, t, !0), t + 2;
}, le.prototype.writeUInt16BE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 2, 65535, 0), le.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : zi(this, e, t, !1), t + 2;
}, le.prototype.writeUInt32LE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 4, 4294967295, 0), le.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : Wi(this, e, t, !0), t + 4;
}, le.prototype.writeUInt32BE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 4, 4294967295, 0), le.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Wi(this, e, t, !1), t + 4;
}, le.prototype.writeIntLE = function(e, t, s, n) {
  if (e = +e, t |= 0, !n) {
    var i = Math.pow(2, 8 * s - 1);
    Rt(this, e, t, s, i - 1, -i);
  }
  var o = 0, c = 1, l = 0;
  for (this[t] = 255 & e; ++o < s && (c *= 256); ) e < 0 && l === 0 && this[t + o - 1] !== 0 && (l = 1), this[t + o] = (e / c | 0) - l & 255;
  return t + s;
}, le.prototype.writeIntBE = function(e, t, s, n) {
  if (e = +e, t |= 0, !n) {
    var i = Math.pow(2, 8 * s - 1);
    Rt(this, e, t, s, i - 1, -i);
  }
  var o = s - 1, c = 1, l = 0;
  for (this[t + o] = 255 & e; --o >= 0 && (c *= 256); ) e < 0 && l === 0 && this[t + o + 1] !== 0 && (l = 1), this[t + o] = (e / c | 0) - l & 255;
  return t + s;
}, le.prototype.writeInt8 = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 1, 127, -128), le.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
}, le.prototype.writeInt16LE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 2, 32767, -32768), le.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : zi(this, e, t, !0), t + 2;
}, le.prototype.writeInt16BE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 2, 32767, -32768), le.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : zi(this, e, t, !1), t + 2;
}, le.prototype.writeInt32LE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 4, 2147483647, -2147483648), le.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Wi(this, e, t, !0), t + 4;
}, le.prototype.writeInt32BE = function(e, t, s) {
  return e = +e, t |= 0, s || Rt(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), le.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Wi(this, e, t, !1), t + 4;
}, le.prototype.writeFloatLE = function(e, t, s) {
  return pd(this, e, t, !0, s);
}, le.prototype.writeFloatBE = function(e, t, s) {
  return pd(this, e, t, !1, s);
}, le.prototype.writeDoubleLE = function(e, t, s) {
  return hd(this, e, t, !0, s);
}, le.prototype.writeDoubleBE = function(e, t, s) {
  return hd(this, e, t, !1, s);
}, le.prototype.copy = function(e, t, s, n) {
  if (s || (s = 0), n || n === 0 || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < s && (n = s), n === s || e.length === 0 || this.length === 0) return 0;
  if (t < 0) throw new RangeError("targetStart out of bounds");
  if (s < 0 || s >= this.length) throw new RangeError("sourceStart out of bounds");
  if (n < 0) throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length), e.length - t < n - s && (n = e.length - t + s);
  var i, o = n - s;
  if (this === e && s < t && t < n) for (i = o - 1; i >= 0; --i) e[i + t] = this[i + s];
  else if (o < 1e3 || !le.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i) e[i + t] = this[i + s];
  else Uint8Array.prototype.set.call(e, this.subarray(s, s + o), t);
  return o;
}, le.prototype.fill = function(e, t, s, n) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (n = t, t = 0, s = this.length) : typeof s == "string" && (n = s, s = this.length), e.length === 1) {
      var i = e.charCodeAt(0);
      i < 256 && (e = i);
    }
    if (n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string");
    if (typeof n == "string" && !le.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
  } else typeof e == "number" && (e &= 255);
  if (t < 0 || this.length < t || this.length < s) throw new RangeError("Out of range index");
  if (s <= t) return this;
  var o;
  if (t >>>= 0, s = s === void 0 ? this.length : s >>> 0, e || (e = 0), typeof e == "number") for (o = t; o < s; ++o) this[o] = e;
  else {
    var c = yr(e) ? e : jo(new le(e, n).toString()), l = c.length;
    for (o = 0; o < s - t; ++o) this[o + t] = c[o % l];
  }
  return this;
};
var Mh, Bk = /[^+\/0-9A-Za-z-_]/g;
function Uk(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function jo(e, t) {
  var s;
  t = t || 1 / 0;
  for (var n = e.length, i = null, o = [], c = 0; c < n; ++c) {
    if ((s = e.charCodeAt(c)) > 55295 && s < 57344) {
      if (!i) {
        if (s > 56319) {
          (t -= 3) > -1 && o.push(239, 191, 189);
          continue;
        }
        if (c + 1 === n) {
          (t -= 3) > -1 && o.push(239, 191, 189);
          continue;
        }
        i = s;
        continue;
      }
      if (s < 56320) {
        (t -= 3) > -1 && o.push(239, 191, 189), i = s;
        continue;
      }
      s = 65536 + (i - 55296 << 10 | s - 56320);
    } else i && (t -= 3) > -1 && o.push(239, 191, 189);
    if (i = null, s < 128) {
      if ((t -= 1) < 0) break;
      o.push(s);
    } else if (s < 2048) {
      if ((t -= 2) < 0) break;
      o.push(s >> 6 | 192, 63 & s | 128);
    } else if (s < 65536) {
      if ((t -= 3) < 0) break;
      o.push(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128);
    } else {
      if (!(s < 1114112)) throw new Error("Invalid code point");
      if ((t -= 4) < 0) break;
      o.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, 63 & s | 128);
    }
  }
  return o;
}
function ix(e) {
  return (function(t) {
    var s, n, i, o, c, l;
    Lh || Jy();
    var p = t.length;
    if (p % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    c = t[p - 2] === "=" ? 2 : t[p - 1] === "=" ? 1 : 0, l = new Ek(3 * p / 4 - c), i = c > 0 ? p - 4 : p;
    var d = 0;
    for (s = 0, n = 0; s < i; s += 4, n += 3) o = Kt[t.charCodeAt(s)] << 18 | Kt[t.charCodeAt(s + 1)] << 12 | Kt[t.charCodeAt(s + 2)] << 6 | Kt[t.charCodeAt(s + 3)], l[d++] = o >> 16 & 255, l[d++] = o >> 8 & 255, l[d++] = 255 & o;
    return c === 2 ? (o = Kt[t.charCodeAt(s)] << 2 | Kt[t.charCodeAt(s + 1)] >> 4, l[d++] = 255 & o) : c === 1 && (o = Kt[t.charCodeAt(s)] << 10 | Kt[t.charCodeAt(s + 1)] << 4 | Kt[t.charCodeAt(s + 2)] >> 2, l[d++] = o >> 8 & 255, l[d++] = 255 & o), l;
  })((function(t) {
    if ((t = (function(s) {
      return s.trim ? s.trim() : s.replace(/^\s+|\s+$/g, "");
    })(t).replace(Bk, "")).length < 2) return "";
    for (; t.length % 4 != 0; ) t += "=";
    return t;
  })(e));
}
function Ia(e, t, s, n) {
  for (var i = 0; i < n && !(i + s >= t.length || i >= e.length); ++i) t[i + s] = e[i];
  return i;
}
function ud(e) {
  return !!e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}
Mh = typeof Object.create == "function" ? function(e, t) {
  e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } });
} : function(e, t) {
  e.super_ = t;
  var s = function() {
  };
  s.prototype = t.prototype, e.prototype = new s(), e.prototype.constructor = e;
};
var ox = Object.getOwnPropertyDescriptors || function(e) {
  for (var t = Object.keys(e), s = {}, n = 0; n < t.length; n++) s[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
  return s;
}, $k = /%[sdj%]/g;
function Na(e) {
  if (!es(e)) {
    for (var t = [], s = 0; s < arguments.length; s++) t.push(Sr(arguments[s]));
    return t.join(" ");
  }
  s = 1;
  for (var n = arguments, i = n.length, o = String(e).replace($k, function(l) {
    if (l === "%%") return "%";
    if (s >= i) return l;
    switch (l) {
      case "%s":
        return String(n[s++]);
      case "%d":
        return Number(n[s++]);
      case "%j":
        try {
          return JSON.stringify(n[s++]);
        } catch {
          return "[Circular]";
        }
      default:
        return l;
    }
  }), c = n[s]; s < i; c = n[++s]) Ir(c) || !Mr(c) ? o += " " + c : o += " " + Sr(c);
  return o;
}
function Dh(e, t) {
  if (br(Zr.process)) return function() {
    return Dh(e, t).apply(this, arguments);
  };
  if ($t.noDeprecation === !0) return e;
  var s = !1;
  return function() {
    if (!s) {
      if ($t.throwDeprecation) throw new Error(t);
      $t.traceDeprecation ? console.trace(t) : console.error(t), s = !0;
    }
    return e.apply(this, arguments);
  };
}
var Tc, Gi = {};
function ax(e) {
  return br(Tc) && (Tc = $t.env.NODE_DEBUG || ""), e = e.toUpperCase(), !Gi[e] && (new RegExp("\\b" + e + "\\b", "i").test(Tc) ? Gi[e] = function() {
    var t = Na.apply(null, arguments);
    console.error("%s %d: %s", e, 0, t);
  } : Gi[e] = function() {
  }), Gi[e];
}
function Sr(e, t) {
  var s = { seen: [], stylize: Vk };
  return arguments.length >= 3 && (s.depth = arguments[2]), arguments.length >= 4 && (s.colors = arguments[3]), Oa(t) ? s.showHidden = t : t && $h(s, t), br(s.showHidden) && (s.showHidden = !1), br(s.depth) && (s.depth = 2), br(s.colors) && (s.colors = !1), br(s.customInspect) && (s.customInspect = !0), s.colors && (s.stylize = qk), Bo(s, e, s.depth);
}
function qk(e, t) {
  var s = Sr.styles[t];
  return s ? "\x1B[" + Sr.colors[s][0] + "m" + e + "\x1B[" + Sr.colors[s][1] + "m" : e;
}
function Vk(e, t) {
  return e;
}
function Bo(e, t, s) {
  if (e.customInspect && t && Hn(t.inspect) && t.inspect !== Sr && (!t.constructor || t.constructor.prototype !== t)) {
    var n = t.inspect(s, e);
    return es(n) || (n = Bo(e, n, s)), n;
  }
  var i = (function(x, m) {
    if (br(m)) return x.stylize("undefined", "undefined");
    if (es(m)) {
      var y = "'" + JSON.stringify(m).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return x.stylize(y, "string");
    }
    if (Bh(m)) return x.stylize("" + m, "number");
    if (Oa(m)) return x.stylize("" + m, "boolean");
    if (Ir(m)) return x.stylize("null", "null");
  })(e, t);
  if (i) return i;
  var o = Object.keys(t), c = (function(x) {
    var m = {};
    return x.forEach(function(y, v) {
      m[y] = !0;
    }), m;
  })(o);
  if (e.showHidden && (o = Object.getOwnPropertyNames(t)), Vn(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return vc(t);
  if (o.length === 0) {
    if (Hn(t)) {
      var l = t.name ? ": " + t.name : "";
      return e.stylize("[Function" + l + "]", "special");
    }
    if (qn(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
    if (Uo(t)) return e.stylize(Date.prototype.toString.call(t), "date");
    if (Vn(t)) return vc(t);
  }
  var p, d = "", g = !1, f = ["{", "}"];
  return Fh(t) && (g = !0, f = ["[", "]"]), Hn(t) && (d = " [Function" + (t.name ? ": " + t.name : "") + "]"), qn(t) && (d = " " + RegExp.prototype.toString.call(t)), Uo(t) && (d = " " + Date.prototype.toUTCString.call(t)), Vn(t) && (d = " " + vc(t)), o.length !== 0 || g && t.length != 0 ? s < 0 ? qn(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), p = g ? (function(x, m, y, v, b) {
    for (var E = [], w = 0, C = m.length; w < C; ++w) ux(m, String(w)) ? E.push(kc(x, m, y, v, String(w), !0)) : E.push("");
    return b.forEach(function(A) {
      A.match(/^\d+$/) || E.push(kc(x, m, y, v, A, !0));
    }), E;
  })(e, t, s, c, o) : o.map(function(x) {
    return kc(e, t, s, c, x, g);
  }), e.seen.pop(), (function(x, m, y) {
    var v = x.reduce(function(b, E) {
      return E.indexOf(`
`), b + E.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return v > 60 ? y[0] + (m === "" ? "" : m + `
 `) + " " + x.join(`,
  `) + " " + y[1] : y[0] + m + " " + x.join(", ") + " " + y[1];
  })(p, d, f)) : f[0] + d + f[1];
}
function vc(e) {
  return "[" + Error.prototype.toString.call(e) + "]";
}
function kc(e, t, s, n, i, o) {
  var c, l, p;
  if ((p = Object.getOwnPropertyDescriptor(t, i) || { value: t[i] }).get ? l = p.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : p.set && (l = e.stylize("[Setter]", "special")), ux(n, i) || (c = "[" + i + "]"), l || (e.seen.indexOf(p.value) < 0 ? (l = Ir(s) ? Bo(e, p.value, null) : Bo(e, p.value, s - 1)).indexOf(`
`) > -1 && (l = o ? l.split(`
`).map(function(d) {
    return "  " + d;
  }).join(`
`).substr(2) : `
` + l.split(`
`).map(function(d) {
    return "   " + d;
  }).join(`
`)) : l = e.stylize("[Circular]", "special")), br(c)) {
    if (o && i.match(/^\d+$/)) return l;
    (c = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (c = c.substr(1, c.length - 2), c = e.stylize(c, "name")) : (c = c.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), c = e.stylize(c, "string"));
  }
  return c + ": " + l;
}
function Fh(e) {
  return Array.isArray(e);
}
function Oa(e) {
  return typeof e == "boolean";
}
function Ir(e) {
  return e === null;
}
function jh(e) {
  return e == null;
}
function Bh(e) {
  return typeof e == "number";
}
function es(e) {
  return typeof e == "string";
}
function cx(e) {
  return typeof e == "symbol";
}
function br(e) {
  return e === void 0;
}
function qn(e) {
  return Mr(e) && Uh(e) === "[object RegExp]";
}
function Mr(e) {
  return typeof e == "object" && e !== null;
}
function Uo(e) {
  return Mr(e) && Uh(e) === "[object Date]";
}
function Vn(e) {
  return Mr(e) && (Uh(e) === "[object Error]" || e instanceof Error);
}
function Hn(e) {
  return typeof e == "function";
}
function lx(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || e === void 0;
}
function px(e) {
  return le.isBuffer(e);
}
function Uh(e) {
  return Object.prototype.toString.call(e);
}
function Sc(e) {
  return e < 10 ? "0" + e.toString(10) : e.toString(10);
}
Sr.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Sr.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var Hk = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function hx() {
  var e, t;
  console.log("%s - %s", (e = /* @__PURE__ */ new Date(), t = [Sc(e.getHours()), Sc(e.getMinutes()), Sc(e.getSeconds())].join(":"), [e.getDate(), Hk[e.getMonth()], t].join(" ")), Na.apply(null, arguments));
}
function $h(e, t) {
  if (!t || !Mr(t)) return e;
  for (var s = Object.keys(t), n = s.length; n--; ) e[s[n]] = t[s[n]];
  return e;
}
function ux(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var us = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function qh(e) {
  if (typeof e != "function") throw new TypeError('The "original" argument must be of type Function');
  if (us && e[us]) {
    var t;
    if (typeof (t = e[us]) != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t, us, { value: t, enumerable: !1, writable: !1, configurable: !0 }), t;
  }
  function t() {
    for (var s, n, i = new Promise(function(l, p) {
      s = l, n = p;
    }), o = [], c = 0; c < arguments.length; c++) o.push(arguments[c]);
    o.push(function(l, p) {
      l ? n(l) : s(p);
    });
    try {
      e.apply(this, o);
    } catch (l) {
      n(l);
    }
    return i;
  }
  return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), us && Object.defineProperty(t, us, { value: t, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(t, ox(e));
}
function zk(e, t) {
  if (!e) {
    var s = new Error("Promise was rejected with a falsy value");
    s.reason = e, e = s;
  }
  return t(e);
}
function dx(e) {
  if (typeof e != "function") throw new TypeError('The "original" argument must be of type Function');
  function t() {
    for (var s = [], n = 0; n < arguments.length; n++) s.push(arguments[n]);
    var i = s.pop();
    if (typeof i != "function") throw new TypeError("The last argument must be of type Function");
    var o = this, c = function() {
      return i.apply(o, arguments);
    };
    e.apply(this, s).then(function(l) {
      $t.nextTick(c.bind(null, null, l));
    }, function(l) {
      $t.nextTick(zk.bind(null, l, c));
    });
  }
  return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, ox(e)), t;
}
qh.custom = us;
var Wk = { inherits: Mh, _extend: $h, log: hx, isBuffer: px, isPrimitive: lx, isFunction: Hn, isError: Vn, isDate: Uo, isObject: Mr, isRegExp: qn, isUndefined: br, isSymbol: cx, isString: es, isNumber: Bh, isNullOrUndefined: jh, isNull: Ir, isBoolean: Oa, isArray: Fh, inspect: Sr, deprecate: Dh, format: Na, debuglog: ax, promisify: qh, callbackify: dx }, Gk = Object.freeze({ __proto__: null, _extend: $h, callbackify: dx, debuglog: ax, default: Wk, deprecate: Dh, format: Na, inherits: Mh, inspect: Sr, isArray: Fh, isBoolean: Oa, isBuffer: px, isDate: Uo, isError: Vn, isFunction: Hn, isNull: Ir, isNullOrUndefined: jh, isNumber: Bh, isObject: Mr, isPrimitive: lx, isRegExp: qn, isString: es, isSymbol: cx, isUndefined: br, log: hx, promisify: qh });
function Xk(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var fx = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
function Ec(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "boolean":
      return e ? "true" : "false";
    case "number":
      return isFinite(e) ? e : "";
    default:
      return "";
  }
}
function dd(e, t) {
  if (e.map) return e.map(t);
  for (var s = [], n = 0; n < e.length; n++) s.push(t(e[n], n));
  return s;
}
var Kk = Object.keys || function(e) {
  var t = [];
  for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.push(s);
  return t;
};
function fd(e, t, s, n) {
  t = t || "&", s = s || "=";
  var i = {};
  if (typeof e != "string" || e.length === 0) return i;
  var o = /\+/g, c = (e = e.split(t)).length;
  c > 1e3 && (c = 1e3);
  for (var l = 0; l < c; ++l) {
    var p, d, g, f, x = e[l].replace(o, "%20"), m = x.indexOf(s);
    m >= 0 ? (p = x.substr(0, m), d = x.substr(m + 1)) : (p = x, d = ""), g = decodeURIComponent(p), f = decodeURIComponent(d), Xk(i, g) ? fx(i[g]) ? i[g].push(f) : i[g] = [i[g], f] : i[g] = f;
  }
  return i;
}
const mx = Zr.URL, gx = Zr.URLSearchParams;
var Jk = { parse: yn, resolve: Tx, resolveObject: vx, fileURLToPath: xx, format: bx, Url: Vt, URL: mx, URLSearchParams: gx };
function Vt() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var Yk = /^([a-z0-9.+-]+:)/i, Qk = /:[0-9]*$/, Zk = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, eS = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), op = ["'"].concat(eS), md = ["%", "/", "?", ";", "#"].concat(op), gd = ["/", "?", "#"], tS = 255, yd = /^[+a-z0-9A-Z_-]{0,63}$/, rS = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, sS = { javascript: !0, "javascript:": !0 }, ap = { javascript: !0, "javascript:": !0 }, Qs = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 };
function yn(e, t, s) {
  if (e && Mr(e) && e instanceof Vt) return e;
  var n = new Vt();
  return n.parse(e, t, s), n;
}
function yx(e, t, s, n) {
  if (!es(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
  var i = t.indexOf("?"), o = i !== -1 && i < t.indexOf("#") ? "?" : "#", c = t.split(o);
  c[0] = c[0].replace(/\\/g, "/");
  var l = t = c.join(o);
  if (l = l.trim(), !n && t.split("#").length === 1) {
    var p = Zk.exec(l);
    if (p) return e.path = l, e.href = l, e.pathname = p[1], p[2] ? (e.search = p[2], e.query = s ? fd(e.search.substr(1)) : e.search.substr(1)) : s && (e.search = "", e.query = {}), e;
  }
  var d, g, f, x, m = Yk.exec(l);
  if (m) {
    var y = (m = m[0]).toLowerCase();
    e.protocol = y, l = l.substr(m.length);
  }
  if (n || m || l.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var v = l.substr(0, 2) === "//";
    !v || m && ap[m] || (l = l.substr(2), e.slashes = !0);
  }
  if (!ap[m] && (v || m && !Qs[m])) {
    var b, E, w = -1;
    for (d = 0; d < gd.length; d++) (g = l.indexOf(gd[d])) !== -1 && (w === -1 || g < w) && (w = g);
    for ((E = w === -1 ? l.lastIndexOf("@") : l.lastIndexOf("@", w)) !== -1 && (b = l.slice(0, E), l = l.slice(E + 1), e.auth = decodeURIComponent(b)), w = -1, d = 0; d < md.length; d++) (g = l.indexOf(md[d])) !== -1 && (w === -1 || g < w) && (w = g);
    w === -1 && (w = l.length), e.host = l.slice(0, w), l = l.slice(w), kx(e), e.hostname = e.hostname || "";
    var C = e.hostname[0] === "[" && e.hostname[e.hostname.length - 1] === "]";
    if (!C) {
      var A = e.hostname.split(/\./);
      for (d = 0, f = A.length; d < f; d++) {
        var O = A[d];
        if (O && !O.match(yd)) {
          for (var D = "", N = 0, j = O.length; N < j; N++) O.charCodeAt(N) > 127 ? D += "x" : D += O[N];
          if (!D.match(yd)) {
            var U = A.slice(0, d), X = A.slice(d + 1), W = O.match(rS);
            W && (U.push(W[1]), X.unshift(W[2])), X.length && (l = "/" + X.join(".") + l), e.hostname = U.join(".");
            break;
          }
        }
      }
    }
    e.hostname.length > tS ? e.hostname = "" : e.hostname = e.hostname.toLowerCase(), C || (e.hostname = Sk(e.hostname)), x = e.port ? ":" + e.port : "";
    var H = e.hostname || "";
    e.host = H + x, e.href += e.host, C && (e.hostname = e.hostname.substr(1, e.hostname.length - 2), l[0] !== "/" && (l = "/" + l));
  }
  if (!sS[y]) for (d = 0, f = op.length; d < f; d++) {
    var F = op[d];
    if (l.indexOf(F) !== -1) {
      var q = encodeURIComponent(F);
      q === F && (q = escape(F)), l = l.split(F).join(q);
    }
  }
  var G = l.indexOf("#");
  G !== -1 && (e.hash = l.substr(G), l = l.slice(0, G));
  var ee = l.indexOf("?");
  if (ee !== -1 ? (e.search = l.substr(ee), e.query = l.substr(ee + 1), s && (e.query = fd(e.query)), l = l.slice(0, ee)) : s && (e.search = "", e.query = {}), l && (e.pathname = l), Qs[y] && e.hostname && !e.pathname && (e.pathname = "/"), e.pathname || e.search) {
    x = e.pathname || "";
    var ce = e.search || "";
    e.path = x + ce;
  }
  return e.href = Vh(e), e;
}
function xx(e) {
  if (typeof e == "string") e = new Vt().parse(e);
  else if (!(e instanceof Vt)) throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof e + String(e));
  if (e.protocol !== "file:") throw new TypeError("The URL must be of scheme file");
  return (function(t) {
    const s = t.pathname;
    for (let n = 0; n < s.length; n++) if (s[n] === "%") {
      const i = 32 | s.codePointAt(n + 2);
      if (s[n + 1] === "2" && i === 102) throw new TypeError("must not include encoded / characters");
    }
    return decodeURIComponent(s);
  })(e);
}
function bx(e) {
  return es(e) && (e = yx({}, e)), Vh(e);
}
function Vh(e) {
  var t = e.auth || "";
  t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
  var s = e.protocol || "", n = e.pathname || "", i = e.hash || "", o = !1, c = "";
  e.host ? o = t + e.host : e.hostname && (o = t + (e.hostname.indexOf(":") === -1 ? e.hostname : "[" + this.hostname + "]"), e.port && (o += ":" + e.port)), e.query && Mr(e.query) && Object.keys(e.query).length && (c = (function(p, d, g) {
    return d = d || "&", g = g || "=", p === null && (p = void 0), typeof p == "object" ? dd(Kk(p), function(f) {
      var x = encodeURIComponent(Ec(f)) + g;
      return fx(p[f]) ? dd(p[f], function(m) {
        return x + encodeURIComponent(Ec(m));
      }).join(d) : x + encodeURIComponent(Ec(p[f]));
    }).join(d) : "";
  })(e.query));
  var l = e.search || c && "?" + c || "";
  return s && s.substr(-1) !== ":" && (s += ":"), e.slashes || (!s || Qs[s]) && o !== !1 ? (o = "//" + (o || ""), n && n.charAt(0) !== "/" && (n = "/" + n)) : o || (o = ""), i && i.charAt(0) !== "#" && (i = "#" + i), l && l.charAt(0) !== "?" && (l = "?" + l), n = n.replace(/[?#]/g, function(p) {
    return encodeURIComponent(p);
  }), s + o + n + (l = l.replace("#", "%23")) + i;
}
function Tx(e, t) {
  return yn(e, !1, !0).resolve(t);
}
function vx(e, t) {
  return e ? yn(e, !1, !0).resolveObject(t) : t;
}
function kx(e) {
  var t = e.host, s = Qk.exec(t);
  s && ((s = s[0]) !== ":" && (e.port = s.substr(1)), t = t.substr(0, t.length - s.length)), t && (e.hostname = t);
}
Vt.prototype.parse = function(e, t, s) {
  return yx(this, e, t, s);
}, Vt.prototype.format = function() {
  return Vh(this);
}, Vt.prototype.resolve = function(e) {
  return this.resolveObject(yn(e, !1, !0)).format();
}, Vt.prototype.resolveObject = function(e) {
  if (es(e)) {
    var t = new Vt();
    t.parse(e, !1, !0), e = t;
  }
  for (var s, n = new Vt(), i = Object.keys(this), o = 0; o < i.length; o++) {
    var c = i[o];
    n[c] = this[c];
  }
  if (n.hash = e.hash, e.href === "") return n.href = n.format(), n;
  if (e.slashes && !e.protocol) {
    for (var l = Object.keys(e), p = 0; p < l.length; p++) {
      var d = l[p];
      d !== "protocol" && (n[d] = e[d]);
    }
    return Qs[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"), n.href = n.format(), n;
  }
  if (e.protocol && e.protocol !== n.protocol) {
    if (!Qs[e.protocol]) {
      for (var g = Object.keys(e), f = 0; f < g.length; f++) {
        var x = g[f];
        n[x] = e[x];
      }
      return n.href = n.format(), n;
    }
    if (n.protocol = e.protocol, e.host || ap[e.protocol]) n.pathname = e.pathname;
    else {
      for (s = (e.pathname || "").split("/"); s.length && !(e.host = s.shift()); ) ;
      e.host || (e.host = ""), e.hostname || (e.hostname = ""), s[0] !== "" && s.unshift(""), s.length < 2 && s.unshift(""), n.pathname = s.join("/");
    }
    if (n.search = e.search, n.query = e.query, n.host = e.host || "", n.auth = e.auth, n.hostname = e.hostname || e.host, n.port = e.port, n.pathname || n.search) {
      var m = n.pathname || "", y = n.search || "";
      n.path = m + y;
    }
    return n.slashes = n.slashes || e.slashes, n.href = n.format(), n;
  }
  var v, b = n.pathname && n.pathname.charAt(0) === "/", E = e.host || e.pathname && e.pathname.charAt(0) === "/", w = E || b || n.host && e.pathname, C = w, A = n.pathname && n.pathname.split("/") || [], O = n.protocol && !Qs[n.protocol];
  if (s = e.pathname && e.pathname.split("/") || [], O && (n.hostname = "", n.port = null, n.host && (A[0] === "" ? A[0] = n.host : A.unshift(n.host)), n.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (s[0] === "" ? s[0] = e.host : s.unshift(e.host)), e.host = null), w = w && (s[0] === "" || A[0] === "")), E) n.host = e.host || e.host === "" ? e.host : n.host, n.hostname = e.hostname || e.hostname === "" ? e.hostname : n.hostname, n.search = e.search, n.query = e.query, A = s;
  else if (s.length) A || (A = []), A.pop(), A = A.concat(s), n.search = e.search, n.query = e.query;
  else if (!jh(e.search)) return O && (n.hostname = n.host = A.shift(), (v = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = v.shift(), n.host = n.hostname = v.shift())), n.search = e.search, n.query = e.query, Ir(n.pathname) && Ir(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.href = n.format(), n;
  if (!A.length) return n.pathname = null, n.search ? n.path = "/" + n.search : n.path = null, n.href = n.format(), n;
  for (var D = A.slice(-1)[0], N = (n.host || e.host || A.length > 1) && (D === "." || D === "..") || D === "", j = 0, U = A.length; U >= 0; U--) (D = A[U]) === "." ? A.splice(U, 1) : D === ".." ? (A.splice(U, 1), j++) : j && (A.splice(U, 1), j--);
  if (!w && !C) for (; j--; j) A.unshift("..");
  !w || A[0] === "" || A[0] && A[0].charAt(0) === "/" || A.unshift(""), N && A.join("/").substr(-1) !== "/" && A.push("");
  var X = A[0] === "" || A[0] && A[0].charAt(0) === "/";
  return O && (n.hostname = n.host = X ? "" : A.length ? A.shift() : "", (v = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = v.shift(), n.host = n.hostname = v.shift())), (w = w || n.host && A.length) && !X && A.unshift(""), A.length ? n.pathname = A.join("/") : (n.pathname = null, n.path = null), Ir(n.pathname) && Ir(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.auth = e.auth || n.auth, n.slashes = n.slashes || e.slashes, n.href = n.format(), n;
}, Vt.prototype.parseHost = function() {
  return kx(this);
};
var nS = Object.freeze({ __proto__: null, URL: mx, URLSearchParams: gx, Url: Vt, default: Jk, fileURLToPath: xx, format: bx, parse: yn, resolve: Tx, resolveObject: vx });
function Sx(e) {
  const t = e.charAt(0);
  return t === "." || t === "~" || t === "@";
}
const iS = /^(?:https?:)?\/\//;
function Ex(e) {
  return iS.test(e);
}
const oS = /^\s*data:/i;
function cp(e) {
  return oS.test(e);
}
function lp(e) {
  if (e.charAt(0) === "~") {
    const s = e.charAt(1);
    e = e.slice(s === "/" ? 2 : 1);
  }
  return yn(De(t = e) ? t : "", !1, !0);
  var t;
}
var aS = Object.defineProperty, cS = Object.defineProperties, lS = Object.getOwnPropertyDescriptors, xd = Object.getOwnPropertySymbols, pS = Object.prototype.hasOwnProperty, hS = Object.prototype.propertyIsEnumerable, bd = (e, t, s) => t in e ? aS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, wc = (e, t) => {
  for (var s in t || (t = {})) pS.call(t, s) && bd(e, s, t[s]);
  if (xd) for (var s of xd(t)) hS.call(t, s) && bd(e, s, t[s]);
  return e;
};
const oi = { base: null, includeAbsolute: !1, tags: { video: ["src", "poster"], source: ["src"], img: ["src"], image: ["xlink:href", "href"], use: ["xlink:href", "href"] } }, uS = (e) => {
  return Object.keys(e).some((s) => gt(e[s])) ? (t = wc({}, oi), cS(t, lS({ tags: e }))) : wc(wc({}, oi), e);
  var t;
}, Td = (e, t, s = oi) => {
  if (e.type === 1) {
    if (!e.props.length) return;
    const n = s.tags || oi.tags, i = n[e.tag], o = n["*"];
    if (!i && !o) return;
    const c = (i || []).concat(o || []);
    e.props.forEach((l, p) => {
      if (l.type !== 6 || !c.includes(l.name) || !l.value || Ex(l.value.content) || cp(l.value.content) || l.value.content[0] === "#" || !s.includeAbsolute && !Sx(l.value.content)) return;
      const d = lp(l.value.content);
      if (s.base && l.value.content[0] === ".") {
        const f = lp(s.base), x = f.protocol || "", m = f.host ? x + "//" + f.host : "", y = f.path || "/";
        return void (l.value.content = m + (Rr.posix || Rr).join(y, d.path + (d.hash || "")));
      }
      const g = (function(f, x, m, y) {
        if (f) {
          let v, b;
          const E = y.imports.findIndex((O) => O.path === f);
          if (E > -1 ? (v = `_imports_${E}`, b = y.imports[E].exp) : (v = `_imports_${y.imports.length}`, b = ue(v, !1, m, 3), y.imports.push({ exp: b, path: decodeURIComponent(f) })), !x) return b;
          const w = `${v} + '${x}'`, C = ue(w, !1, m, 3);
          if (!y.hoistStatic) return C;
          const A = y.hoists.findIndex((O) => O && O.type === 4 && !O.isStatic && O.content === w);
          return A > -1 ? ue(`_hoisted_${A + 1}`, !1, m, 3) : y.hoist(C);
        }
        return ue("''", !1, m, 3);
      })(d.path, d.hash, l.loc, t);
      e.props[p] = { type: 7, name: "bind", arg: ue(l.name, !0, l.loc), exp: g, modifiers: [], loc: l.loc };
    });
  }
}, dS = ["img", "source"], fS = /( |\\t|\\n|\\f|\\r)+/g, mS = (e) => (t, s) => wx(t, s, e), wx = (e, t, s = oi) => {
  e.type === 1 && dS.includes(e.tag) && e.props.length && e.props.forEach((n, i) => {
    if (n.name === "srcset" && n.type === 6) {
      if (!n.value) return;
      const o = n.value.content;
      if (!o) return;
      const c = o.split(",").map((g) => {
        const [f, x] = g.replace(fS, " ").trim().split(" ", 2);
        return { url: f, descriptor: x };
      });
      for (let g = 0; g < c.length; g++) {
        const { url: f } = c[g];
        cp(f) && (c[g + 1].url = f + "," + c[g + 1].url, c.splice(g, 1));
      }
      const l = (g) => g && !Ex(g) && !cp(g) && (s.includeAbsolute || Sx(g));
      if (!c.some(({ url: g }) => l(g))) return;
      if (s.base) {
        const g = s.base, f = [];
        let x = !1;
        if (c.forEach((m) => {
          let { url: y, descriptor: v } = m;
          v = v ? ` ${v}` : "", y[0] === "." ? (m.url = (Rr.posix || Rr).join(g, y), f.push(m.url + v)) : l(y) ? x = !0 : f.push(y + v);
        }), !x) return void (n.value.content = f.join(", "));
      }
      const p = dt([], n.loc);
      c.forEach(({ url: g, descriptor: f }, x) => {
        if (l(g)) {
          const { path: y } = lp(g);
          let v;
          if (y) {
            const b = t.imports.findIndex((E) => E.path === y);
            b > -1 ? v = ue(`_imports_${b}`, !1, n.loc, 3) : (v = ue(`_imports_${t.imports.length}`, !1, n.loc, 3), t.imports.push({ exp: v, path: y })), p.children.push(v);
          }
        } else {
          const y = ue(`"${g}"`, !1, n.loc, 3);
          p.children.push(y);
        }
        const m = c.length - 1 > x;
        f && m ? p.children.push(` + ' ${f}, ' + `) : f ? p.children.push(` + ' ${f}'`) : m && p.children.push(" + ', ' + ");
      });
      let d = p;
      t.hoistStatic && (d = t.hoist(p), d.constType = 3), e.props[i] = { type: 7, name: "bind", arg: ue("srcset", !0, n.loc), exp: d, modifiers: [], loc: n.loc };
    }
  });
}, $o = Symbol("ssrInterpolate"), _x = Symbol("ssrRenderVNode"), Px = Symbol("ssrRenderComponent"), Ax = Symbol("ssrRenderSlot"), Cx = Symbol("ssrRenderSlotInner"), Ix = Symbol("ssrRenderClass"), Nx = Symbol("ssrRenderStyle"), Hh = Symbol("ssrRenderAttrs"), Ox = Symbol("ssrRenderAttr"), Lx = Symbol("ssrRenderDynamicAttr"), Rx = Symbol("ssrRenderList"), zh = Symbol("ssrIncludeBooleanAttr"), fo = Symbol("ssrLooseEqual"), pp = Symbol("ssrLooseContain"), Mx = Symbol("ssrRenderDynamicModel"), Dx = Symbol("ssrGetDynamicModelProps"), Fx = Symbol("ssrRenderTeleport"), jx = Symbol("ssrRenderSuspense"), Bx = Symbol("ssrGetDirectiveProps"), hp = { [$o]: "ssrInterpolate", [_x]: "ssrRenderVNode", [Px]: "ssrRenderComponent", [Ax]: "ssrRenderSlot", [Cx]: "ssrRenderSlotInner", [Ix]: "ssrRenderClass", [Nx]: "ssrRenderStyle", [Hh]: "ssrRenderAttrs", [Ox]: "ssrRenderAttr", [Lx]: "ssrRenderDynamicAttr", [Rx]: "ssrRenderList", [zh]: "ssrIncludeBooleanAttr", [fo]: "ssrLooseEqual", [pp]: "ssrLooseContain", [Mx]: "ssrRenderDynamicModel", [Dx]: "ssrGetDynamicModelProps", [Fx]: "ssrRenderTeleport", [jx]: "ssrRenderSuspense", [Bx]: "ssrGetDirectiveProps" };
Gp(hp);
const gS = vi(/^(?:if|else|else-if)$/, ch);
function yS(e, t, s = !1, n = !1) {
  const [i] = e.branches, o = Ao(i.condition, vd(i, t, s));
  t.pushStatement(o);
  let c = o;
  for (let l = 1; l < e.branches.length; l++) {
    const p = e.branches[l], d = vd(p, t, s);
    p.condition ? c = c.alternate = Ao(p.condition, d) : c.alternate = d;
  }
  c.alternate || n || (c.alternate = bi([we("_push", ["`<!---->`"])]));
}
function vd(e, t, s = !1) {
  const { children: n } = e;
  return Zs(e, t, !(s || n.length === 1 && n[0].type === 1 || n.length === 1 && n[0].type === 11));
}
const xS = vi("for", lh);
function bS(e, t, s = !1) {
  const n = !s && (e.children.length !== 1 || e.children[0].type !== 1), i = Wt(ii(e.parseResult));
  i.body = Zs(e, t, n), s || t.pushStringPart("<!--[-->"), t.pushStatement(we(t.helper(Rx), [e.source, i])), s || t.pushStringPart("<!--]-->");
}
const TS = (e, t) => {
  if (cn(e)) {
    const { slotName: s, slotProps: n } = fh(e, t), i = ["_ctx.$slots", s, n || "{}", "null", "_push", "_parent"];
    t.scopeId && t.slotted !== !1 && i.push(`"${t.scopeId}-s"`);
    let o = Ax, c = t.parent;
    if (c) {
      const l = c.children;
      let p;
      c.type === 10 && (c = t.grandParent), c.type !== 1 || c.tagType !== 1 || (p = Pa(c, t, !0)) !== Os && p !== gn || l.filter((d) => d.type === 1).length !== 1 || (o = Cx, t.scopeId && t.slotted !== !1 || i.push("null"), i.push("true"));
    }
    e.ssrCodegenNode = we(t.helper(o), i);
  }
};
function vS(e, t) {
  const s = e.ssrCodegenNode;
  if (e.children.length) {
    const n = Wt([]);
    n.body = Zs(e, t), s.arguments[3] = n;
  }
  if (t.withSlotScopeId) {
    const n = s.arguments[6];
    s.arguments[6] = n ? `${n} + _scopeId` : "_scopeId";
  }
  t.pushStatement(e.ssrCodegenNode);
}
function ai(e, t) {
  return $e(e, t, kS);
}
const kS = { 65: "Unsafe attribute name for SSR.", 66: "Missing the 'to' prop on teleport element.", 67: "Invalid AST node during SSR transform." }, Ux = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), SS = (e, t) => {
  if (e.type === 1 && e.tagType === 0) return function() {
    const s = [`<${e.tag}`], n = e.tag === "textarea" || e.tag.indexOf("-") > 0, i = Sa(e), o = e.props.some((f) => f.type === 7 && !Up(f.name)), c = e.props.findIndex((f) => f.type === 7 && f.name === "show");
    if (c !== -1) {
      const f = e.props[c];
      e.props.splice(c, 1), e.props.push(f);
    }
    const l = i || o;
    if (l) {
      const { props: f, directives: x } = pn(e, t, e.props, !1, !1, !0);
      if (f || x.length) {
        const m = up(f, x, t), y = we(t.helper(Hh), [m]);
        if (e.tag === "textarea") {
          const v = e.children[0];
          if (!v || v.type !== 5) {
            const b = "_temp" + t.temps++;
            y.arguments = [oo(ue(b, !1), m)], Fn.set(e, we(t.helper($o), [or(ue(`"value" in ${b}`, !1), ue(`${b}.value`, !1), ue(v ? v.content : "", !0), !1)]));
          }
        } else if (e.tag === "input") {
          const v = (function(b) {
            return b.props.find((E) => E.type === 7 && E.name === "model" && E.exp);
          })(e);
          if (v) {
            const b = ue("_temp" + t.temps++, !1);
            y.arguments = [Qg([oo(b, m), we(t.helper(Es), [b, we(t.helper(Dx), [b, v.exp])])])];
          }
        } else if (x.length && !e.children.length && !rt(e, "text")) {
          const v = "_temp" + t.temps++;
          y.arguments = [oo(ue(v, !1), m)], Fn.set(e, or(ue(`"textContent" in ${v}`, !1), we(t.helper($o), [ue(`${v}.textContent`, !1)]), ue(`${v}.innerHTML ?? ''`, !1), !1));
        }
        n && y.arguments.push(`"${e.tag}"`), s.push(y);
      }
    }
    let p, d, g;
    for (let f = 0; f < e.props.length; f++) {
      const x = e.props[f];
      if (e.tag !== "input" || !ES(x)) if (x.type === 7) {
        if (x.name === "html" && x.exp) Fn.set(e, dt(["(", x.exp, ") ?? ''"]));
        else if (x.name === "text" && x.exp) e.children = [Po(x.exp, x.loc)];
        else if (x.name === "slot") t.onError($e(40, x.loc));
        else if (wS(e, x) && x.exp) l || (e.children = [Po(x.exp, x.loc)]);
        else if (!l && x.name !== "on") {
          const m = t.directiveTransforms[x.name];
          if (m) {
            const { props: y, ssrTagParts: v } = m(x, e, t);
            v && s.push(...v);
            for (let b = 0; b < y.length; b++) {
              const { key: E, value: w } = y[b];
              if (vt(E)) {
                let C = E.content;
                if (C === "key" || C === "ref") continue;
                C === "class" ? s.push(' class="', p = we(t.helper(Ix), [w]), '"') : C === "style" ? g ? kd(g, w) : s.push(' style="', g = we(t.helper(Nx), [w]), '"') : (C = e.tag.indexOf("-") > 0 ? C : XT[C] || C.toLowerCase(), Hg(C) ? s.push(or(we(t.helper(zh), [w]), ue(" " + C, !0), ue("", !0), !1)) : GT(C) ? s.push(we(t.helper(Ox), [E, w])) : t.onError(ai(65, E.loc)));
              } else {
                const C = [E, w];
                n && C.push(`"${e.tag}"`), s.push(we(t.helper(Lx), C));
              }
            }
          }
        }
      } else {
        const m = x.name;
        if (e.tag === "textarea" && m === "value" && x.value) Fn.set(e, ur(x.value.content));
        else if (!l) {
          if (m === "key" || m === "ref") continue;
          m === "class" && x.value && (d = JSON.stringify(x.value.content)), s.push(` ${x.name}` + (x.value ? `="${ur(x.value.content)}"` : ""));
        }
      }
    }
    p && d && (kd(p, d), (function(f, x) {
      const m = new RegExp(`^ ${x}=".+"$`), y = f.findIndex((v) => typeof v == "string" && m.test(v));
      y > -1 && f.splice(y, 1);
    })(s, "class")), t.scopeId && s.push(` ${t.scopeId}`), e.ssrCodegenNode = Xp(s);
  };
};
function up(e, t, s) {
  let n = [];
  if (e && (e.type === 14 ? n = e.arguments : n.push(e)), t.length) for (const i of t) n.push(we(s.helper(Bx), ["_ctx", ...dh(i, s).elements]));
  return n.length > 1 ? we(s.helper(Es), n) : n[0];
}
function ES(e) {
  return e.type === 7 ? e.name === "bind" && e.arg && vt(e.arg) && (e.arg.content === "true-value" || e.arg.content === "false-value") : e.name === "true-value" || e.name === "false-value";
}
function wS(e, t) {
  return !(e.tag !== "textarea" || t.name !== "bind" || !xr(t.arg, "value"));
}
function kd(e, t) {
  const s = e.arguments[0];
  s.type === 17 ? s.elements.push(t) : e.arguments[0] = Nr([s, t]);
}
function _S(e, t) {
  const s = t.options.isVoidTag || Dn, n = e.ssrCodegenNode.elements;
  for (let o = 0; o < n.length; o++) t.pushStringPart(n[o]);
  t.withSlotScopeId && t.pushStringPart(ue("_scopeId", !1)), t.pushStringPart(">");
  const i = Fn.get(e);
  i ? t.pushStringPart(i) : e.children.length && Pr(e, t), s(e.tag) || t.pushStringPart(`</${e.tag}>`);
}
const $x = /* @__PURE__ */ new WeakMap(), qx = /* @__PURE__ */ new WeakMap();
var PS = Object.defineProperty, AS = Object.defineProperties, CS = Object.getOwnPropertyDescriptors, Sd = Object.getOwnPropertySymbols, IS = Object.prototype.hasOwnProperty, NS = Object.prototype.propertyIsEnumerable, Ed = (e, t, s) => t in e ? PS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, fs = (e, t) => {
  for (var s in t || (t = {})) IS.call(t, s) && Ed(e, s, t[s]);
  if (Sd) for (var s of Sd(t)) NS.call(t, s) && Ed(e, s, t[s]);
  return e;
};
const Vx = /* @__PURE__ */ new WeakMap(), Hx = Symbol(), zx = /* @__PURE__ */ new WeakMap(), OS = (e, t) => {
  if (e.type !== 1 || e.tagType !== 1) return;
  const s = Pa(e, t, !0), n = ss(s) && s.callee === yi;
  if (zx.set(e, s), rs(s)) return s === dn ? /* @__PURE__ */ (function(c, l) {
    return () => {
      if (c.children.length) {
        const p = { slotsExp: null, wipSlots: [] };
        Ux.set(c, p), p.slotsExp = Un(c, l, (d, g, f, x) => {
          const m = Wt([], void 0, !0, !1, x);
          return p.wipSlots.push({ fn: m, children: f }), m;
        }).slots;
      }
    };
  })(e, t) : s === gn ? /* @__PURE__ */ (function(c, l) {
    return () => {
      const p = Ut(c, "tag");
      if (p) {
        const d = c.props.filter((m) => m !== p), { props: g, directives: f } = pn(c, l, d, !0, !1, !0);
        let x = null;
        (g || f.length) && (x = we(l.helper(Hh), [up(g, f, l)])), $x.set(c, { tag: p, propsExp: x, scopeId: l.scopeId || null });
      }
    };
  })(e, t) : s === Os ? /* @__PURE__ */ (function(c) {
    return () => {
      const l = Ut(c, "appear", !1, !0);
      qx.set(c, !!l);
    };
  })(e) : void 0;
  const i = [], o = dp(e);
  return function() {
    o.children.length && Un(o, t, (d, g, f) => (i.push((function(x, m, y, v) {
      const b = Wx.get(v.root), E = (C = fs({}, b), A = { nodeTransforms: [...DS, ...b.nodeTransforms || []], directiveTransforms: fs(fs({}, FS), b.directiveTransforms || {}) }, AS(C, CS(A))), w = [];
      var C, A;
      return x && w.push({ type: 7, name: "slot", exp: x, arg: void 0, modifiers: [], loc: tt }), m && w.push(kr({}, m)), (function(D, N, j) {
        const U = Ns([D]), X = Ti(U, N);
        X.ssr = !1, X.scopes = fs({}, j.scopes), X.identifiers = fs({}, j.identifiers), X.imports = j.imports, ln(U, X), ["helpers", "components", "directives"].forEach((W) => {
          X[W].forEach((H, F) => {
            if (W === "helpers") {
              const q = j.helpers.get(F);
              q === void 0 ? j.helpers.set(F, H) : j.helpers.set(F, H + q);
            } else j[W].add(H);
          });
        });
      })({ type: 1, ns: 0, tag: "template", tagType: 3, props: w, children: y, loc: tt, codegenNode: void 0 }, E, v), Zg(y);
    })(d, g, f, t)), Wt(void 0)));
    let c = "null";
    if (e.props.length) {
      const { props: d, directives: g } = pn(e, t, void 0, !0, n);
      (d || g.length) && (c = up(d, g, t));
    }
    const l = [];
    Vx.set(e, l);
    const p = e.children.length ? Un(e, t, (d, g, f, x) => {
      const m = Wt([d && _a(d) || "_", "_push", "_parent", "_scopeId"], void 0, !0, !0, x);
      return l.push({ type: Hx, fn: m, children: f, vnodeBranch: i[l.length] }), m;
    }).slots : "null";
    e.ssrCodegenNode = typeof s != "string" ? we(t.helper(_x), ["_push", we(t.helper(gi), [s, c, p]), "_parent"]) : we(t.helper(Px), [s, c, p, "_parent"]);
  };
};
function LS(e, t, s) {
  const n = zx.get(e);
  if (e.ssrCodegenNode) {
    const i = Vx.get(e) || [];
    for (let o = 0; o < i.length; o++) {
      const { fn: c, vnodeBranch: l } = i[o];
      c.body = Ao(ue("_push", !1), Zs(i[o], t, !1, !0), l);
    }
    t.withSlotScopeId && e.ssrCodegenNode.arguments.push("_scopeId"), typeof n == "string" ? t.pushStatement(we("_push", [e.ssrCodegenNode])) : t.pushStatement(e.ssrCodegenNode);
  } else {
    if (n === Ts) return (function(i, o) {
      const c = Ut(i, "to");
      if (!c) return void o.onError(ai(66, i.loc));
      let l;
      if (l = c.type === 6 ? c.value && ue(c.value.content, !0) : c.exp, !l) return void o.onError(ai(66, c.loc));
      const p = Ut(i, "disabled", !1, !0), d = p ? p.type === 6 ? "true" : p.exp || "false" : "false", g = Wt(["_push"], void 0, !0, !1, i.loc);
      g.body = Zs(i, o), o.pushStatement(we(o.helper(Fx), ["_push", g, l, d, "_parent"]));
    })(e, t);
    if (n === dn) return (function(i, o) {
      const c = Ux.get(i);
      if (!c) return;
      const { slotsExp: l, wipSlots: p } = c;
      for (let d = 0; d < p.length; d++) {
        const g = p[d];
        g.fn.body = Zs(g, o);
      }
      o.pushStatement(we(o.helper(jx), ["_push", l]));
    })(e, t);
    if (n === gn) return (function(i, o) {
      const c = $x.get(i);
      if (c) {
        const { tag: l, propsExp: p, scopeId: d } = c;
        l.type === 7 ? (o.pushStringPart("<"), o.pushStringPart(l.exp), p && o.pushStringPart(p), d && o.pushStringPart(` ${d}`), o.pushStringPart(">"), Pr(i, o, !1, !0, !0), o.pushStringPart("</"), o.pushStringPart(l.exp), o.pushStringPart(">")) : (o.pushStringPart(`<${l.value.content}`), p && o.pushStringPart(p), d && o.pushStringPart(` ${d}`), o.pushStringPart(">"), Pr(i, o, !1, !0, !0), o.pushStringPart(`</${l.value.content}>`));
      } else Pr(i, o, !0, !0, !0);
    })(e, t);
    if (s.type === Hx && t.pushStringPart(""), n === Os) return (function(i, o) {
      i.children = i.children.filter((c) => c.type !== 3), qx.get(i) ? (o.pushStringPart("<template>"), Pr(i, o, !1, !0), o.pushStringPart("</template>")) : Pr(i, o, !1, !0);
    })(e, t);
    Pr(e, t);
  }
}
const Wx = /* @__PURE__ */ new WeakMap(), [RS, MS] = yh(!0), DS = [...RS, ...rp], FS = fs(fs({}, MS), sp);
function dp(e) {
  if (gt(e)) return e.map(dp);
  if (Bg(e)) {
    const t = {};
    for (const s in e) t[s] = dp(e[s]);
    return t;
  }
  return e;
}
function Gx(e, t, s = /* @__PURE__ */ new Set(), n = !1) {
  const i = [];
  let o = null;
  return { root: e, options: t, body: i, helpers: s, withSlotScopeId: n, onError: t.onError || ((c) => {
    throw c;
  }), helper: (c) => (s.add(c), c), pushStringPart(c) {
    if (!o) {
      const d = we("_push");
      i.push(d), o = Xp([]), d.arguments.push(o);
    }
    const l = o.elements, p = l[l.length - 1];
    De(c) && De(p) ? l[l.length - 1] += c : l.push(c);
  }, pushStatement(c) {
    o = null, i.push(c);
  } };
}
function Pr(e, t, s = !1, n = !1, i = !1) {
  s && t.pushStringPart("<!--[-->");
  const { children: o } = e;
  for (let c = 0; c < o.length; c++) {
    const l = o[c];
    switch (l.type) {
      case 1:
        switch (l.tagType) {
          case 0:
            _S(l, t);
            break;
          case 1:
            LS(l, t, e);
            break;
          case 2:
            vS(l, t);
            break;
          case 3:
            break;
          default:
            return t.onError(ai(67, l.loc)), l;
        }
        break;
      case 2:
        t.pushStringPart(ur(l.content));
        break;
      case 3:
        i || t.pushStringPart(`<!--${l.content}-->`);
        break;
      case 5:
        t.pushStringPart(we(t.helper($o), [l.content]));
        break;
      case 9:
        yS(l, t, n, i);
        break;
      case 11:
        bS(l, t, n);
        break;
      case 10:
      case 12:
      case 8:
        break;
      default:
        return t.onError(ai(67, l.loc)), l;
    }
  }
  s && t.pushStringPart("<!--]-->");
}
function Zs(e, t, s = !1, n = t.withSlotScopeId) {
  const i = (function(o, c = o.withSlotScopeId) {
    return Gx(o.root, o.options, o.helpers, c);
  })(t, n);
  return Pr(e, i, s), bi(i.body);
}
const jS = (e, t, s) => {
  const n = e.exp;
  function i() {
    const c = Ut(t, "value");
    c && s.onError(At(60, c.loc));
  }
  const o = (c) => {
    c.forEach((l) => {
      l.type === 1 ? (function(p) {
        if (p.tag === "option") {
          if (p.props.findIndex((d) => d.name === "selected") === -1) {
            const d = wd(p);
            p.ssrCodegenNode.elements.push(or(we(s.helper(zh), [or(we("Array.isArray", [n]), we(s.helper(pp), [n, d]), we(s.helper(fo), [n, d]))]), ue(" selected", !0), ue("", !0), !1));
          }
        } else p.tag === "optgroup" && o(p.children);
      })(l) : l.type === 11 ? o(l.children) : l.type === 9 && l.branches.forEach((p) => o(p.children));
    });
  };
  if (t.tagType === 0) {
    const c = { props: [] }, l = [Ve("value", n)];
    if (t.tag === "input") {
      const p = Ut(t, "type");
      if (p) {
        const d = wd(t);
        if (p.type === 7) c.ssrTagParts = [we(s.helper(Mx), [p.exp, n, d])];
        else if (p.value) switch (p.value.content) {
          case "radio":
            c.props = [Ve("checked", we(s.helper(fo), [n, d]))];
            break;
          case "checkbox":
            const g = Ut(t, "true-value");
            if (g) {
              const f = g.type === 6 ? JSON.stringify(g.value.content) : g.exp;
              c.props = [Ve("checked", we(s.helper(fo), [n, f]))];
            } else c.props = [Ve("checked", or(we("Array.isArray", [n]), we(s.helper(pp), [n, d]), n))];
            break;
          case "file":
            s.onError(At(59, e.loc));
            break;
          default:
            i(), c.props = l;
        }
      } else Sa(t) || (i(), c.props = l);
    } else t.tag === "textarea" ? (i(), t.children = [Po(n, n.loc)]) : t.tag === "select" ? o(t.children) : s.onError(At(57, e.loc));
    return c;
  }
  return Ca(e, t, s);
};
function wd(e) {
  const t = Ut(e, "value");
  return t ? t.type === 7 ? t.exp : ue(t.value.content, !0) : ue("null", !1);
}
const BS = (e, t, s) => (e.exp || s.onError(At(61)), { props: [Ve("style", or(e.exp, ue("null", !1), Ft([Ve("display", ue("none", !0))]), !1))] }), fp = (e) => e.children.filter((t) => t.type !== 3), _c = (e) => fp(e).length === 1, US = (e, t) => {
  if (e.type === 0 && (t.identifiers._attrs = 1), e.type === 1 && e.tagType === 1 && (e.tag === "transition" || e.tag === "Transition" || e.tag === "KeepAlive" || e.tag === "keep-alive")) {
    const n = fp(t.root);
    if (n.length === 1 && n[0] === e) return void (_c(e) && Pc(e.children[0]));
  }
  const s = t.parent;
  if (s && s.type === 0) if (e.type === 10 && _c(e)) {
    let n = !1;
    for (const i of fp(s)) if (i.type === 9 || i.type === 1 && rt(i, "if")) {
      if (n) return;
      n = !0;
    } else if (!n || i.type !== 1 || !rt(i, /else/, !0)) return;
    Pc(e.children[0]);
  } else _c(s) && Pc(e);
};
function Pc(e) {
  e.type !== 1 || e.tagType !== 0 && e.tagType !== 1 || rt(e, "for") || e.props.push({ type: 7, name: "bind", arg: void 0, exp: ue("_attrs", !1), modifiers: [], loc: tt });
}
const $S = (e, t) => {
  if (!t.ssrCssVars) return;
  e.type === 0 && (t.identifiers._cssVars = 1);
  const s = t.parent;
  if (s && s.type === 0) if (e.type === 10) for (const n of e.children) qo(n);
  else qo(e);
};
function qo(e) {
  if (e.type === 1 && (e.tagType === 0 || e.tagType === 1) && !rt(e, "for")) if (e.tag === "suspense" || e.tag === "Suspense") for (const t of e.children) t.type === 1 && t.tagType === 3 ? t.children.forEach(qo) : qo(t);
  else e.props.push({ type: 7, name: "bind", arg: void 0, exp: ue("_cssVars", !1), modifiers: [], loc: tt });
}
var qS = Object.defineProperty, VS = Object.defineProperties, HS = Object.getOwnPropertyDescriptors, _d = Object.getOwnPropertySymbols, zS = Object.prototype.hasOwnProperty, WS = Object.prototype.propertyIsEnumerable, Pd = (e, t, s) => t in e ? qS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, Xi = (e, t) => {
  for (var s in t || (t = {})) zS.call(t, s) && Pd(e, s, t[s]);
  if (_d) for (var s of _d(t)) WS.call(t, s) && Pd(e, s, t[s]);
  return e;
}, Ad = (e, t) => VS(e, HS(t)), GS = Object.freeze({ __proto__: null, compile: function(e, t = {}) {
  t = Ad(Xi(Xi({}, t), Js), { ssr: !0, inSSR: !0, scopeId: t.mode === "function" ? null : t.scopeId, prefixIdentifiers: !0, cacheHandlers: !1, hoistStatic: !1 });
  const s = typeof e == "string" ? Oo(e, t) : e;
  return Wx.set(s, t), ih(s, Ad(Xi({}, t), { hoistStatic: !1, nodeTransforms: [gh, gS, xS, uh, ah, TS, US, $S, SS, OS, hh, wh, ...t.nodeTransforms || []], directiveTransforms: Xi({ bind: mh, on: Aa, model: jS, show: BS, cloak: $n, once: $n, memo: $n }, t.directiveTransforms || {}) })), (function(n, i) {
    const o = Gx(n, i);
    if (i.ssrCssVars) {
      const l = Ti(Ns([]), i), p = yt(ue(i.ssrCssVars, !1), l);
      o.body.push(dt(["const _cssVars = { style: ", p, "}"])), Array.from(l.helpers.keys()).forEach((d) => {
        n.helpers.add(d);
      });
    }
    const c = n.children.length > 1 && n.children.some((l) => !Bn(l));
    Pr(n, o, c), n.codegenNode = bi(o.body), n.ssrHelpers = Array.from(/* @__PURE__ */ new Set([...Array.from(n.helpers).filter((l) => l in hp), ...o.helpers])), n.helpers = new Set(Array.from(n.helpers).filter((l) => !(l in hp)));
  })(s, t), oh(s, t);
} }), XS = ba(Object.freeze({ __proto__: null, default: {} })), Wh = ba(xk), KS = ba(Gk);
const Cd = {};
function zn(e) {
  typeof process < "u" && process.env.NODE_ENV === "production" || Cd[e] || (Cd[e] = !0, Vo(e));
}
function Vo(e) {
  console.warn(`\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${e}\x1B[0m
`);
}
var JS = Object.defineProperty, YS = Object.defineProperties, QS = Object.getOwnPropertyDescriptors, Id = Object.getOwnPropertySymbols, ZS = Object.prototype.hasOwnProperty, eE = Object.prototype.propertyIsEnumerable, Nd = (e, t, s) => t in e ? JS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, Ho = (e, t) => {
  for (var s in t || (t = {})) ZS.call(t, s) && Nd(e, s, t[s]);
  if (Id) for (var s of Id(t)) eE.call(t, s) && Nd(e, s, t[s]);
  return e;
}, mp = (e, t) => YS(e, QS(t));
function tE({ source: e, filename: t, preprocessOptions: s }, n) {
  let i = "", o = null;
  if (n.render(e, Ho({ filename: t }, s), (c, l) => {
    c && (o = c), i = l;
  }), o) throw o;
  return i;
}
function Xx(e) {
  const { preprocessLang: t, preprocessCustomRequire: s } = e;
  if (t && !s) throw new Error("[@vue/compiler-sfc] Template preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor in the shape of { render(): string }.");
  const n = !!t && (s ? s(t) : void 0);
  if (!n) return t ? { code: "export default function render() {}", source: e.source, tips: [`Component ${e.filename} uses lang ${t} for template. Please install the language preprocessor.`], errors: [`Component ${e.filename} uses lang ${t} for template, however it is not installed.`] } : Od(e);
  try {
    return Od(mp(Ho({}, e), { source: tE(e, n), ast: void 0 }));
  } catch (i) {
    return { code: "export default function render() {}", source: e.source, tips: [], errors: [i] };
  }
}
function Od({ filename: e, id: t, scoped: s, slotted: n, inMap: i, source: o, ast: c, ssr: l = !1, ssrCssVars: p, isProd: d = !1, compiler: g, compilerOptions: f = {}, transformAssetUrls: x }) {
  const m = [], y = [];
  let v = [];
  if (ss(x)) {
    const U = uS(x);
    v = [(b = U, (X, W) => Td(X, W, b)), mS(U)];
  } else x !== !1 && (v = [Td, wx]);
  var b;
  l && !p && zn("compileTemplate is called with `ssr: true` but no corresponding `cssVars` option."), t || (zn("compileTemplate now requires the `id` option."), t = "");
  const E = t.replace(/^data-v-/, ""), w = `data-v-${E}`, C = l ? GS : np;
  if ((g = g || C) !== C && (c = void 0), c?.transformed) {
    const U = (l ? np : g).parse(c.source, mp(Ho({ prefixIdentifiers: !0 }, f), { parseMode: "sfc", onError: (X) => m.push(X) })).children.find((X) => X.type === 1 && X.tag === "template");
    c = Ns(U.children, c.source);
  }
  let { code: A, ast: O, preamble: D, map: N } = g.compile(c || o, mp(Ho({ mode: "module", prefixIdentifiers: !0, hoistStatic: !0, cacheHandlers: !0, ssrCssVars: l && p && p.length ? Ny(p, E, d, !0) : "", scopeId: s ? w : void 0, slotted: n, sourceMap: !0 }, f), { hmr: !d, nodeTransforms: v.concat(f.nodeTransforms || []), filename: e, onError: (U) => m.push(U), onWarn: (U) => y.push(U) }));
  i && !c && (N && (N = (function(U, X) {
    if (!U) return X;
    if (!X) return U;
    const W = new vs.SourceMapConsumer(U), H = new vs.SourceMapConsumer(X), F = new vs.SourceMapGenerator();
    H.eachMapping((G) => {
      if (G.originalLine == null) return;
      const ee = W.originalPositionFor({ line: G.originalLine, column: G.originalColumn });
      ee.source != null && F.addMapping({ generated: { line: G.generatedLine, column: G.generatedColumn }, original: { line: ee.line, column: G.originalColumn }, source: ee.source, name: ee.name });
    });
    const q = F;
    return W.sources.forEach((G) => {
      q._sources.add(G);
      const ee = W.sourceContentFor(G);
      ee != null && F.setSourceContent(G, ee);
    }), q._sourceRoot = U.sourceRoot, q._file = U.file, q.toJSON();
  })(i, N)), m.length && (function(U, X, W) {
    const H = W.sourcesContent[0], F = H.indexOf(X), q = H.slice(0, F).split(/\r?\n/).length - 1;
    U.forEach((G) => {
      G.loc && (G.loc.start.line += q, G.loc.start.offset += F, G.loc.end !== G.loc.start && (G.loc.end.line += q, G.loc.end.offset += F));
    });
  })(m, o, i));
  const j = y.map((U) => {
    let X = U.message;
    return U.loc && (X += `
${mi(c?.source || o, U.loc.start.offset, U.loc.end.offset)}`), X;
  });
  return { code: A, ast: O, preamble: D, source: o, errors: m, tips: j, map: N };
}
var Ld, Ac, Rd, Md, Dd, Cc, Fd, Ic, jd, Nc, Bd, Ki = { exports: {} };
function Kx() {
  if (Ld) return Ki.exports;
  Ld = 1;
  let e = $t || {}, t = e.argv || [], s = e.env || {}, n = !(s.NO_COLOR || t.includes("--no-color")) && (!!s.FORCE_COLOR || t.includes("--color") || e.platform === "win32" || (e.stdout || {}).isTTY && s.TERM !== "dumb" || !!s.CI), i = (l, p, d = l) => (g) => {
    let f = "" + g, x = f.indexOf(p, l.length);
    return ~x ? l + o(f, p, d, x) + p : l + f + p;
  }, o = (l, p, d, g) => {
    let f = "", x = 0;
    do
      f += l.substring(x, g) + d, x = g + p.length, g = l.indexOf(p, x);
    while (~g);
    return f + l.substring(x);
  }, c = (l = n) => {
    let p = l ? i : () => String;
    return { isColorSupported: l, reset: p("\x1B[0m", "\x1B[0m"), bold: p("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"), dim: p("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"), italic: p("\x1B[3m", "\x1B[23m"), underline: p("\x1B[4m", "\x1B[24m"), inverse: p("\x1B[7m", "\x1B[27m"), hidden: p("\x1B[8m", "\x1B[28m"), strikethrough: p("\x1B[9m", "\x1B[29m"), black: p("\x1B[30m", "\x1B[39m"), red: p("\x1B[31m", "\x1B[39m"), green: p("\x1B[32m", "\x1B[39m"), yellow: p("\x1B[33m", "\x1B[39m"), blue: p("\x1B[34m", "\x1B[39m"), magenta: p("\x1B[35m", "\x1B[39m"), cyan: p("\x1B[36m", "\x1B[39m"), white: p("\x1B[37m", "\x1B[39m"), gray: p("\x1B[90m", "\x1B[39m"), bgBlack: p("\x1B[40m", "\x1B[49m"), bgRed: p("\x1B[41m", "\x1B[49m"), bgGreen: p("\x1B[42m", "\x1B[49m"), bgYellow: p("\x1B[43m", "\x1B[49m"), bgBlue: p("\x1B[44m", "\x1B[49m"), bgMagenta: p("\x1B[45m", "\x1B[49m"), bgCyan: p("\x1B[46m", "\x1B[49m"), bgWhite: p("\x1B[47m", "\x1B[49m"), blackBright: p("\x1B[90m", "\x1B[39m"), redBright: p("\x1B[91m", "\x1B[39m"), greenBright: p("\x1B[92m", "\x1B[39m"), yellowBright: p("\x1B[93m", "\x1B[39m"), blueBright: p("\x1B[94m", "\x1B[39m"), magentaBright: p("\x1B[95m", "\x1B[39m"), cyanBright: p("\x1B[96m", "\x1B[39m"), whiteBright: p("\x1B[97m", "\x1B[39m"), bgBlackBright: p("\x1B[100m", "\x1B[49m"), bgRedBright: p("\x1B[101m", "\x1B[49m"), bgGreenBright: p("\x1B[102m", "\x1B[49m"), bgYellowBright: p("\x1B[103m", "\x1B[49m"), bgBlueBright: p("\x1B[104m", "\x1B[49m"), bgMagentaBright: p("\x1B[105m", "\x1B[49m"), bgCyanBright: p("\x1B[106m", "\x1B[49m"), bgWhiteBright: p("\x1B[107m", "\x1B[49m") };
  };
  return Ki.exports = c(), Ki.exports.createColors = c, Ki.exports;
}
function Jx() {
  if (Rd) return Ac;
  Rd = 1;
  const e = 39, t = 34, s = 92, n = 47, i = 10, o = 32, c = 12, l = 9, p = 13, d = 91, g = 93, f = 40, x = 41, m = 123, y = 125, v = 59, b = 42, E = 58, w = 64, C = /[\t\n\f\r "#'()/;[\\\]{}]/g, A = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, O = /.[\r\n"'(/\\]/, D = /[\da-f]/i;
  return Ac = function(N, j = {}) {
    let U, X, W, H, F, q, G, ee, ce, Te, Q = N.css.valueOf(), pe = j.ignoreErrors, J = Q.length, $ = 0, oe = [], Y = [];
    function se(z) {
      throw N.error("Unclosed " + z, $);
    }
    return { back: function(z) {
      Y.push(z);
    }, endOfFile: function() {
      return Y.length === 0 && $ >= J;
    }, nextToken: function(z) {
      if (Y.length) return Y.pop();
      if ($ >= J) return;
      let ie = !!z && z.ignoreUnclosed;
      switch (U = Q.charCodeAt($), U) {
        case i:
        case o:
        case l:
        case p:
        case c:
          H = $;
          do
            H += 1, U = Q.charCodeAt(H);
          while (U === o || U === i || U === l || U === p || U === c);
          q = ["space", Q.slice($, H)], $ = H - 1;
          break;
        case d:
        case g:
        case m:
        case y:
        case E:
        case v:
        case x: {
          let ae = String.fromCharCode(U);
          q = [ae, ae, $];
          break;
        }
        case f:
          if (Te = oe.length ? oe.pop()[1] : "", ce = Q.charCodeAt($ + 1), Te === "url" && ce !== e && ce !== t && ce !== o && ce !== i && ce !== l && ce !== c && ce !== p) {
            H = $;
            do {
              if (G = !1, H = Q.indexOf(")", H + 1), H === -1) {
                if (pe || ie) {
                  H = $;
                  break;
                }
                se("bracket");
              }
              for (ee = H; Q.charCodeAt(ee - 1) === s; ) ee -= 1, G = !G;
            } while (G);
            q = ["brackets", Q.slice($, H + 1), $, H], $ = H;
          } else H = Q.indexOf(")", $ + 1), X = Q.slice($, H + 1), H === -1 || O.test(X) ? q = ["(", "(", $] : (q = ["brackets", X, $, H], $ = H);
          break;
        case e:
        case t:
          F = U === e ? "'" : '"', H = $;
          do {
            if (G = !1, H = Q.indexOf(F, H + 1), H === -1) {
              if (pe || ie) {
                H = $ + 1;
                break;
              }
              se("string");
            }
            for (ee = H; Q.charCodeAt(ee - 1) === s; ) ee -= 1, G = !G;
          } while (G);
          q = ["string", Q.slice($, H + 1), $, H], $ = H;
          break;
        case w:
          C.lastIndex = $ + 1, C.test(Q), H = C.lastIndex === 0 ? Q.length - 1 : C.lastIndex - 2, q = ["at-word", Q.slice($, H + 1), $, H], $ = H;
          break;
        case s:
          for (H = $, W = !0; Q.charCodeAt(H + 1) === s; ) H += 1, W = !W;
          if (U = Q.charCodeAt(H + 1), W && U !== n && U !== o && U !== i && U !== l && U !== p && U !== c && (H += 1, D.test(Q.charAt(H)))) {
            for (; D.test(Q.charAt(H + 1)); ) H += 1;
            Q.charCodeAt(H + 1) === o && (H += 1);
          }
          q = ["word", Q.slice($, H + 1), $, H], $ = H;
          break;
        default:
          U === n && Q.charCodeAt($ + 1) === b ? (H = Q.indexOf("*/", $ + 2) + 1, H === 0 && (pe || ie ? H = Q.length : se("comment")), q = ["comment", Q.slice($, H + 1), $, H], $ = H) : (A.lastIndex = $ + 1, A.test(Q), H = A.lastIndex === 0 ? Q.length - 1 : A.lastIndex - 2, q = ["word", Q.slice($, H + 1), $, H], oe.push(q), $ = H);
      }
      return $++, q;
    }, position: function() {
      return $;
    } };
  }, Ac;
}
function Yx() {
  if (Dd) return Md;
  Dd = 1;
  let e, t = Kx(), s = Jx();
  const n = { ";": t.yellow, ":": t.yellow, "(": t.cyan, ")": t.cyan, "[": t.yellow, "]": t.yellow, "{": t.yellow, "}": t.yellow, "at-word": t.cyan, brackets: t.cyan, call: t.cyan, class: t.yellow, comment: t.gray, hash: t.magenta, string: t.green };
  function i([c, l], p) {
    if (c === "word") {
      if (l[0] === ".") return "class";
      if (l[0] === "#") return "hash";
    }
    if (!p.endOfFile()) {
      let d = p.nextToken();
      if (p.back(d), d[0] === "brackets" || d[0] === "(") return "call";
    }
    return c;
  }
  function o(c) {
    let l = s(new e(c), { ignoreErrors: !0 }), p = "";
    for (; !l.endOfFile(); ) {
      let d = l.nextToken(), g = n[i(d, l)];
      p += g ? d[1].split(/\r?\n/).map((f) => g(f)).join(`
`) : d[1];
    }
    return p;
  }
  return o.registerInput = function(c) {
    e = c;
  }, Md = o;
}
function Gh() {
  if (Fd) return Cc;
  Fd = 1;
  let e = Kx(), t = Yx();
  class s extends Error {
    constructor(i, o, c, l, p, d) {
      super(i), this.name = "CssSyntaxError", this.reason = i, p && (this.file = p), l && (this.source = l), d && (this.plugin = d), o !== void 0 && c !== void 0 && (typeof o == "number" ? (this.line = o, this.column = c) : (this.line = o.line, this.column = o.column, this.endLine = c.line, this.endColumn = c.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, s);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(i) {
      if (!this.source) return "";
      let o = this.source;
      i == null && (i = e.isColorSupported);
      let c = (m) => m, l = (m) => m, p = (m) => m;
      if (i) {
        let { bold: m, gray: y, red: v } = e.createColors(!0);
        l = (b) => m(v(b)), c = (b) => y(b), t && (p = (b) => t(b));
      }
      let d = o.split(/\r?\n/), g = Math.max(this.line - 3, 0), f = Math.min(this.line + 2, d.length), x = String(f).length;
      return d.slice(g, f).map((m, y) => {
        let v = g + 1 + y, b = " " + (" " + v).slice(-x) + " | ";
        if (v === this.line) {
          if (m.length > 160) {
            let w = 20, C = Math.max(0, this.column - w), A = Math.max(this.column + w, this.endColumn + w), O = m.slice(C, A), D = c(b.replace(/\d/g, " ")) + m.slice(0, Math.min(this.column - 1, w - 1)).replace(/[^\t]/g, " ");
            return l(">") + c(b) + p(O) + `
 ` + D + l("^");
          }
          let E = c(b.replace(/\d/g, " ")) + m.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return l(">") + c(b) + p(m) + `
 ` + E + l("^");
        }
        return " " + c(b) + p(m);
      }).join(`
`);
    }
    toString() {
      let i = this.showSourceCode();
      return i && (i = `

` + i + `
`), this.name + ": " + this.message + i;
    }
  }
  return Cc = s, s.default = s, Cc;
}
function Qx() {
  if (jd) return Ic;
  jd = 1;
  const e = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  class t {
    constructor(n) {
      this.builder = n;
    }
    atrule(n, i) {
      let o = "@" + n.name, c = n.params ? this.rawValue(n, "params") : "";
      if (n.raws.afterName !== void 0 ? o += n.raws.afterName : c && (o += " "), n.nodes) this.block(n, o + c);
      else {
        let l = (n.raws.between || "") + (i ? ";" : "");
        this.builder(o + c + l, n);
      }
    }
    beforeAfter(n, i) {
      let o;
      o = n.type === "decl" ? this.raw(n, null, "beforeDecl") : n.type === "comment" ? this.raw(n, null, "beforeComment") : i === "before" ? this.raw(n, null, "beforeRule") : this.raw(n, null, "beforeClose");
      let c = n.parent, l = 0;
      for (; c && c.type !== "root"; ) l += 1, c = c.parent;
      if (o.includes(`
`)) {
        let p = this.raw(n, null, "indent");
        if (p.length) for (let d = 0; d < l; d++) o += p;
      }
      return o;
    }
    block(n, i) {
      let o, c = this.raw(n, "between", "beforeOpen");
      this.builder(i + c + "{", n, "start"), n.nodes && n.nodes.length ? (this.body(n), o = this.raw(n, "after")) : o = this.raw(n, "after", "emptyBody"), o && this.builder(o), this.builder("}", n, "end");
    }
    body(n) {
      let i = n.nodes.length - 1;
      for (; i > 0 && n.nodes[i].type === "comment"; ) i -= 1;
      let o = this.raw(n, "semicolon");
      for (let c = 0; c < n.nodes.length; c++) {
        let l = n.nodes[c], p = this.raw(l, "before");
        p && this.builder(p), this.stringify(l, i !== c || o);
      }
    }
    comment(n) {
      let i = this.raw(n, "left", "commentLeft"), o = this.raw(n, "right", "commentRight");
      this.builder("/*" + i + n.text + o + "*/", n);
    }
    decl(n, i) {
      let o = this.raw(n, "between", "colon"), c = n.prop + o + this.rawValue(n, "value");
      n.important && (c += n.raws.important || " !important"), i && (c += ";"), this.builder(c, n);
    }
    document(n) {
      this.body(n);
    }
    raw(n, i, o) {
      let c;
      if (o || (o = i), i && (c = n.raws[i], c !== void 0)) return c;
      let l = n.parent;
      if (o === "before" && (!l || l.type === "root" && l.first === n || l && l.type === "document"))
        return "";
      if (!l) return e[o];
      let p = n.root();
      if (p.rawCache || (p.rawCache = {}), p.rawCache[o] !== void 0) return p.rawCache[o];
      if (o === "before" || o === "after") return this.beforeAfter(n, o);
      {
        let g = "raw" + ((d = o)[0].toUpperCase() + d.slice(1));
        this[g] ? c = this[g](p, n) : p.walk((f) => {
          if (c = f.raws[i], c !== void 0) return !1;
        });
      }
      var d;
      return c === void 0 && (c = e[o]), p.rawCache[o] = c, c;
    }
    rawBeforeClose(n) {
      let i;
      return n.walk((o) => {
        if (o.nodes && o.nodes.length > 0 && o.raws.after !== void 0) return i = o.raws.after, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
      }), i && (i = i.replace(/\S/g, "")), i;
    }
    rawBeforeComment(n, i) {
      let o;
      return n.walkComments((c) => {
        if (c.raws.before !== void 0) return o = c.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o === void 0 ? o = this.raw(i, null, "beforeDecl") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeDecl(n, i) {
      let o;
      return n.walkDecls((c) => {
        if (c.raws.before !== void 0) return o = c.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o === void 0 ? o = this.raw(i, null, "beforeRule") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeOpen(n) {
      let i;
      return n.walk((o) => {
        if (o.type !== "decl" && (i = o.raws.between, i !== void 0)) return !1;
      }), i;
    }
    rawBeforeRule(n) {
      let i;
      return n.walk((o) => {
        if (o.nodes && (o.parent !== n || n.first !== o) && o.raws.before !== void 0) return i = o.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
      }), i && (i = i.replace(/\S/g, "")), i;
    }
    rawColon(n) {
      let i;
      return n.walkDecls((o) => {
        if (o.raws.between !== void 0) return i = o.raws.between.replace(/[^\s:]/g, ""), !1;
      }), i;
    }
    rawEmptyBody(n) {
      let i;
      return n.walk((o) => {
        if (o.nodes && o.nodes.length === 0 && (i = o.raws.after, i !== void 0)) return !1;
      }), i;
    }
    rawIndent(n) {
      if (n.raws.indent) return n.raws.indent;
      let i;
      return n.walk((o) => {
        let c = o.parent;
        if (c && c !== n && c.parent && c.parent === n && o.raws.before !== void 0) {
          let l = o.raws.before.split(`
`);
          return i = l[l.length - 1], i = i.replace(/\S/g, ""), !1;
        }
      }), i;
    }
    rawSemicolon(n) {
      let i;
      return n.walk((o) => {
        if (o.nodes && o.nodes.length && o.last.type === "decl" && (i = o.raws.semicolon, i !== void 0)) return !1;
      }), i;
    }
    rawValue(n, i) {
      let o = n[i], c = n.raws[i];
      return c && c.value === o ? c.raw : o;
    }
    root(n) {
      this.body(n), n.raws.after && this.builder(n.raws.after);
    }
    rule(n) {
      this.block(n, this.rawValue(n, "selector")), n.raws.ownSemicolon && this.builder(n.raws.ownSemicolon, n, "end");
    }
    stringify(n, i) {
      if (!this[n.type]) throw new Error("Unknown AST node type " + n.type + ". Maybe you need to change PostCSS stringifier.");
      this[n.type](n, i);
    }
  }
  return Ic = t, t.default = t, Ic;
}
function La() {
  if (Bd) return Nc;
  Bd = 1;
  let e = Qx();
  function t(s, n) {
    new e(n).stringify(s);
  }
  return Nc = t, t.default = t, Nc;
}
var Ud, Oc, $d, Lc, qd, Rc, Vd, Mc, Hd, Dc, zd, Fc, Wd, jc, Gd, Bc = {};
function Xh() {
  return Ud || (Ud = 1, Bc.isClean = Symbol("isClean"), Bc.my = Symbol("my")), Bc;
}
function Ra() {
  if ($d) return Oc;
  $d = 1;
  let e = Gh(), t = Qx(), s = La(), { isClean: n, my: i } = Xh();
  function o(p, d) {
    let g = new p.constructor();
    for (let f in p) {
      if (!Object.prototype.hasOwnProperty.call(p, f) || f === "proxyCache") continue;
      let x = p[f], m = typeof x;
      f === "parent" && m === "object" ? d && (g[f] = d) : f === "source" ? g[f] = x : Array.isArray(x) ? g[f] = x.map((y) => o(y, g)) : (m === "object" && x !== null && (x = o(x)), g[f] = x);
    }
    return g;
  }
  function c(p, d) {
    if (d && d.offset !== void 0) return d.offset;
    let g = 1, f = 1, x = 0;
    for (let m = 0; m < p.length; m++) {
      if (f === d.line && g === d.column) {
        x = m;
        break;
      }
      p[m] === `
` ? (g = 1, f += 1) : g += 1;
    }
    return x;
  }
  class l {
    get proxyOf() {
      return this;
    }
    constructor(d = {}) {
      this.raws = {}, this[n] = !1, this[i] = !0;
      for (let g in d) if (g === "nodes") {
        this.nodes = [];
        for (let f of d[g]) typeof f.clone == "function" ? this.append(f.clone()) : this.append(f);
      } else this[g] = d[g];
    }
    addToError(d) {
      if (d.postcssNode = this, d.stack && this.source && /\n\s{4}at /.test(d.stack)) {
        let g = this.source;
        d.stack = d.stack.replace(/\n\s{4}at /, `$&${g.input.from}:${g.start.line}:${g.start.column}$&`);
      }
      return d;
    }
    after(d) {
      return this.parent.insertAfter(this, d), this;
    }
    assign(d = {}) {
      for (let g in d) this[g] = d[g];
      return this;
    }
    before(d) {
      return this.parent.insertBefore(this, d), this;
    }
    cleanRaws(d) {
      delete this.raws.before, delete this.raws.after, d || delete this.raws.between;
    }
    clone(d = {}) {
      let g = o(this);
      for (let f in d) g[f] = d[f];
      return g;
    }
    cloneAfter(d = {}) {
      let g = this.clone(d);
      return this.parent.insertAfter(this, g), g;
    }
    cloneBefore(d = {}) {
      let g = this.clone(d);
      return this.parent.insertBefore(this, g), g;
    }
    error(d, g = {}) {
      if (this.source) {
        let { end: f, start: x } = this.rangeBy(g);
        return this.source.input.error(d, { column: x.column, line: x.line }, { column: f.column, line: f.line }, g);
      }
      return new e(d);
    }
    getProxyProcessor() {
      return { get: (d, g) => g === "proxyOf" ? d : g === "root" ? () => d.root().toProxy() : d[g], set: (d, g, f) => (d[g] === f || (d[g] = f, g !== "prop" && g !== "value" && g !== "name" && g !== "params" && g !== "important" && g !== "text" || d.markDirty()), !0) };
    }
    markClean() {
      this[n] = !0;
    }
    markDirty() {
      if (this[n]) {
        this[n] = !1;
        let d = this;
        for (; d = d.parent; ) d[n] = !1;
      }
    }
    next() {
      if (!this.parent) return;
      let d = this.parent.index(this);
      return this.parent.nodes[d + 1];
    }
    positionBy(d = {}) {
      let g = this.source.start;
      if (d.index) g = this.positionInside(d.index);
      else if (d.word) {
        let f = "document" in this.source.input ? this.source.input.document : this.source.input.css, x = f.slice(c(f, this.source.start), c(f, this.source.end)).indexOf(d.word);
        x !== -1 && (g = this.positionInside(x));
      }
      return g;
    }
    positionInside(d) {
      let g = this.source.start.column, f = this.source.start.line, x = "document" in this.source.input ? this.source.input.document : this.source.input.css, m = c(x, this.source.start), y = m + d;
      for (let v = m; v < y; v++) x[v] === `
` ? (g = 1, f += 1) : g += 1;
      return { column: g, line: f, offset: y };
    }
    prev() {
      if (!this.parent) return;
      let d = this.parent.index(this);
      return this.parent.nodes[d - 1];
    }
    rangeBy(d = {}) {
      let g = "document" in this.source.input ? this.source.input.document : this.source.input.css, f = { column: this.source.start.column, line: this.source.start.line, offset: c(g, this.source.start) }, x = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line, offset: typeof this.source.end.offset == "number" ? this.source.end.offset : c(g, this.source.end) + 1 } : { column: f.column + 1, line: f.line, offset: f.offset + 1 };
      if (d.word) {
        let m = g.slice(c(g, this.source.start), c(g, this.source.end)).indexOf(d.word);
        m !== -1 && (f = this.positionInside(m), x = this.positionInside(m + d.word.length));
      } else d.start ? f = { column: d.start.column, line: d.start.line, offset: c(g, d.start) } : d.index && (f = this.positionInside(d.index)), d.end ? x = { column: d.end.column, line: d.end.line, offset: c(g, d.end) } : typeof d.endIndex == "number" ? x = this.positionInside(d.endIndex) : d.index && (x = this.positionInside(d.index + 1));
      return (x.line < f.line || x.line === f.line && x.column <= f.column) && (x = { column: f.column + 1, line: f.line, offset: f.offset + 1 }), { end: x, start: f };
    }
    raw(d, g) {
      return new t().raw(this, d, g);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...d) {
      if (this.parent) {
        let g = this, f = !1;
        for (let x of d) x === this ? f = !0 : f ? (this.parent.insertAfter(g, x), g = x) : this.parent.insertBefore(g, x);
        f || this.remove();
      }
      return this;
    }
    root() {
      let d = this;
      for (; d.parent && d.parent.type !== "document"; ) d = d.parent;
      return d;
    }
    toJSON(d, g) {
      let f = {}, x = g == null;
      g = g || /* @__PURE__ */ new Map();
      let m = 0;
      for (let y in this) {
        if (!Object.prototype.hasOwnProperty.call(this, y) || y === "parent" || y === "proxyCache") continue;
        let v = this[y];
        if (Array.isArray(v)) f[y] = v.map((b) => typeof b == "object" && b.toJSON ? b.toJSON(null, g) : b);
        else if (typeof v == "object" && v.toJSON) f[y] = v.toJSON(null, g);
        else if (y === "source") {
          if (v == null) continue;
          let b = g.get(v.input);
          b == null && (b = m, g.set(v.input, m), m++), f[y] = { end: v.end, inputId: b, start: v.start };
        } else f[y] = v;
      }
      return x && (f.inputs = [...g.keys()].map((y) => y.toJSON())), f;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(d = s) {
      d.stringify && (d = d.stringify);
      let g = "";
      return d(this, (f) => {
        g += f;
      }), g;
    }
    warn(d, g, f = {}) {
      let x = { node: this };
      for (let m in f) x[m] = f[m];
      return d.warn(g, x);
    }
  }
  return Oc = l, l.default = l, Oc;
}
function Ma() {
  if (qd) return Lc;
  qd = 1;
  let e = Ra();
  class t extends e {
    constructor(n) {
      super(n), this.type = "comment";
    }
  }
  return Lc = t, t.default = t, Lc;
}
function Da() {
  if (Vd) return Rc;
  Vd = 1;
  let e = Ra();
  class t extends e {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(n) {
      n && n.value !== void 0 && typeof n.value != "string" && (n = { ...n, value: String(n.value) }), super(n), this.type = "decl";
    }
  }
  return Rc = t, t.default = t, Rc;
}
function Rs() {
  if (Hd) return Mc;
  Hd = 1;
  let e, t, s, n, i = Ma(), o = Da(), c = Ra(), { isClean: l, my: p } = Xh();
  function d(x) {
    return x.map((m) => (m.nodes && (m.nodes = d(m.nodes)), delete m.source, m));
  }
  function g(x) {
    if (x[l] = !1, x.proxyOf.nodes) for (let m of x.proxyOf.nodes) g(m);
  }
  class f extends c {
    get first() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...m) {
      for (let y of m) {
        let v = this.normalize(y, this.last);
        for (let b of v) this.proxyOf.nodes.push(b);
      }
      return this.markDirty(), this;
    }
    cleanRaws(m) {
      if (super.cleanRaws(m), this.nodes) for (let y of this.nodes) y.cleanRaws(m);
    }
    each(m) {
      if (!this.proxyOf.nodes) return;
      let y, v, b = this.getIterator();
      for (; this.indexes[b] < this.proxyOf.nodes.length && (y = this.indexes[b], v = m(this.proxyOf.nodes[y], y), v !== !1); ) this.indexes[b] += 1;
      return delete this.indexes[b], v;
    }
    every(m) {
      return this.nodes.every(m);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let m = this.lastEach;
      return this.indexes[m] = 0, m;
    }
    getProxyProcessor() {
      return { get: (m, y) => y === "proxyOf" ? m : m[y] ? y === "each" || typeof y == "string" && y.startsWith("walk") ? (...v) => m[y](...v.map((b) => typeof b == "function" ? (E, w) => b(E.toProxy(), w) : b)) : y === "every" || y === "some" ? (v) => m[y]((b, ...E) => v(b.toProxy(), ...E)) : y === "root" ? () => m.root().toProxy() : y === "nodes" ? m.nodes.map((v) => v.toProxy()) : y === "first" || y === "last" ? m[y].toProxy() : m[y] : m[y], set: (m, y, v) => (m[y] === v || (m[y] = v, y !== "name" && y !== "params" && y !== "selector" || m.markDirty()), !0) };
    }
    index(m) {
      return typeof m == "number" ? m : (m.proxyOf && (m = m.proxyOf), this.proxyOf.nodes.indexOf(m));
    }
    insertAfter(m, y) {
      let v, b = this.index(m), E = this.normalize(y, this.proxyOf.nodes[b]).reverse();
      b = this.index(m);
      for (let w of E) this.proxyOf.nodes.splice(b + 1, 0, w);
      for (let w in this.indexes) v = this.indexes[w], b < v && (this.indexes[w] = v + E.length);
      return this.markDirty(), this;
    }
    insertBefore(m, y) {
      let v, b = this.index(m), E = b === 0 && "prepend", w = this.normalize(y, this.proxyOf.nodes[b], E).reverse();
      b = this.index(m);
      for (let C of w) this.proxyOf.nodes.splice(b, 0, C);
      for (let C in this.indexes) v = this.indexes[C], b <= v && (this.indexes[C] = v + w.length);
      return this.markDirty(), this;
    }
    normalize(m, y) {
      if (typeof m == "string") m = d(t(m).nodes);
      else if (m === void 0) m = [];
      else if (Array.isArray(m)) {
        m = m.slice(0);
        for (let v of m) v.parent && v.parent.removeChild(v, "ignore");
      } else if (m.type === "root" && this.type !== "document") {
        m = m.nodes.slice(0);
        for (let v of m) v.parent && v.parent.removeChild(v, "ignore");
      } else if (m.type) m = [m];
      else if (m.prop) {
        if (m.value === void 0) throw new Error("Value field is missed in node creation");
        typeof m.value != "string" && (m.value = String(m.value)), m = [new o(m)];
      } else if (m.selector || m.selectors) m = [new n(m)];
      else if (m.name) m = [new e(m)];
      else {
        if (!m.text) throw new Error("Unknown node type in node creation");
        m = [new i(m)];
      }
      return m.map((v) => (v[p] || f.rebuild(v), (v = v.proxyOf).parent && v.parent.removeChild(v), v[l] && g(v), v.raws || (v.raws = {}), v.raws.before === void 0 && y && y.raws.before !== void 0 && (v.raws.before = y.raws.before.replace(/\S/g, "")), v.parent = this.proxyOf, v));
    }
    prepend(...m) {
      m = m.reverse();
      for (let y of m) {
        let v = this.normalize(y, this.first, "prepend").reverse();
        for (let b of v) this.proxyOf.nodes.unshift(b);
        for (let b in this.indexes) this.indexes[b] = this.indexes[b] + v.length;
      }
      return this.markDirty(), this;
    }
    push(m) {
      return m.parent = this, this.proxyOf.nodes.push(m), this;
    }
    removeAll() {
      for (let m of this.proxyOf.nodes) m.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(m) {
      let y;
      m = this.index(m), this.proxyOf.nodes[m].parent = void 0, this.proxyOf.nodes.splice(m, 1);
      for (let v in this.indexes) y = this.indexes[v], y >= m && (this.indexes[v] = y - 1);
      return this.markDirty(), this;
    }
    replaceValues(m, y, v) {
      return v || (v = y, y = {}), this.walkDecls((b) => {
        y.props && !y.props.includes(b.prop) || y.fast && !b.value.includes(y.fast) || (b.value = b.value.replace(m, v));
      }), this.markDirty(), this;
    }
    some(m) {
      return this.nodes.some(m);
    }
    walk(m) {
      return this.each((y, v) => {
        let b;
        try {
          b = m(y, v);
        } catch (E) {
          throw y.addToError(E);
        }
        return b !== !1 && y.walk && (b = y.walk(m)), b;
      });
    }
    walkAtRules(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, b) => {
        if (v.type === "atrule" && m.test(v.name)) return y(v, b);
      }) : this.walk((v, b) => {
        if (v.type === "atrule" && v.name === m) return y(v, b);
      }) : (y = m, this.walk((v, b) => {
        if (v.type === "atrule") return y(v, b);
      }));
    }
    walkComments(m) {
      return this.walk((y, v) => {
        if (y.type === "comment") return m(y, v);
      });
    }
    walkDecls(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, b) => {
        if (v.type === "decl" && m.test(v.prop)) return y(v, b);
      }) : this.walk((v, b) => {
        if (v.type === "decl" && v.prop === m) return y(v, b);
      }) : (y = m, this.walk((v, b) => {
        if (v.type === "decl") return y(v, b);
      }));
    }
    walkRules(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, b) => {
        if (v.type === "rule" && m.test(v.selector)) return y(v, b);
      }) : this.walk((v, b) => {
        if (v.type === "rule" && v.selector === m) return y(v, b);
      }) : (y = m, this.walk((v, b) => {
        if (v.type === "rule") return y(v, b);
      }));
    }
  }
  return f.registerParse = (x) => {
    t = x;
  }, f.registerRule = (x) => {
    n = x;
  }, f.registerAtRule = (x) => {
    e = x;
  }, f.registerRoot = (x) => {
    s = x;
  }, Mc = f, f.default = f, f.rebuild = (x) => {
    x.type === "atrule" ? Object.setPrototypeOf(x, e.prototype) : x.type === "rule" ? Object.setPrototypeOf(x, n.prototype) : x.type === "decl" ? Object.setPrototypeOf(x, o.prototype) : x.type === "comment" ? Object.setPrototypeOf(x, i.prototype) : x.type === "root" && Object.setPrototypeOf(x, s.prototype), x[p] = !0, x.nodes && x.nodes.forEach((m) => {
      f.rebuild(m);
    });
  }, Mc;
}
function Kh() {
  if (zd) return Dc;
  zd = 1;
  let e = Rs();
  class t extends e {
    constructor(n) {
      super(n), this.type = "atrule";
    }
    append(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...n);
    }
    prepend(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...n);
    }
  }
  return Dc = t, t.default = t, e.registerAtRule(t), Dc;
}
function Jh() {
  if (Wd) return Fc;
  Wd = 1;
  let e, t, s = Rs();
  class n extends s {
    constructor(o) {
      super({ type: "document", ...o }), this.nodes || (this.nodes = []);
    }
    toResult(o = {}) {
      return new e(new t(), this, o).stringify();
    }
  }
  return n.registerLazyResult = (i) => {
    e = i;
  }, n.registerProcessor = (i) => {
    t = i;
  }, Fc = n, n.default = n, Fc;
}
function rE() {
  return Gd ? jc : (Gd = 1, jc = { nanoid: (e = 21) => {
    let t = "", s = 0 | e;
    for (; s--; ) t += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[64 * Math.random() | 0];
    return t;
  }, customAlphabet: (e, t = 21) => (s = t) => {
    let n = "", i = 0 | s;
    for (; i--; ) n += e[Math.random() * e.length | 0];
    return n;
  } }, jc);
}
var Uc, Xd, $c, Kd, qc, Jd, Vc, Yd, Hc, Qd, zc, Zd, Wc, ef, Gc, tf, Xc, rf, Kc, sf, Jc, nf, of, af, Yc, cf, Qc, lf, Zc, pf, el, hf, Zx = ba(nS);
function eb() {
  if (Xd) return Uc;
  Xd = 1;
  let { existsSync: e, readFileSync: t } = XS, { dirname: s, join: n } = Wh, { SourceMapConsumer: i, SourceMapGenerator: o } = wa();
  class c {
    constructor(p, d) {
      if (d.map === !1) return;
      this.loadAnnotation(p), this.inline = this.startWith(this.annotation, "data:");
      let g = d.map ? d.map.prev : void 0, f = this.loadMap(d.from, g);
      !this.mapFile && d.from && (this.mapFile = d.from), this.mapFile && (this.root = s(this.mapFile)), f && (this.text = f);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new i(this.text)), this.consumerCache;
    }
    decodeInline(p) {
      let d = p.match(/^data:application\/json;charset=utf-?8,/) || p.match(/^data:application\/json,/);
      if (d) return decodeURIComponent(p.substr(d[0].length));
      let g = p.match(/^data:application\/json;charset=utf-?8;base64,/) || p.match(/^data:application\/json;base64,/);
      if (g) return f = p.substr(g[0].length), le ? le.from(f, "base64").toString() : window.atob(f);
      var f;
      let x = p.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + x);
    }
    getAnnotationURL(p) {
      return p.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(p) {
      return typeof p == "object" && (typeof p.mappings == "string" || typeof p._mappings == "string" || Array.isArray(p.sections));
    }
    loadAnnotation(p) {
      let d = p.match(/\/\*\s*# sourceMappingURL=/g);
      if (!d) return;
      let g = p.lastIndexOf(d.pop()), f = p.indexOf("*/", g);
      g > -1 && f > -1 && (this.annotation = this.getAnnotationURL(p.substring(g, f)));
    }
    loadFile(p) {
      if (this.root = s(p), e(p)) return this.mapFile = p, t(p, "utf-8").toString().trim();
    }
    loadMap(p, d) {
      if (d === !1) return !1;
      if (d) {
        if (typeof d == "string") return d;
        if (typeof d != "function") {
          if (d instanceof i) return o.fromSourceMap(d).toString();
          if (d instanceof o) return d.toString();
          if (this.isMap(d)) return JSON.stringify(d);
          throw new Error("Unsupported previous source map format: " + d.toString());
        }
        {
          let g = d(p);
          if (g) {
            let f = this.loadFile(g);
            if (!f) throw new Error("Unable to load previous source map: " + g.toString());
            return f;
          }
        }
      } else {
        if (this.inline) return this.decodeInline(this.annotation);
        if (this.annotation) {
          let g = this.annotation;
          return p && (g = n(s(p), g)), this.loadFile(g);
        }
      }
    }
    startWith(p, d) {
      return !!p && p.substr(0, d.length) === d;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return Uc = c, c.default = c, Uc;
}
function Fa() {
  if (Kd) return $c;
  Kd = 1;
  let { nanoid: e } = rE(), { isAbsolute: t, resolve: s } = Wh, { SourceMapConsumer: n, SourceMapGenerator: i } = wa(), { fileURLToPath: o, pathToFileURL: c } = Zx, l = Gh(), p = eb(), d = Yx(), g = Symbol("lineToIndexCache"), f = !!(n && i), x = !!(s && t);
  function m(v) {
    if (v[g]) return v[g];
    let b = v.css.split(`
`), E = new Array(b.length), w = 0;
    for (let C = 0, A = b.length; C < A; C++) E[C] = w, w += b[C].length + 1;
    return v[g] = E, E;
  }
  class y {
    get from() {
      return this.file || this.id;
    }
    constructor(b, E = {}) {
      if (b == null || typeof b == "object" && !b.toString) throw new Error(`PostCSS received ${b} instead of CSS string`);
      if (this.css = b.toString(), this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, E.document && (this.document = E.document.toString()), E.from && (!x || /^\w+:\/\//.test(E.from) || t(E.from) ? this.file = E.from : this.file = s(E.from)), x && f) {
        let w = new p(this.css, E);
        if (w.text) {
          this.map = w;
          let C = w.consumer().file;
          !this.file && C && (this.file = this.mapResolve(C));
        }
      }
      this.file || (this.id = "<input css " + e(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(b, E, w, C = {}) {
      let A, O, D, N, j;
      if (E && typeof E == "object") {
        let X = E, W = w;
        if (typeof X.offset == "number") {
          N = X.offset;
          let H = this.fromOffset(N);
          E = H.line, w = H.col;
        } else E = X.line, w = X.column, N = this.fromLineAndColumn(E, w);
        if (typeof W.offset == "number") {
          D = W.offset;
          let H = this.fromOffset(D);
          O = H.line, A = H.col;
        } else O = W.line, A = W.column, D = this.fromLineAndColumn(W.line, W.column);
      } else if (w) N = this.fromLineAndColumn(E, w);
      else {
        N = E;
        let X = this.fromOffset(N);
        E = X.line, w = X.col;
      }
      let U = this.origin(E, w, O, A);
      return j = U ? new l(b, U.endLine === void 0 ? U.line : { column: U.column, line: U.line }, U.endLine === void 0 ? U.column : { column: U.endColumn, line: U.endLine }, U.source, U.file, C.plugin) : new l(b, O === void 0 ? E : { column: w, line: E }, O === void 0 ? w : { column: A, line: O }, this.css, this.file, C.plugin), j.input = { column: w, endColumn: A, endLine: O, endOffset: D, line: E, offset: N, source: this.css }, this.file && (c && (j.input.url = c(this.file).toString()), j.input.file = this.file), j;
    }
    fromLineAndColumn(b, E) {
      return m(this)[b - 1] + E - 1;
    }
    fromOffset(b) {
      let E = m(this), w = 0;
      if (b >= E[E.length - 1]) w = E.length - 1;
      else {
        let C, A = E.length - 2;
        for (; w < A; ) if (C = w + (A - w >> 1), b < E[C]) A = C - 1;
        else {
          if (!(b >= E[C + 1])) {
            w = C;
            break;
          }
          w = C + 1;
        }
      }
      return { col: b - E[w] + 1, line: w + 1 };
    }
    mapResolve(b) {
      return /^\w+:\/\//.test(b) ? b : s(this.map.consumer().sourceRoot || this.map.root || ".", b);
    }
    origin(b, E, w, C) {
      if (!this.map) return !1;
      let A, O, D = this.map.consumer(), N = D.originalPositionFor({ column: E, line: b });
      if (!N.source) return !1;
      typeof w == "number" && (A = D.originalPositionFor({ column: C, line: w })), O = t(N.source) ? c(N.source) : new URL(N.source, this.map.consumer().sourceRoot || c(this.map.mapFile));
      let j = { column: N.column, endColumn: A && A.column, endLine: A && A.line, line: N.line, url: O.toString() };
      if (O.protocol === "file:") {
        if (!o) throw new Error("file: protocol is not available in this PostCSS build");
        j.file = o(O);
      }
      let U = D.sourceContentFor(N.source);
      return U && (j.source = U), j;
    }
    toJSON() {
      let b = {};
      for (let E of ["hasBOM", "css", "file", "id"]) this[E] != null && (b[E] = this[E]);
      return this.map && (b.map = { ...this.map }, b.map.consumerCache && (b.map.consumerCache = void 0)), b;
    }
  }
  return $c = y, y.default = y, d && d.registerInput && d.registerInput(y), $c;
}
function Si() {
  if (Jd) return qc;
  Jd = 1;
  let e, t, s = Rs();
  class n extends s {
    constructor(o) {
      super(o), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(o, c, l) {
      let p = super.normalize(o);
      if (c) {
        if (l === "prepend") this.nodes.length > 1 ? c.raws.before = this.nodes[1].raws.before : delete c.raws.before;
        else if (this.first !== c) for (let d of p) d.raws.before = c.raws.before;
      }
      return p;
    }
    removeChild(o, c) {
      let l = this.index(o);
      return !c && l === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[l].raws.before), super.removeChild(o);
    }
    toResult(o = {}) {
      return new e(new t(), this, o).stringify();
    }
  }
  return n.registerLazyResult = (i) => {
    e = i;
  }, n.registerProcessor = (i) => {
    t = i;
  }, qc = n, n.default = n, s.registerRoot(n), qc;
}
function tb() {
  if (Yd) return Vc;
  Yd = 1;
  let e = { comma: (t) => e.split(t, [","], !0), space: (t) => e.split(t, [" ", `
`, "	"]), split(t, s, n) {
    let i = [], o = "", c = !1, l = 0, p = !1, d = "", g = !1;
    for (let f of t) g ? g = !1 : f === "\\" ? g = !0 : p ? f === d && (p = !1) : f === '"' || f === "'" ? (p = !0, d = f) : f === "(" ? l += 1 : f === ")" ? l > 0 && (l -= 1) : l === 0 && s.includes(f) && (c = !0), c ? (o !== "" && i.push(o.trim()), o = "", c = !1) : o += f;
    return (n || o !== "") && i.push(o.trim()), i;
  } };
  return Vc = e, e.default = e, Vc;
}
function Yh() {
  if (Qd) return Hc;
  Qd = 1;
  let e = Rs(), t = tb();
  class s extends e {
    get selectors() {
      return t.comma(this.selector);
    }
    set selectors(i) {
      let o = this.selector ? this.selector.match(/,\s*/) : null, c = o ? o[0] : "," + this.raw("between", "beforeOpen");
      this.selector = i.join(c);
    }
    constructor(i) {
      super(i), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return Hc = s, s.default = s, e.registerRule(s), Hc;
}
function sE() {
  if (Zd) return zc;
  Zd = 1;
  let e = Kh(), t = Ma(), s = Da(), n = Fa(), i = eb(), o = Si(), c = Yh();
  function l(p, d) {
    if (Array.isArray(p)) return p.map((x) => l(x));
    let { inputs: g, ...f } = p;
    if (g) {
      d = [];
      for (let x of g) {
        let m = { ...x, __proto__: n.prototype };
        m.map && (m.map = { ...m.map, __proto__: i.prototype }), d.push(m);
      }
    }
    if (f.nodes && (f.nodes = p.nodes.map((x) => l(x, d))), f.source) {
      let { inputId: x, ...m } = f.source;
      f.source = m, x != null && (f.source.input = d[x]);
    }
    if (f.type === "root") return new o(f);
    if (f.type === "decl") return new s(f);
    if (f.type === "rule") return new c(f);
    if (f.type === "comment") return new t(f);
    if (f.type === "atrule") return new e(f);
    throw new Error("Unknown node type: " + p.type);
  }
  return zc = l, l.default = l, zc;
}
function rb() {
  if (ef) return Wc;
  ef = 1;
  let { dirname: e, relative: t, resolve: s, sep: n } = Wh, { SourceMapConsumer: i, SourceMapGenerator: o } = wa(), { pathToFileURL: c } = Zx, l = Fa(), p = !!(i && o), d = !!(e && s && t && n);
  return Wc = class {
    constructor(g, f, x, m) {
      this.stringify = g, this.mapOpts = x.map || {}, this.root = f, this.opts = x, this.css = m, this.originalCSS = m, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let g;
      g = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? this.mapOpts.annotation(this.opts.to, this.root) : this.outputFile() + ".map";
      let f = `
`;
      this.css.includes(`\r
`) && (f = `\r
`), this.css += f + "/*# sourceMappingURL=" + g + " */";
    }
    applyPrevMaps() {
      for (let g of this.previous()) {
        let f, x = this.toUrl(this.path(g.file)), m = g.root || e(g.file);
        this.mapOpts.sourcesContent === !1 ? (f = new i(g.text), f.sourcesContent && (f.sourcesContent = null)) : f = g.consumer(), this.map.applySourceMap(f, x, this.toUrl(this.path(m)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== !1) if (this.root) {
        let g;
        for (let f = this.root.nodes.length - 1; f >= 0; f--) g = this.root.nodes[f], g.type === "comment" && g.text.startsWith("# sourceMappingURL=") && this.root.removeChild(f);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), d && p && this.isMap()) return this.generateMap();
      {
        let g = "";
        return this.stringify(this.root, (f) => {
          g += f;
        }), [g];
      }
    }
    generateMap() {
      if (this.root) this.generateString();
      else if (this.previous().length === 1) {
        let g = this.previous()[0].consumer();
        g.file = this.outputFile(), this.map = o.fromSourceMap(g, { ignoreInvalidMapping: !0 });
      } else this.map = new o({ file: this.outputFile(), ignoreInvalidMapping: !0 }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new o({ file: this.outputFile(), ignoreInvalidMapping: !0 });
      let g, f, x = 1, m = 1, y = "<no source>", v = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" };
      this.stringify(this.root, (b, E, w) => {
        if (this.css += b, E && w !== "end" && (v.generated.line = x, v.generated.column = m - 1, E.source && E.source.start ? (v.source = this.sourcePath(E), v.original.line = E.source.start.line, v.original.column = E.source.start.column - 1, this.map.addMapping(v)) : (v.source = y, v.original.line = 1, v.original.column = 0, this.map.addMapping(v))), f = b.match(/\n/g), f ? (x += f.length, g = b.lastIndexOf(`
`), m = b.length - g) : m += b.length, E && w !== "start") {
          let C = E.parent || { raws: {} };
          (E.type === "decl" || E.type === "atrule" && !E.nodes) && E === C.last && !C.raws.semicolon || (E.source && E.source.end ? (v.source = this.sourcePath(E), v.original.line = E.source.end.line, v.original.column = E.source.end.column - 1, v.generated.line = x, v.generated.column = m - 2, this.map.addMapping(v)) : (v.source = y, v.original.line = 1, v.original.column = 0, v.generated.line = x, v.generated.column = m - 1, this.map.addMapping(v)));
        }
      });
    }
    isAnnotation() {
      return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some((g) => g.annotation));
    }
    isInline() {
      if (this.mapOpts.inline !== void 0) return this.mapOpts.inline;
      let g = this.mapOpts.annotation;
      return (g === void 0 || g === !0) && (!this.previous().length || this.previous().some((f) => f.inline));
    }
    isMap() {
      return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some((g) => g.withContent());
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(g) {
      if (this.mapOpts.absolute || g.charCodeAt(0) === 60 || /^\w+:\/\//.test(g)) return g;
      let f = this.memoizedPaths.get(g);
      if (f) return f;
      let x = this.opts.to ? e(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (x = e(s(x, this.mapOpts.annotation)));
      let m = t(x, g);
      return this.memoizedPaths.set(g, m), m;
    }
    previous() {
      if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((g) => {
        if (g.source && g.source.input.map) {
          let f = g.source.input.map;
          this.previousMaps.includes(f) || this.previousMaps.push(f);
        }
      });
      else {
        let g = new l(this.originalCSS, this.opts);
        g.map && this.previousMaps.push(g.map);
      }
      return this.previousMaps;
    }
    setSourcesContent() {
      let g = {};
      if (this.root) this.root.walk((f) => {
        if (f.source) {
          let x = f.source.input.from;
          if (x && !g[x]) {
            g[x] = !0;
            let m = this.usesFileUrls ? this.toFileUrl(x) : this.toUrl(this.path(x));
            this.map.setSourceContent(m, f.source.input.css);
          }
        }
      });
      else if (this.css) {
        let f = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(f, this.css);
      }
    }
    sourcePath(g) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(g.source.input.from) : this.toUrl(this.path(g.source.input.from));
    }
    toBase64(g) {
      return le ? le.from(g).toString("base64") : window.btoa(unescape(encodeURIComponent(g)));
    }
    toFileUrl(g) {
      let f = this.memoizedFileURLs.get(g);
      if (f) return f;
      if (c) {
        let x = c(g).toString();
        return this.memoizedFileURLs.set(g, x), x;
      }
      throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(g) {
      let f = this.memoizedURLs.get(g);
      if (f) return f;
      n === "\\" && (g = g.replace(/\\/g, "/"));
      let x = encodeURI(g).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(g, x), x;
    }
  }, Wc;
}
function nE() {
  if (tf) return Gc;
  tf = 1;
  let e = Kh(), t = Ma(), s = Da(), n = Si(), i = Yh(), o = Jx();
  const c = { empty: !0, space: !0 };
  return Gc = class {
    constructor(l) {
      this.input = l, this.root = new n(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: l, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(l) {
      let p, d, g, f = new e();
      f.name = l[1].slice(1), f.name === "" && this.unnamedAtrule(f, l), this.init(f, l[2]);
      let x = !1, m = !1, y = [], v = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (p = (l = this.tokenizer.nextToken())[0], p === "(" || p === "[" ? v.push(p === "(" ? ")" : "]") : p === "{" && v.length > 0 ? v.push("}") : p === v[v.length - 1] && v.pop(), v.length === 0) {
          if (p === ";") {
            f.source.end = this.getPosition(l[2]), f.source.end.offset++, this.semicolon = !0;
            break;
          }
          if (p === "{") {
            m = !0;
            break;
          }
          if (p === "}") {
            if (y.length > 0) {
              for (g = y.length - 1, d = y[g]; d && d[0] === "space"; ) d = y[--g];
              d && (f.source.end = this.getPosition(d[3] || d[2]), f.source.end.offset++);
            }
            this.end(l);
            break;
          }
          y.push(l);
        } else y.push(l);
        if (this.tokenizer.endOfFile()) {
          x = !0;
          break;
        }
      }
      f.raws.between = this.spacesAndCommentsFromEnd(y), y.length ? (f.raws.afterName = this.spacesAndCommentsFromStart(y), this.raw(f, "params", y), x && (l = y[y.length - 1], f.source.end = this.getPosition(l[3] || l[2]), f.source.end.offset++, this.spaces = f.raws.between, f.raws.between = "")) : (f.raws.afterName = "", f.params = ""), m && (f.nodes = [], this.current = f);
    }
    checkMissedSemicolon(l) {
      let p = this.colon(l);
      if (p === !1) return;
      let d, g = 0;
      for (let f = p - 1; f >= 0 && (d = l[f], d[0] === "space" || (g += 1, g !== 2)); f--) ;
      throw this.input.error("Missed semicolon", d[0] === "word" ? d[3] + 1 : d[2]);
    }
    colon(l) {
      let p, d, g, f = 0;
      for (let [x, m] of l.entries()) {
        if (d = m, g = d[0], g === "(" && (f += 1), g === ")" && (f -= 1), f === 0 && g === ":") {
          if (p) {
            if (p[0] === "word" && p[1] === "progid") continue;
            return x;
          }
          this.doubleColon(d);
        }
        p = d;
      }
      return !1;
    }
    comment(l) {
      let p = new t();
      this.init(p, l[2]), p.source.end = this.getPosition(l[3] || l[2]), p.source.end.offset++;
      let d = l[1].slice(2, -2);
      if (/^\s*$/.test(d)) p.text = "", p.raws.left = d, p.raws.right = "";
      else {
        let g = d.match(/^(\s*)([^]*\S)(\s*)$/);
        p.text = g[2], p.raws.left = g[1], p.raws.right = g[3];
      }
    }
    createTokenizer() {
      this.tokenizer = o(this.input);
    }
    decl(l, p) {
      let d = new s();
      this.init(d, l[0][2]);
      let g, f = l[l.length - 1];
      for (f[0] === ";" && (this.semicolon = !0, l.pop()), d.source.end = this.getPosition(f[3] || f[2] || (function(y) {
        for (let v = y.length - 1; v >= 0; v--) {
          let b = y[v], E = b[3] || b[2];
          if (E) return E;
        }
      })(l)), d.source.end.offset++; l[0][0] !== "word"; ) l.length === 1 && this.unknownWord(l), d.raws.before += l.shift()[1];
      for (d.source.start = this.getPosition(l[0][2]), d.prop = ""; l.length; ) {
        let y = l[0][0];
        if (y === ":" || y === "space" || y === "comment") break;
        d.prop += l.shift()[1];
      }
      for (d.raws.between = ""; l.length; ) {
        if (g = l.shift(), g[0] === ":") {
          d.raws.between += g[1];
          break;
        }
        g[0] === "word" && /\w/.test(g[1]) && this.unknownWord([g]), d.raws.between += g[1];
      }
      d.prop[0] !== "_" && d.prop[0] !== "*" || (d.raws.before += d.prop[0], d.prop = d.prop.slice(1));
      let x, m = [];
      for (; l.length && (x = l[0][0], x === "space" || x === "comment"); ) m.push(l.shift());
      this.precheckMissedSemicolon(l);
      for (let y = l.length - 1; y >= 0; y--) {
        if (g = l[y], g[1].toLowerCase() === "!important") {
          d.important = !0;
          let v = this.stringFrom(l, y);
          v = this.spacesFromEnd(l) + v, v !== " !important" && (d.raws.important = v);
          break;
        }
        if (g[1].toLowerCase() === "important") {
          let v = l.slice(0), b = "";
          for (let E = y; E > 0; E--) {
            let w = v[E][0];
            if (b.trim().startsWith("!") && w !== "space") break;
            b = v.pop()[1] + b;
          }
          b.trim().startsWith("!") && (d.important = !0, d.raws.important = b, l = v);
        }
        if (g[0] !== "space" && g[0] !== "comment") break;
      }
      l.some((y) => y[0] !== "space" && y[0] !== "comment") && (d.raws.between += m.map((y) => y[1]).join(""), m = []), this.raw(d, "value", m.concat(l), p), d.value.includes(":") && !p && this.checkMissedSemicolon(l);
    }
    doubleColon(l) {
      throw this.input.error("Double colon", { offset: l[2] }, { offset: l[2] + l[1].length });
    }
    emptyRule(l) {
      let p = new i();
      this.init(p, l[2]), p.selector = "", p.raws.between = "", this.current = p;
    }
    end(l) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(l[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(l);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(l) {
      if (this.spaces += l[1], this.current.nodes) {
        let p = this.current.nodes[this.current.nodes.length - 1];
        p && p.type === "rule" && !p.raws.ownSemicolon && (p.raws.ownSemicolon = this.spaces, this.spaces = "", p.source.end = this.getPosition(l[2]), p.source.end.offset += p.raws.ownSemicolon.length);
      }
    }
    getPosition(l) {
      let p = this.input.fromOffset(l);
      return { column: p.col, line: p.line, offset: l };
    }
    init(l, p) {
      this.current.push(l), l.source = { input: this.input, start: this.getPosition(p) }, l.raws.before = this.spaces, this.spaces = "", l.type !== "comment" && (this.semicolon = !1);
    }
    other(l) {
      let p = !1, d = null, g = !1, f = null, x = [], m = l[1].startsWith("--"), y = [], v = l;
      for (; v; ) {
        if (d = v[0], y.push(v), d === "(" || d === "[") f || (f = v), x.push(d === "(" ? ")" : "]");
        else if (m && g && d === "{") f || (f = v), x.push("}");
        else if (x.length === 0) {
          if (d === ";") {
            if (g) return void this.decl(y, m);
            break;
          }
          if (d === "{") return void this.rule(y);
          if (d === "}") {
            this.tokenizer.back(y.pop()), p = !0;
            break;
          }
          d === ":" && (g = !0);
        } else d === x[x.length - 1] && (x.pop(), x.length === 0 && (f = null));
        v = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (p = !0), x.length > 0 && this.unclosedBracket(f), p && g) {
        if (!m) for (; y.length && (v = y[y.length - 1][0], v === "space" || v === "comment"); ) this.tokenizer.back(y.pop());
        this.decl(y, m);
      } else this.unknownWord(y);
    }
    parse() {
      let l;
      for (; !this.tokenizer.endOfFile(); ) switch (l = this.tokenizer.nextToken(), l[0]) {
        case "space":
          this.spaces += l[1];
          break;
        case ";":
          this.freeSemicolon(l);
          break;
        case "}":
          this.end(l);
          break;
        case "comment":
          this.comment(l);
          break;
        case "at-word":
          this.atrule(l);
          break;
        case "{":
          this.emptyRule(l);
          break;
        default:
          this.other(l);
      }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(l, p, d, g) {
      let f, x, m, y, v = d.length, b = "", E = !0;
      for (let w = 0; w < v; w += 1) f = d[w], x = f[0], x !== "space" || w !== v - 1 || g ? x === "comment" ? (y = d[w - 1] ? d[w - 1][0] : "empty", m = d[w + 1] ? d[w + 1][0] : "empty", c[y] || c[m] || b.slice(-1) === "," ? E = !1 : b += f[1]) : b += f[1] : E = !1;
      if (!E) {
        let w = d.reduce((C, A) => C + A[1], "");
        l.raws[p] = { raw: w, value: b };
      }
      l[p] = b;
    }
    rule(l) {
      l.pop();
      let p = new i();
      this.init(p, l[0][2]), p.raws.between = this.spacesAndCommentsFromEnd(l), this.raw(p, "selector", l), this.current = p;
    }
    spacesAndCommentsFromEnd(l) {
      let p, d = "";
      for (; l.length && (p = l[l.length - 1][0], p === "space" || p === "comment"); ) d = l.pop()[1] + d;
      return d;
    }
    spacesAndCommentsFromStart(l) {
      let p, d = "";
      for (; l.length && (p = l[0][0], p === "space" || p === "comment"); ) d += l.shift()[1];
      return d;
    }
    spacesFromEnd(l) {
      let p, d = "";
      for (; l.length && (p = l[l.length - 1][0], p === "space"); ) d = l.pop()[1] + d;
      return d;
    }
    stringFrom(l, p) {
      let d = "";
      for (let g = p; g < l.length; g++) d += l[g][1];
      return l.splice(p, l.length - p), d;
    }
    unclosedBlock() {
      let l = this.current.source.start;
      throw this.input.error("Unclosed block", l.line, l.column);
    }
    unclosedBracket(l) {
      throw this.input.error("Unclosed bracket", { offset: l[2] }, { offset: l[2] + 1 });
    }
    unexpectedClose(l) {
      throw this.input.error("Unexpected }", { offset: l[2] }, { offset: l[2] + 1 });
    }
    unknownWord(l) {
      throw this.input.error("Unknown word " + l[0][1], { offset: l[0][2] }, { offset: l[0][2] + l[0][1].length });
    }
    unnamedAtrule(l, p) {
      throw this.input.error("At-rule without name", { offset: p[2] }, { offset: p[2] + p[1].length });
    }
  }, Gc;
}
function Qh() {
  if (rf) return Xc;
  rf = 1;
  let e = Rs(), t = Fa(), s = nE();
  function n(i, o) {
    let c = new t(i, o), l = new s(c);
    try {
      l.parse();
    } catch (p) {
      throw $t.env.NODE_ENV !== "production" && p.name === "CssSyntaxError" && o && o.from && (/\.scss$/i.test(o.from) ? p.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(o.from) ? p.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(o.from) && (p.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), p;
    }
    return l.root;
  }
  return Xc = n, n.default = n, e.registerParse(n), Xc;
}
function sb() {
  if (sf) return Kc;
  sf = 1;
  class e {
    constructor(s, n = {}) {
      if (this.type = "warning", this.text = s, n.node && n.node.source) {
        let i = n.node.rangeBy(n);
        this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
      }
      for (let i in n) this[i] = n[i];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return Kc = e, e.default = e, Kc;
}
function Zh() {
  if (nf) return Jc;
  nf = 1;
  let e = sb();
  class t {
    get content() {
      return this.css;
    }
    constructor(n, i, o) {
      this.processor = n, this.messages = [], this.root = i, this.opts = o, this.css = "", this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(n, i = {}) {
      i.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (i.plugin = this.lastPlugin.postcssPlugin);
      let o = new e(n, i);
      return this.messages.push(o), o;
    }
    warnings() {
      return this.messages.filter((n) => n.type === "warning");
    }
  }
  return Jc = t, t.default = t, Jc;
}
function nb() {
  if (af) return of;
  af = 1;
  let e = {};
  return of = function(t) {
    e[t] || (e[t] = !0, typeof console < "u" && console.warn && console.warn(t));
  };
}
function ib() {
  if (cf) return Yc;
  cf = 1;
  let e = Rs(), t = Jh(), s = rb(), n = Qh(), i = Zh(), o = Si(), c = La(), { isClean: l, my: p } = Xh(), d = nb();
  const g = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, f = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, x = { Once: !0, postcssPlugin: !0, prepare: !0 };
  function m(C) {
    return typeof C == "object" && typeof C.then == "function";
  }
  function y(C) {
    let A = !1, O = g[C.type];
    return C.type === "decl" ? A = C.prop.toLowerCase() : C.type === "atrule" && (A = C.name.toLowerCase()), A && C.append ? [O, O + "-" + A, 0, O + "Exit", O + "Exit-" + A] : A ? [O, O + "-" + A, O + "Exit", O + "Exit-" + A] : C.append ? [O, 0, O + "Exit"] : [O, O + "Exit"];
  }
  function v(C) {
    let A;
    return A = C.type === "document" ? ["Document", 0, "DocumentExit"] : C.type === "root" ? ["Root", 0, "RootExit"] : y(C), { eventIndex: 0, events: A, iterator: 0, node: C, visitorIndex: 0, visitors: [] };
  }
  function b(C) {
    return C[l] = !1, C.nodes && C.nodes.forEach((A) => b(A)), C;
  }
  let E = {};
  class w {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(A, O, D) {
      let N;
      if (this.stringified = !1, this.processed = !1, typeof O != "object" || O === null || O.type !== "root" && O.type !== "document") if (O instanceof w || O instanceof i) N = b(O.root), O.map && (D.map === void 0 && (D.map = {}), D.map.inline || (D.map.inline = !1), D.map.prev = O.map);
      else {
        let j = n;
        D.syntax && (j = D.syntax.parse), D.parser && (j = D.parser), j.parse && (j = j.parse);
        try {
          N = j(O, D);
        } catch (U) {
          this.processed = !0, this.error = U;
        }
        N && !N[p] && e.rebuild(N);
      }
      else N = b(O);
      this.result = new i(A, N, D), this.helpers = { ...E, postcss: E, result: this.result }, this.plugins = this.processor.plugins.map((j) => typeof j == "object" && j.prepare ? { ...j, ...j.prepare(this.result) } : j);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(A) {
      return this.async().catch(A);
    }
    finally(A) {
      return this.async().then(A, A);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(A, O) {
      let D = this.result.lastPlugin;
      try {
        if (O && O.addToError(A), this.error = A, A.name !== "CssSyntaxError" || A.plugin) {
          if (D.postcssVersion && $t.env.NODE_ENV !== "production") {
            let N = D.postcssPlugin, j = D.postcssVersion, U = this.result.processor.version, X = j.split("."), W = U.split(".");
            (X[0] !== W[0] || parseInt(X[1]) > parseInt(W[1])) && console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + U + ", but " + N + " uses " + j + ". Perhaps this is the source of the error below.");
          }
        } else A.plugin = D.postcssPlugin, A.setMessage();
      } catch (N) {
        console && console.error && console.error(N);
      }
      return A;
    }
    prepareVisitors() {
      this.listeners = {};
      let A = (O, D, N) => {
        this.listeners[D] || (this.listeners[D] = []), this.listeners[D].push([O, N]);
      };
      for (let O of this.plugins) if (typeof O == "object") for (let D in O) {
        if (!f[D] && /^[A-Z]/.test(D)) throw new Error(`Unknown event ${D} in ${O.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
        if (!x[D]) if (typeof O[D] == "object") for (let N in O[D]) A(O, N === "*" ? D : D + "-" + N.toLowerCase(), O[D][N]);
        else typeof O[D] == "function" && A(O, D, O[D]);
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let A = 0; A < this.plugins.length; A++) {
        let O = this.plugins[A], D = this.runOnRoot(O);
        if (m(D)) try {
          await D;
        } catch (N) {
          throw this.handleError(N);
        }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[l]; ) {
          A[l] = !0;
          let O = [v(A)];
          for (; O.length > 0; ) {
            let D = this.visitTick(O);
            if (m(D)) try {
              await D;
            } catch (N) {
              let j = O[O.length - 1].node;
              throw this.handleError(N, j);
            }
          }
        }
        if (this.listeners.OnceExit) for (let [O, D] of this.listeners.OnceExit) {
          this.result.lastPlugin = O;
          try {
            if (A.type === "document") {
              let N = A.nodes.map((j) => D(j, this.helpers));
              await Promise.all(N);
            } else await D(A, this.helpers);
          } catch (N) {
            throw this.handleError(N);
          }
        }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(A) {
      this.result.lastPlugin = A;
      try {
        if (typeof A == "object" && A.Once) {
          if (this.result.root.type === "document") {
            let O = this.result.root.nodes.map((D) => A.Once(D, this.helpers));
            return m(O[0]) ? Promise.all(O) : O;
          }
          return A.Once(this.result.root, this.helpers);
        }
        if (typeof A == "function") return A(this.result.root, this.result);
      } catch (O) {
        throw this.handleError(O);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = !0, this.sync();
      let A = this.result.opts, O = c;
      A.syntax && (O = A.syntax.stringify), A.stringifier && (O = A.stringifier), O.stringify && (O = O.stringify);
      let D = new s(O, this.result.root, this.result.opts).generate();
      return this.result.css = D[0], this.result.map = D[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = !0, this.processing) throw this.getAsyncError();
      for (let A of this.plugins)
        if (m(this.runOnRoot(A))) throw this.getAsyncError();
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[l]; ) A[l] = !0, this.walkSync(A);
        if (this.listeners.OnceExit) if (A.type === "document") for (let O of A.nodes) this.visitSync(this.listeners.OnceExit, O);
        else this.visitSync(this.listeners.OnceExit, A);
      }
      return this.result;
    }
    then(A, O) {
      return $t.env.NODE_ENV !== "production" && ("from" in this.opts || d("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.")), this.async().then(A, O);
    }
    toString() {
      return this.css;
    }
    visitSync(A, O) {
      for (let [D, N] of A) {
        let j;
        this.result.lastPlugin = D;
        try {
          j = N(O, this.helpers);
        } catch (U) {
          throw this.handleError(U, O.proxyOf);
        }
        if (O.type !== "root" && O.type !== "document" && !O.parent) return !0;
        if (m(j)) throw this.getAsyncError();
      }
    }
    visitTick(A) {
      let O = A[A.length - 1], { node: D, visitors: N } = O;
      if (D.type !== "root" && D.type !== "document" && !D.parent) return void A.pop();
      if (N.length > 0 && O.visitorIndex < N.length) {
        let [U, X] = N[O.visitorIndex];
        O.visitorIndex += 1, O.visitorIndex === N.length && (O.visitors = [], O.visitorIndex = 0), this.result.lastPlugin = U;
        try {
          return X(D.toProxy(), this.helpers);
        } catch (W) {
          throw this.handleError(W, D);
        }
      }
      if (O.iterator !== 0) {
        let U, X = O.iterator;
        for (; U = D.nodes[D.indexes[X]]; ) if (D.indexes[X] += 1, !U[l]) return U[l] = !0, void A.push(v(U));
        O.iterator = 0, delete D.indexes[X];
      }
      let j = O.events;
      for (; O.eventIndex < j.length; ) {
        let U = j[O.eventIndex];
        if (O.eventIndex += 1, U === 0) return void (D.nodes && D.nodes.length && (D[l] = !0, O.iterator = D.getIterator()));
        if (this.listeners[U]) return void (O.visitors = this.listeners[U]);
      }
      A.pop();
    }
    walkSync(A) {
      A[l] = !0;
      let O = y(A);
      for (let D of O) if (D === 0) A.nodes && A.each((N) => {
        N[l] || this.walkSync(N);
      });
      else {
        let N = this.listeners[D];
        if (N && this.visitSync(N, A.toProxy())) return;
      }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return w.registerPostcss = (C) => {
    E = C;
  }, Yc = w, w.default = w, o.registerLazyResult(w), t.registerLazyResult(w), Yc;
}
function iE() {
  if (lf) return Qc;
  lf = 1;
  let e = rb(), t = Qh();
  const s = Zh();
  let n = La(), i = nb();
  class o {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root) return this._root;
      let l, p = t;
      try {
        l = p(this._css, this._opts);
      } catch (d) {
        this.error = d;
      }
      if (this.error) throw this.error;
      return this._root = l, l;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(l, p, d) {
      let g;
      p = p.toString(), this.stringified = !1, this._processor = l, this._css = p, this._opts = d, this._map = void 0;
      let f = n;
      this.result = new s(this._processor, g, this._opts), this.result.css = p;
      let x = this;
      Object.defineProperty(this.result, "root", { get: () => x.root });
      let m = new e(f, g, this._opts, p);
      if (m.isMap()) {
        let [y, v] = m.generate();
        y && (this.result.css = y), v && (this.result.map = v);
      } else m.clearAnnotation(), this.result.css = m.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(l) {
      return this.async().catch(l);
    }
    finally(l) {
      return this.async().then(l, l);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(l, p) {
      return $t.env.NODE_ENV !== "production" && ("from" in this._opts || i("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.")), this.async().then(l, p);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Qc = o, o.default = o, Qc;
}
function oE() {
  if (pf) return Zc;
  pf = 1;
  let e = Jh(), t = ib(), s = iE(), n = Si();
  class i {
    constructor(c = []) {
      this.version = "8.5.6", this.plugins = this.normalize(c);
    }
    normalize(c) {
      let l = [];
      for (let p of c) if (p.postcss === !0 ? p = p() : p.postcss && (p = p.postcss), typeof p == "object" && Array.isArray(p.plugins)) l = l.concat(p.plugins);
      else if (typeof p == "object" && p.postcssPlugin) l.push(p);
      else if (typeof p == "function") l.push(p);
      else {
        if (typeof p != "object" || !p.parse && !p.stringify) throw new Error(p + " is not a PostCSS plugin");
        if ($t.env.NODE_ENV !== "production") throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
      }
      return l;
    }
    process(c, l = {}) {
      return this.plugins.length || l.parser || l.stringifier || l.syntax ? new t(this, c, l) : new s(this, c, l);
    }
    use(c) {
      return this.plugins = this.plugins.concat(this.normalize([c])), this;
    }
  }
  return Zc = i, i.default = i, n.registerProcessor(i), e.registerProcessor(i), Zc;
}
function aE() {
  if (hf) return el;
  hf = 1;
  let e = Kh(), t = Ma(), s = Rs(), n = Gh(), i = Da(), o = Jh(), c = sE(), l = Fa(), p = ib(), d = tb(), g = Ra(), f = Qh(), x = oE(), m = Zh(), y = Si(), v = Yh(), b = La(), E = sb();
  function w(...C) {
    return C.length === 1 && Array.isArray(C[0]) && (C = C[0]), new x(C);
  }
  return w.plugin = function(C, A) {
    let O, D = !1;
    function N(...j) {
      console && console.warn && !D && (D = !0, console.warn(C + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), $t.env.LANG && $t.env.LANG.startsWith("cn") && console.warn(C + `: é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:
https://www.w3ctech.com/topic/2226`));
      let U = A(...j);
      return U.postcssPlugin = C, U.postcssVersion = new x().version, U;
    }
    return Object.defineProperty(N, "postcss", { get: () => (O || (O = N()), O) }), N.process = function(j, U, X) {
      return w([N(X)]).process(j, U);
    }, N;
  }, w.stringify = b, w.parse = f, w.fromJSON = c, w.list = d, w.comment = (C) => new t(C), w.atRule = (C) => new e(C), w.decl = (C) => new i(C), w.rule = (C) => new v(C), w.root = (C) => new y(C), w.document = (C) => new o(C), w.CssSyntaxError = n, w.Declaration = i, w.Container = s, w.Processor = x, w.Document = o, w.Comment = t, w.Warning = E, w.AtRule = e, w.Result = m, w.Input = l, w.Rule = v, w.Root = y, w.Node = g, p.registerPostcss(w), el = w, w.default = w, el;
}
var Je = xa(aE());
Je.stringify, Je.fromJSON, Je.plugin, Je.parse, Je.list, Je.document, Je.comment, Je.atRule, Je.rule, Je.decl, Je.root, Je.CssSyntaxError, Je.Declaration, Je.Container, Je.Processor, Je.Document, Je.Comment, Je.Warning, Je.AtRule, Je.Result, Je.Input;
const cE = Je.Rule;
Je.Root, Je.Node;
const ob = () => ({ postcssPlugin: "vue-sfc-trim", Once(e) {
  e.walk(({ type: t, raws: s }) => {
    t !== "rule" && t !== "atrule" || (s.before && (s.before = `
`), "after" in s && s.after && (s.after = `
`));
  });
} });
ob.postcss = !0;
var uf, tl = { exports: {} }, rl = { exports: {} }, sl = { exports: {} }, nl = { exports: {} }, il = { exports: {} }, ol = { exports: {} }, tr = {}, al = { exports: {} };
function ab() {
  return uf || (uf = 1, (function(e, t) {
    function s(i) {
      for (var o = i.toLowerCase(), c = "", l = !1, p = 0; p < 6 && o[p] !== void 0; p++) {
        var d = o.charCodeAt(p);
        if (l = d === 32, !(d >= 97 && d <= 102 || d >= 48 && d <= 57)) break;
        c += o[p];
      }
      if (c.length !== 0) {
        var g = parseInt(c, 16);
        return g >= 55296 && g <= 57343 || g === 0 || g > 1114111 ? ["ï¿½", c.length + (l ? 1 : 0)] : [String.fromCodePoint(g), c.length + (l ? 1 : 0)];
      }
    }
    t.__esModule = !0, t.default = function(i) {
      if (!n.test(i)) return i;
      for (var o = "", c = 0; c < i.length; c++) if (i[c] !== "\\") o += i[c];
      else {
        var l = s(i.slice(c + 1, c + 7));
        if (l !== void 0) {
          o += l[0], c += l[1];
          continue;
        }
        if (i[c + 1] === "\\") {
          o += "\\", c++;
          continue;
        }
        i.length === c + 1 && (o += i[c]);
      }
      return o;
    };
    var n = /\\/;
    e.exports = t.default;
  })(al, al.exports)), al.exports;
}
var df, cl = { exports: {} };
function lE() {
  return df || (df = 1, e = cl, (t = cl.exports).__esModule = !0, t.default = function(s) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) i[o - 1] = arguments[o];
    for (; i.length > 0; ) {
      var c = i.shift();
      if (!s[c]) return;
      s = s[c];
    }
    return s;
  }, e.exports = t.default), cl.exports;
  var e, t;
}
var ff, ll = { exports: {} };
function pE() {
  return ff || (ff = 1, e = ll, (t = ll.exports).__esModule = !0, t.default = function(s) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) i[o - 1] = arguments[o];
    for (; i.length > 0; ) {
      var c = i.shift();
      s[c] || (s[c] = {}), s = s[c];
    }
  }, e.exports = t.default), ll.exports;
  var e, t;
}
var mf, gf, yf, pl = { exports: {} };
function hE() {
  return mf || (mf = 1, e = pl, (t = pl.exports).__esModule = !0, t.default = function(s) {
    for (var n = "", i = s.indexOf("/*"), o = 0; i >= 0; ) {
      n += s.slice(o, i);
      var c = s.indexOf("*/", i + 2);
      if (c < 0) return n;
      o = c + 2, i = s.indexOf("/*", o);
    }
    return n += s.slice(o);
  }, e.exports = t.default), pl.exports;
  var e, t;
}
function ja() {
  if (gf) return tr;
  gf = 1, tr.__esModule = !0, tr.unesc = tr.stripComments = tr.getProp = tr.ensureObject = void 0;
  var e = i(ab());
  tr.unesc = e.default;
  var t = i(lE());
  tr.getProp = t.default;
  var s = i(pE());
  tr.ensureObject = s.default;
  var n = i(hE());
  function i(o) {
    return o && o.__esModule ? o : { default: o };
  }
  return tr.stripComments = n.default, tr;
}
function ns() {
  return yf || (yf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s = ja();
    function n(c, l, p) {
      return l && (function(d, g) {
        for (var f = 0; f < g.length; f++) {
          var x = g[f];
          x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(d, x.key, x);
        }
      })(c.prototype, l), Object.defineProperty(c, "prototype", { writable: !1 }), c;
    }
    var i = function c(l, p) {
      if (typeof l != "object" || l === null) return l;
      var d = new l.constructor();
      for (var g in l) if (l.hasOwnProperty(g)) {
        var f = l[g];
        g === "parent" && typeof f == "object" ? p && (d[g] = p) : d[g] = f instanceof Array ? f.map(function(x) {
          return c(x, d);
        }) : c(f, d);
      }
      return d;
    }, o = (function() {
      function c(p) {
        p === void 0 && (p = {}), Object.assign(this, p), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var l = c.prototype;
      return l.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, l.replaceWith = function() {
        if (this.parent) {
          for (var p in arguments) this.parent.insertBefore(this, arguments[p]);
          this.remove();
        }
        return this;
      }, l.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, l.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, l.clone = function(p) {
        p === void 0 && (p = {});
        var d = i(this);
        for (var g in p) d[g] = p[g];
        return d;
      }, l.appendToPropertyAndEscape = function(p, d, g) {
        this.raws || (this.raws = {});
        var f = this[p], x = this.raws[p];
        this[p] = f + d, x || g !== d ? this.raws[p] = (x || f) + g : delete this.raws[p];
      }, l.setPropertyAndEscape = function(p, d, g) {
        this.raws || (this.raws = {}), this[p] = d, this.raws[p] = g;
      }, l.setPropertyWithoutEscape = function(p, d) {
        this[p] = d, this.raws && delete this.raws[p];
      }, l.isAtPosition = function(p, d) {
        if (this.source && this.source.start && this.source.end) return !(this.source.start.line > p) && !(this.source.end.line < p) && !(this.source.start.line === p && this.source.start.column > d) && !(this.source.end.line === p && this.source.end.column < d);
      }, l.stringifyProperty = function(p) {
        return this.raws && this.raws[p] || this[p];
      }, l.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, l.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, n(c, [{ key: "rawSpaceBefore", get: function() {
        var p = this.raws && this.raws.spaces && this.raws.spaces.before;
        return p === void 0 && (p = this.spaces && this.spaces.before), p || "";
      }, set: function(p) {
        (0, s.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = p;
      } }, { key: "rawSpaceAfter", get: function() {
        var p = this.raws && this.raws.spaces && this.raws.spaces.after;
        return p === void 0 && (p = this.spaces.after), p || "";
      }, set: function(p) {
        (0, s.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = p;
      } }]), c;
    })();
    t.default = o, e.exports = t.default;
  })(ol, ol.exports)), ol.exports;
}
var xf, bf, Tf, We = {};
function Ct() {
  return xf ? We : (xf = 1, We.__esModule = !0, We.UNIVERSAL = We.TAG = We.STRING = We.SELECTOR = We.ROOT = We.PSEUDO = We.NESTING = We.ID = We.COMMENT = We.COMBINATOR = We.CLASS = We.ATTRIBUTE = void 0, We.TAG = "tag", We.STRING = "string", We.SELECTOR = "selector", We.ROOT = "root", We.PSEUDO = "pseudo", We.NESTING = "nesting", We.ID = "id", We.COMMENT = "comment", We.COMBINATOR = "combinator", We.CLASS = "class", We.ATTRIBUTE = "attribute", We.UNIVERSAL = "universal", We);
}
function eu() {
  return bf || (bf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = (function(f, x) {
      if (f && f.__esModule) return f;
      if (f === null || typeof f != "object" && typeof f != "function") return { default: f };
      var m = o(x);
      if (m && m.has(f)) return m.get(f);
      var y = {}, v = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b in f) if (b !== "default" && Object.prototype.hasOwnProperty.call(f, b)) {
        var E = v ? Object.getOwnPropertyDescriptor(f, b) : null;
        E && (E.get || E.set) ? Object.defineProperty(y, b, E) : y[b] = f[b];
      }
      return y.default = f, m && m.set(f, y), y;
    })(Ct());
    function o(f) {
      if (typeof WeakMap != "function") return null;
      var x = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
      return (o = function(y) {
        return y ? m : x;
      })(f);
    }
    function c(f, x) {
      var m = typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (m) return (m = m.call(f)).next.bind(m);
      if (Array.isArray(f) || (m = (function(v, b) {
        if (v) {
          if (typeof v == "string") return l(v, b);
          var E = Object.prototype.toString.call(v).slice(8, -1);
          if (E === "Object" && v.constructor && (E = v.constructor.name), E === "Map" || E === "Set") return Array.from(v);
          if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E)) return l(v, b);
        }
      })(f)) || x) {
        m && (f = m);
        var y = 0;
        return function() {
          return y >= f.length ? { done: !0 } : { done: !1, value: f[y++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function l(f, x) {
      (x == null || x > f.length) && (x = f.length);
      for (var m = 0, y = new Array(x); m < x; m++) y[m] = f[m];
      return y;
    }
    function p(f, x, m) {
      return x && (function(y, v) {
        for (var b = 0; b < v.length; b++) {
          var E = v[b];
          E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(y, E.key, E);
        }
      })(f.prototype, x), Object.defineProperty(f, "prototype", { writable: !1 }), f;
    }
    function d(f, x) {
      return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, y) {
        return m.__proto__ = y, m;
      }, d(f, x);
    }
    var g = (function(f) {
      var x, m;
      function y(b) {
        var E;
        return (E = f.call(this, b) || this).nodes || (E.nodes = []), E;
      }
      m = f, (x = y).prototype = Object.create(m.prototype), x.prototype.constructor = x, d(x, m);
      var v = y.prototype;
      return v.append = function(b) {
        return b.parent = this, this.nodes.push(b), this;
      }, v.prepend = function(b) {
        for (var E in b.parent = this, this.nodes.unshift(b), this.indexes) this.indexes[E]++;
        return this;
      }, v.at = function(b) {
        return this.nodes[b];
      }, v.index = function(b) {
        return typeof b == "number" ? b : this.nodes.indexOf(b);
      }, v.removeChild = function(b) {
        var E;
        for (var w in b = this.index(b), this.at(b).parent = void 0, this.nodes.splice(b, 1), this.indexes) (E = this.indexes[w]) >= b && (this.indexes[w] = E - 1);
        return this;
      }, v.removeAll = function() {
        for (var b, E = c(this.nodes); !(b = E()).done; )
          b.value.parent = void 0;
        return this.nodes = [], this;
      }, v.empty = function() {
        return this.removeAll();
      }, v.insertAfter = function(b, E) {
        var w;
        E.parent = this;
        for (var C, A = this.index(b), O = [], D = 2; D < arguments.length; D++) O.push(arguments[D]);
        for (var N in (w = this.nodes).splice.apply(w, [A + 1, 0, E].concat(O)), E.parent = this, this.indexes) A < (C = this.indexes[N]) && (this.indexes[N] = C + arguments.length - 1);
        return this;
      }, v.insertBefore = function(b, E) {
        var w;
        E.parent = this;
        for (var C, A = this.index(b), O = [], D = 2; D < arguments.length; D++) O.push(arguments[D]);
        for (var N in (w = this.nodes).splice.apply(w, [A, 0, E].concat(O)), E.parent = this, this.indexes) (C = this.indexes[N]) >= A && (this.indexes[N] = C + arguments.length - 1);
        return this;
      }, v._findChildAtPosition = function(b, E) {
        var w = void 0;
        return this.each(function(C) {
          if (C.atPosition) {
            var A = C.atPosition(b, E);
            if (A) return w = A, !1;
          } else if (C.isAtPosition(b, E)) return w = C, !1;
        }), w;
      }, v.atPosition = function(b, E) {
        return this.isAtPosition(b, E) ? this._findChildAtPosition(b, E) || this : void 0;
      }, v._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, v.each = function(b) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var E = this.lastEach;
        if (this.indexes[E] = 0, this.length) {
          for (var w, C; this.indexes[E] < this.length && (w = this.indexes[E], (C = b(this.at(w), w)) !== !1); ) this.indexes[E] += 1;
          return delete this.indexes[E], C !== !1 && void 0;
        }
      }, v.walk = function(b) {
        return this.each(function(E, w) {
          var C = b(E, w);
          if (C !== !1 && E.length && (C = E.walk(b)), C === !1) return !1;
        });
      }, v.walkAttributes = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.ATTRIBUTE) return b.call(E, w);
        });
      }, v.walkClasses = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.CLASS) return b.call(E, w);
        });
      }, v.walkCombinators = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.COMBINATOR) return b.call(E, w);
        });
      }, v.walkComments = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.COMMENT) return b.call(E, w);
        });
      }, v.walkIds = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.ID) return b.call(E, w);
        });
      }, v.walkNesting = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.NESTING) return b.call(E, w);
        });
      }, v.walkPseudos = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.PSEUDO) return b.call(E, w);
        });
      }, v.walkTags = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.TAG) return b.call(E, w);
        });
      }, v.walkUniversals = function(b) {
        var E = this;
        return this.walk(function(w) {
          if (w.type === i.UNIVERSAL) return b.call(E, w);
        });
      }, v.split = function(b) {
        var E = this, w = [];
        return this.reduce(function(C, A, O) {
          var D = b.call(E, A);
          return w.push(A), D ? (C.push(w), w = []) : O === E.length - 1 && C.push(w), C;
        }, []);
      }, v.map = function(b) {
        return this.nodes.map(b);
      }, v.reduce = function(b, E) {
        return this.nodes.reduce(b, E);
      }, v.every = function(b) {
        return this.nodes.every(b);
      }, v.some = function(b) {
        return this.nodes.some(b);
      }, v.filter = function(b) {
        return this.nodes.filter(b);
      }, v.sort = function(b) {
        return this.nodes.sort(b);
      }, v.toString = function() {
        return this.map(String).join("");
      }, p(y, [{ key: "first", get: function() {
        return this.at(0);
      } }, { key: "last", get: function() {
        return this.at(this.length - 1);
      } }, { key: "length", get: function() {
        return this.nodes.length;
      } }]), y;
    })(n.default);
    t.default = g, e.exports = t.default;
  })(il, il.exports)), il.exports;
}
function cb() {
  return Tf || (Tf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = eu()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(p, d, g) {
      return d && (function(f, x) {
        for (var m = 0; m < x.length; m++) {
          var y = x[m];
          y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(f, y.key, y);
        }
      })(p.prototype, d), Object.defineProperty(p, "prototype", { writable: !1 }), p;
    }
    function c(p, d) {
      return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(g, f) {
        return g.__proto__ = f, g;
      }, c(p, d);
    }
    var l = (function(p) {
      var d, g;
      function f(m) {
        var y;
        return (y = p.call(this, m) || this).type = i.ROOT, y;
      }
      g = p, (d = f).prototype = Object.create(g.prototype), d.prototype.constructor = d, c(d, g);
      var x = f.prototype;
      return x.toString = function() {
        var m = this.reduce(function(y, v) {
          return y.push(String(v)), y;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, x.error = function(m, y) {
        return this._error ? this._error(m, y) : new Error(m);
      }, o(f, [{ key: "errorGenerator", set: function(m) {
        this._error = m;
      } }]), f;
    })(n.default);
    t.default = l, e.exports = t.default;
  })(nl, nl.exports)), nl.exports;
}
var vf, hl = { exports: {} };
function lb() {
  return vf || (vf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = eu()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.SELECTOR, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(hl, hl.exports)), hl.exports;
}
var kf, Sf, Ef, ul = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
function tu() {
  if (Sf) return kf;
  Sf = 1;
  var e = {}.hasOwnProperty, t = /[ -,\.\/:-@\[-\^`\{-~]/, s = /[ -,\.\/:-@\[\]\^`\{-~]/, n = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, i = function o(c, l) {
    l = (function(w, C) {
      if (!w) return C;
      var A = {};
      for (var O in C) A[O] = e.call(w, O) ? w[O] : C[O];
      return A;
    })(l, o.options), l.quotes != "single" && l.quotes != "double" && (l.quotes = "single");
    for (var p = l.quotes == "double" ? '"' : "'", d = l.isIdentifier, g = c.charAt(0), f = "", x = 0, m = c.length; x < m; ) {
      var y = c.charAt(x++), v = y.charCodeAt(), b = void 0;
      if (v < 32 || v > 126) {
        if (v >= 55296 && v <= 56319 && x < m) {
          var E = c.charCodeAt(x++);
          (64512 & E) == 56320 ? v = ((1023 & v) << 10) + (1023 & E) + 65536 : x--;
        }
        b = "\\" + v.toString(16).toUpperCase() + " ";
      } else b = l.escapeEverything ? t.test(y) ? "\\" + y : "\\" + v.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(y) ? "\\" + v.toString(16).toUpperCase() + " " : y == "\\" || !d && (y == '"' && p == y || y == "'" && p == y) || d && s.test(y) ? "\\" + y : y;
      f += b;
    }
    return d && (/^-[-\d]/.test(f) ? f = "\\-" + f.slice(1) : /\d/.test(g) && (f = "\\3" + g + " " + f.slice(1))), f = f.replace(n, function(w, C, A) {
      return C && C.length % 2 ? w : (C || "") + A;
    }), !d && l.wrap ? p + f + p : f;
  };
  return i.options = { escapeEverything: !1, isIdentifier: !1, quotes: "single", wrap: !1 }, i.version = "3.0.0", kf = i;
}
function pb() {
  return Ef || (Ef = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s = c(tu()), n = ja(), i = c(ns()), o = Ct();
    function c(g) {
      return g && g.__esModule ? g : { default: g };
    }
    function l(g, f, x) {
      return f && (function(m, y) {
        for (var v = 0; v < y.length; v++) {
          var b = y[v];
          b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(m, b.key, b);
        }
      })(g.prototype, f), Object.defineProperty(g, "prototype", { writable: !1 }), g;
    }
    function p(g, f) {
      return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, m) {
        return x.__proto__ = m, x;
      }, p(g, f);
    }
    var d = (function(g) {
      var f, x;
      function m(y) {
        var v;
        return (v = g.call(this, y) || this).type = o.CLASS, v._constructed = !0, v;
      }
      return x = g, (f = m).prototype = Object.create(x.prototype), f.prototype.constructor = f, p(f, x), m.prototype.valueToString = function() {
        return "." + g.prototype.valueToString.call(this);
      }, l(m, [{ key: "value", get: function() {
        return this._value;
      }, set: function(y) {
        if (this._constructed) {
          var v = (0, s.default)(y, { isIdentifier: !0 });
          v !== y ? ((0, n.ensureObject)(this, "raws"), this.raws.value = v) : this.raws && delete this.raws.value;
        }
        this._value = y;
      } }]), m;
    })(i.default);
    t.default = d, e.exports = t.default;
  })(ul, ul.exports)), ul.exports;
}
var wf, dl = { exports: {} };
function hb() {
  return wf || (wf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.COMMENT, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(dl, dl.exports)), dl.exports;
}
var _f, fl = { exports: {} };
function ub() {
  return _f || (_f = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.ID, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g.prototype.valueToString = function() {
        return "#" + l.prototype.valueToString.call(this);
      }, g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(fl, fl.exports)), fl.exports;
}
var Pf, Af, ml = { exports: {} }, gl = { exports: {} };
function ru() {
  return Pf || (Pf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s = i(tu()), n = ja();
    function i(p) {
      return p && p.__esModule ? p : { default: p };
    }
    function o(p, d, g) {
      return d && (function(f, x) {
        for (var m = 0; m < x.length; m++) {
          var y = x[m];
          y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(f, y.key, y);
        }
      })(p.prototype, d), Object.defineProperty(p, "prototype", { writable: !1 }), p;
    }
    function c(p, d) {
      return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(g, f) {
        return g.__proto__ = f, g;
      }, c(p, d);
    }
    var l = (function(p) {
      var d, g;
      function f() {
        return p.apply(this, arguments) || this;
      }
      g = p, (d = f).prototype = Object.create(g.prototype), d.prototype.constructor = d, c(d, g);
      var x = f.prototype;
      return x.qualifiedName = function(m) {
        return this.namespace ? this.namespaceString + "|" + m : m;
      }, x.valueToString = function() {
        return this.qualifiedName(p.prototype.valueToString.call(this));
      }, o(f, [{ key: "namespace", get: function() {
        return this._namespace;
      }, set: function(m) {
        if (m === !0 || m === "*" || m === "&") return this._namespace = m, void (this.raws && delete this.raws.namespace);
        var y = (0, s.default)(m, { isIdentifier: !0 });
        this._namespace = m, y !== m ? ((0, n.ensureObject)(this, "raws"), this.raws.namespace = y) : this.raws && delete this.raws.namespace;
      } }, { key: "ns", get: function() {
        return this._namespace;
      }, set: function(m) {
        this.namespace = m;
      } }, { key: "namespaceString", get: function() {
        if (this.namespace) {
          var m = this.stringifyProperty("namespace");
          return m === !0 ? "" : m;
        }
        return "";
      } }]), f;
    })(i(ns()).default);
    t.default = l, e.exports = t.default;
  })(gl, gl.exports)), gl.exports;
}
function db() {
  return Af || (Af = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ru()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.TAG, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(ml, ml.exports)), ml.exports;
}
var Cf, yl = { exports: {} };
function fb() {
  return Cf || (Cf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.STRING, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(yl, yl.exports)), yl.exports;
}
var If, xl = { exports: {} };
function mb() {
  return If || (If = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = eu()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.PSEUDO, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g.prototype.toString = function() {
        var f = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), f, this.rawSpaceAfter].join("");
      }, g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(xl, xl.exports)), xl.exports;
}
var Nf, Of, Lf, Rf = {};
function uE() {
  return Of ? Nf : (Of = 1, Nf = KS.deprecate);
}
function gb() {
  return Lf || (Lf = 1, (function(e) {
    e.__esModule = !0, e.default = void 0, e.unescapeValue = y;
    var t, s = c(tu()), n = c(ab()), i = c(ru()), o = Ct();
    function c(w) {
      return w && w.__esModule ? w : { default: w };
    }
    function l(w, C, A) {
      return C && (function(O, D) {
        for (var N = 0; N < D.length; N++) {
          var j = D[N];
          j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(O, j.key, j);
        }
      })(w.prototype, C), Object.defineProperty(w, "prototype", { writable: !1 }), w;
    }
    function p(w, C) {
      return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(A, O) {
        return A.__proto__ = O, A;
      }, p(w, C);
    }
    var d = uE(), g = /^('|")([^]*)\1$/, f = d(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), x = d(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), m = d(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function y(w) {
      var C = !1, A = null, O = w, D = O.match(g);
      return D && (A = D[1], O = D[2]), (O = (0, n.default)(O)) !== w && (C = !0), { deprecatedUsage: C, unescaped: O, quoteMark: A };
    }
    var v = (function(w) {
      var C, A;
      function O(N) {
        var j;
        return N === void 0 && (N = {}), j = w.call(this, (function(U) {
          if (U.quoteMark !== void 0 || U.value === void 0) return U;
          m();
          var X = y(U.value), W = X.quoteMark, H = X.unescaped;
          return U.raws || (U.raws = {}), U.raws.value === void 0 && (U.raws.value = U.value), U.value = H, U.quoteMark = W, U;
        })(N)) || this, j.type = o.ATTRIBUTE, j.raws = j.raws || {}, Object.defineProperty(j.raws, "unquoted", { get: d(function() {
          return j.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: d(function() {
          return j.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), j._constructed = !0, j;
      }
      A = w, (C = O).prototype = Object.create(A.prototype), C.prototype.constructor = C, p(C, A);
      var D = O.prototype;
      return D.getQuotedValue = function(N) {
        N === void 0 && (N = {});
        var j = this._determineQuoteMark(N), U = b[j];
        return (0, s.default)(this._value, U);
      }, D._determineQuoteMark = function(N) {
        return N.smart ? this.smartQuoteMark(N) : this.preferredQuoteMark(N);
      }, D.setValue = function(N, j) {
        j === void 0 && (j = {}), this._value = N, this._quoteMark = this._determineQuoteMark(j), this._syncRawValue();
      }, D.smartQuoteMark = function(N) {
        var j = this.value, U = j.replace(/[^']/g, "").length, X = j.replace(/[^"]/g, "").length;
        if (U + X === 0) {
          var W = (0, s.default)(j, { isIdentifier: !0 });
          if (W === j) return O.NO_QUOTE;
          var H = this.preferredQuoteMark(N);
          if (H === O.NO_QUOTE) {
            var F = this.quoteMark || N.quoteMark || O.DOUBLE_QUOTE, q = b[F];
            if ((0, s.default)(j, q).length < W.length) return F;
          }
          return H;
        }
        return X === U ? this.preferredQuoteMark(N) : X < U ? O.DOUBLE_QUOTE : O.SINGLE_QUOTE;
      }, D.preferredQuoteMark = function(N) {
        var j = N.preferCurrentQuoteMark ? this.quoteMark : N.quoteMark;
        return j === void 0 && (j = N.preferCurrentQuoteMark ? N.quoteMark : this.quoteMark), j === void 0 && (j = O.DOUBLE_QUOTE), j;
      }, D._syncRawValue = function() {
        var N = (0, s.default)(this._value, b[this.quoteMark]);
        N === this._value ? this.raws && delete this.raws.value : this.raws.value = N;
      }, D._handleEscapes = function(N, j) {
        if (this._constructed) {
          var U = (0, s.default)(j, { isIdentifier: !0 });
          U !== j ? this.raws[N] = U : delete this.raws[N];
        }
      }, D._spacesFor = function(N) {
        var j = this.spaces[N] || {}, U = this.raws.spaces && this.raws.spaces[N] || {};
        return Object.assign({ before: "", after: "" }, j, U);
      }, D._stringFor = function(N, j, U) {
        j === void 0 && (j = N), U === void 0 && (U = E);
        var X = this._spacesFor(j);
        return U(this.stringifyProperty(N), X);
      }, D.offsetOf = function(N) {
        var j = 1, U = this._spacesFor("attribute");
        if (j += U.before.length, N === "namespace" || N === "ns") return this.namespace ? j : -1;
        if (N === "attributeNS" || (j += this.namespaceString.length, this.namespace && (j += 1), N === "attribute")) return j;
        j += this.stringifyProperty("attribute").length, j += U.after.length;
        var X = this._spacesFor("operator");
        j += X.before.length;
        var W = this.stringifyProperty("operator");
        if (N === "operator") return W ? j : -1;
        j += W.length, j += X.after.length;
        var H = this._spacesFor("value");
        j += H.before.length;
        var F = this.stringifyProperty("value");
        return N === "value" ? F ? j : -1 : (j += F.length, j += H.after.length, j += this._spacesFor("insensitive").before.length, N === "insensitive" && this.insensitive ? j : -1);
      }, D.toString = function() {
        var N = this, j = [this.rawSpaceBefore, "["];
        return j.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (j.push(this._stringFor("operator")), j.push(this._stringFor("value")), j.push(this._stringFor("insensitiveFlag", "insensitive", function(U, X) {
          return !(U.length > 0) || N.quoted || X.before.length !== 0 || N.spaces.value && N.spaces.value.after || (X.before = " "), E(U, X);
        }))), j.push("]"), j.push(this.rawSpaceAfter), j.join("");
      }, l(O, [{ key: "quoted", get: function() {
        var N = this.quoteMark;
        return N === "'" || N === '"';
      }, set: function(N) {
        x();
      } }, { key: "quoteMark", get: function() {
        return this._quoteMark;
      }, set: function(N) {
        this._constructed ? this._quoteMark !== N && (this._quoteMark = N, this._syncRawValue()) : this._quoteMark = N;
      } }, { key: "qualifiedAttribute", get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      } }, { key: "insensitiveFlag", get: function() {
        return this.insensitive ? "i" : "";
      } }, { key: "value", get: function() {
        return this._value;
      }, set: function(N) {
        if (this._constructed) {
          var j = y(N), U = j.deprecatedUsage, X = j.unescaped, W = j.quoteMark;
          if (U && f(), X === this._value && W === this._quoteMark) return;
          this._value = X, this._quoteMark = W, this._syncRawValue();
        } else this._value = N;
      } }, { key: "insensitive", get: function() {
        return this._insensitive;
      }, set: function(N) {
        N || (this._insensitive = !1, !this.raws || this.raws.insensitiveFlag !== "I" && this.raws.insensitiveFlag !== "i" || (this.raws.insensitiveFlag = void 0)), this._insensitive = N;
      } }, { key: "attribute", get: function() {
        return this._attribute;
      }, set: function(N) {
        this._handleEscapes("attribute", N), this._attribute = N;
      } }]), O;
    })(i.default);
    e.default = v, v.NO_QUOTE = null, v.SINGLE_QUOTE = "'", v.DOUBLE_QUOTE = '"';
    var b = ((t = { "'": { quotes: "single", wrap: !0 }, '"': { quotes: "double", wrap: !0 } }).null = { isIdentifier: !0 }, t);
    function E(w, C) {
      return "" + C.before + w + C.after;
    }
  })(Rf)), Rf;
}
var Mf, bl = { exports: {} };
function yb() {
  return Mf || (Mf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ru()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.UNIVERSAL, x.value = "*", x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(bl, bl.exports)), bl.exports;
}
var Df, Tl = { exports: {} };
function xb() {
  return Df || (Df = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.COMBINATOR, x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(Tl, Tl.exports)), Tl.exports;
}
var Ff, vl = { exports: {} };
function bb() {
  return Ff || (Ff = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = ns()) && s.__esModule ? s : { default: s }, i = Ct();
    function o(l, p) {
      return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, g) {
        return d.__proto__ = g, d;
      }, o(l, p);
    }
    var c = (function(l) {
      var p, d;
      function g(f) {
        var x;
        return (x = l.call(this, f) || this).type = i.NESTING, x.value = "&", x;
      }
      return d = l, (p = g).prototype = Object.create(d.prototype), p.prototype.constructor = p, o(p, d), g;
    })(n.default);
    t.default = c, e.exports = t.default;
  })(vl, vl.exports)), vl.exports;
}
var jf, kl = { exports: {} };
function dE() {
  return jf || (jf = 1, e = kl, (t = kl.exports).__esModule = !0, t.default = function(s) {
    return s.sort(function(n, i) {
      return n - i;
    });
  }, e.exports = t.default), kl.exports;
  var e, t;
}
var Bf, Uf, $f, qf, Vf = {}, xe = {};
function Tb() {
  return Bf ? xe : (Bf = 1, xe.__esModule = !0, xe.word = xe.tilde = xe.tab = xe.str = xe.space = xe.slash = xe.singleQuote = xe.semicolon = xe.plus = xe.pipe = xe.openSquare = xe.openParenthesis = xe.newline = xe.greaterThan = xe.feed = xe.equals = xe.doubleQuote = xe.dollar = xe.cr = xe.comment = xe.comma = xe.combinator = xe.colon = xe.closeSquare = xe.closeParenthesis = xe.caret = xe.bang = xe.backslash = xe.at = xe.asterisk = xe.ampersand = void 0, xe.ampersand = 38, xe.asterisk = 42, xe.at = 64, xe.comma = 44, xe.colon = 58, xe.semicolon = 59, xe.openParenthesis = 40, xe.closeParenthesis = 41, xe.openSquare = 91, xe.closeSquare = 93, xe.dollar = 36, xe.tilde = 126, xe.caret = 94, xe.plus = 43, xe.equals = 61, xe.pipe = 124, xe.greaterThan = 62, xe.space = 32, xe.singleQuote = 39, xe.doubleQuote = 34, xe.slash = 47, xe.bang = 33, xe.backslash = 92, xe.cr = 13, xe.feed = 12, xe.newline = 10, xe.tab = 9, xe.str = 39, xe.comment = -1, xe.word = -2, xe.combinator = -3, xe);
}
function fE() {
  return Uf || (Uf = 1, (function(e) {
    e.__esModule = !0, e.FIELDS = void 0, e.default = function(x) {
      var m, y, v, b, E, w, C, A, O, D, N, j, U = [], X = x.css.valueOf(), W = X.length, H = -1, F = 1, q = 0, G = 0;
      function ee(ce, Te) {
        if (!x.safe) throw x.error("Unclosed " + ce, F, q - H, q);
        A = (X += Te).length - 1;
      }
      for (; q < W; ) {
        switch ((m = X.charCodeAt(q)) === n.newline && (H = q, F += 1), m) {
          case n.space:
          case n.tab:
          case n.newline:
          case n.cr:
          case n.feed:
            A = q;
            do
              A += 1, (m = X.charCodeAt(A)) === n.newline && (H = A, F += 1);
            while (m === n.space || m === n.newline || m === n.tab || m === n.cr || m === n.feed);
            j = n.space, v = F, y = A - H - 1, G = A;
            break;
          case n.plus:
          case n.greaterThan:
          case n.tilde:
          case n.pipe:
            A = q;
            do
              A += 1, m = X.charCodeAt(A);
            while (m === n.plus || m === n.greaterThan || m === n.tilde || m === n.pipe);
            j = n.combinator, v = F, y = q - H, G = A;
            break;
          case n.asterisk:
          case n.ampersand:
          case n.bang:
          case n.comma:
          case n.equals:
          case n.dollar:
          case n.caret:
          case n.openSquare:
          case n.closeSquare:
          case n.colon:
          case n.semicolon:
          case n.openParenthesis:
          case n.closeParenthesis:
            j = m, v = F, y = q - H, G = (A = q) + 1;
            break;
          case n.singleQuote:
          case n.doubleQuote:
            N = m === n.singleQuote ? "'" : '"', A = q;
            do
              for (b = !1, (A = X.indexOf(N, A + 1)) === -1 && ee("quote", N), E = A; X.charCodeAt(E - 1) === n.backslash; ) E -= 1, b = !b;
            while (b);
            j = n.str, v = F, y = q - H, G = A + 1;
            break;
          default:
            m === n.slash && X.charCodeAt(q + 1) === n.asterisk ? ((A = X.indexOf("*/", q + 2) + 1) === 0 && ee("comment", "*/"), (w = (C = X.slice(q, A + 1).split(`
`)).length - 1) > 0 ? (O = F + w, D = A - C[w].length) : (O = F, D = H), j = n.comment, F = O, v = O, y = A - D) : m === n.slash ? (j = m, v = F, y = q - H, G = (A = q) + 1) : (A = g(X, q), j = n.word, v = F, y = A - H), G = A + 1;
        }
        U.push([j, F, q - H, v, y, q, G]), D && (H = D, D = null), q = G;
      }
      return U;
    };
    var t, s, n = (function(x, m) {
      if (x && x.__esModule) return x;
      if (x === null || typeof x != "object" && typeof x != "function") return { default: x };
      var y = i(m);
      if (y && y.has(x)) return y.get(x);
      var v = {}, b = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var E in x) if (E !== "default" && Object.prototype.hasOwnProperty.call(x, E)) {
        var w = b ? Object.getOwnPropertyDescriptor(x, E) : null;
        w && (w.get || w.set) ? Object.defineProperty(v, E, w) : v[E] = x[E];
      }
      return v.default = x, y && y.set(x, v), v;
    })(Tb());
    function i(x) {
      if (typeof WeakMap != "function") return null;
      var m = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
      return (i = function(v) {
        return v ? y : m;
      })(x);
    }
    for (var o = ((t = {})[n.tab] = !0, t[n.newline] = !0, t[n.cr] = !0, t[n.feed] = !0, t), c = ((s = {})[n.space] = !0, s[n.tab] = !0, s[n.newline] = !0, s[n.cr] = !0, s[n.feed] = !0, s[n.ampersand] = !0, s[n.asterisk] = !0, s[n.bang] = !0, s[n.comma] = !0, s[n.colon] = !0, s[n.semicolon] = !0, s[n.openParenthesis] = !0, s[n.closeParenthesis] = !0, s[n.openSquare] = !0, s[n.closeSquare] = !0, s[n.singleQuote] = !0, s[n.doubleQuote] = !0, s[n.plus] = !0, s[n.pipe] = !0, s[n.tilde] = !0, s[n.greaterThan] = !0, s[n.equals] = !0, s[n.dollar] = !0, s[n.caret] = !0, s[n.slash] = !0, s), l = {}, p = "0123456789abcdefABCDEF", d = 0; d < 22; d++) l[p.charCodeAt(d)] = !0;
    function g(x, m) {
      var y, v = m;
      do {
        if (y = x.charCodeAt(v), c[y]) return v - 1;
        y === n.backslash ? v = f(x, v) + 1 : v++;
      } while (v < x.length);
      return v - 1;
    }
    function f(x, m) {
      var y = m, v = x.charCodeAt(y + 1);
      if (!o[v]) if (l[v]) {
        var b = 0;
        do
          y++, b++, v = x.charCodeAt(y + 1);
        while (l[v] && b < 6);
        b < 6 && v === n.space && y++;
      } else y++;
      return y;
    }
    e.FIELDS = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  })(Vf)), Vf;
}
function mE() {
  return $f || ($f = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n, i = N(cb()), o = N(lb()), c = N(pb()), l = N(hb()), p = N(ub()), d = N(db()), g = N(fb()), f = N(mb()), x = D(gb()), m = N(yb()), y = N(xb()), v = N(bb()), b = N(dE()), E = D(fE()), w = D(Tb()), C = D(Ct()), A = ja();
    function O(Q) {
      if (typeof WeakMap != "function") return null;
      var pe = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap();
      return (O = function($) {
        return $ ? J : pe;
      })(Q);
    }
    function D(Q, pe) {
      if (Q && Q.__esModule) return Q;
      if (Q === null || typeof Q != "object" && typeof Q != "function") return { default: Q };
      var J = O(pe);
      if (J && J.has(Q)) return J.get(Q);
      var $ = {}, oe = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var Y in Q) if (Y !== "default" && Object.prototype.hasOwnProperty.call(Q, Y)) {
        var se = oe ? Object.getOwnPropertyDescriptor(Q, Y) : null;
        se && (se.get || se.set) ? Object.defineProperty($, Y, se) : $[Y] = Q[Y];
      }
      return $.default = Q, J && J.set(Q, $), $;
    }
    function N(Q) {
      return Q && Q.__esModule ? Q : { default: Q };
    }
    function j(Q, pe, J) {
      return pe && (function($, oe) {
        for (var Y = 0; Y < oe.length; Y++) {
          var se = oe[Y];
          se.enumerable = se.enumerable || !1, se.configurable = !0, "value" in se && (se.writable = !0), Object.defineProperty($, se.key, se);
        }
      })(Q.prototype, pe), Object.defineProperty(Q, "prototype", { writable: !1 }), Q;
    }
    var U = ((s = {})[w.space] = !0, s[w.cr] = !0, s[w.feed] = !0, s[w.newline] = !0, s[w.tab] = !0, s), X = Object.assign({}, U, ((n = {})[w.comment] = !0, n));
    function W(Q) {
      return { line: Q[E.FIELDS.START_LINE], column: Q[E.FIELDS.START_COL] };
    }
    function H(Q) {
      return { line: Q[E.FIELDS.END_LINE], column: Q[E.FIELDS.END_COL] };
    }
    function F(Q, pe, J, $) {
      return { start: { line: Q, column: pe }, end: { line: J, column: $ } };
    }
    function q(Q) {
      return F(Q[E.FIELDS.START_LINE], Q[E.FIELDS.START_COL], Q[E.FIELDS.END_LINE], Q[E.FIELDS.END_COL]);
    }
    function G(Q, pe) {
      if (Q) return F(Q[E.FIELDS.START_LINE], Q[E.FIELDS.START_COL], pe[E.FIELDS.END_LINE], pe[E.FIELDS.END_COL]);
    }
    function ee(Q, pe) {
      var J = Q[pe];
      if (typeof J == "string") return J.indexOf("\\") !== -1 && ((0, A.ensureObject)(Q, "raws"), Q[pe] = (0, A.unesc)(J), Q.raws[pe] === void 0 && (Q.raws[pe] = J)), Q;
    }
    function ce(Q, pe) {
      for (var J = -1, $ = []; (J = Q.indexOf(pe, J + 1)) !== -1; ) $.push(J);
      return $;
    }
    var Te = (function() {
      function Q(J, $) {
        $ === void 0 && ($ = {}), this.rule = J, this.options = Object.assign({ lossy: !1, safe: !1 }, $), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, E.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
        var oe = G(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new i.default({ source: oe }), this.root.errorGenerator = this._errorGenerator();
        var Y = new o.default({ source: { start: { line: 1, column: 1 } }, sourceIndex: 0 });
        this.root.append(Y), this.current = Y, this.loop();
      }
      var pe = Q.prototype;
      return pe._errorGenerator = function() {
        var J = this;
        return function($, oe) {
          return typeof J.rule == "string" ? new Error($) : J.rule.error($, oe);
        };
      }, pe.attribute = function() {
        var J = [], $ = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[E.FIELDS.TYPE] !== w.closeSquare; ) J.push(this.currToken), this.position++;
        if (this.currToken[E.FIELDS.TYPE] !== w.closeSquare) return this.expected("closing square bracket", this.currToken[E.FIELDS.START_POS]);
        var oe = J.length, Y = { source: F($[1], $[2], this.currToken[3], this.currToken[4]), sourceIndex: $[E.FIELDS.START_POS] };
        if (oe === 1 && !~[w.word].indexOf(J[0][E.FIELDS.TYPE])) return this.expected("attribute", J[0][E.FIELDS.START_POS]);
        for (var se = 0, z = "", ie = "", ae = null, ge = !1; se < oe; ) {
          var Ee = J[se], fe = this.content(Ee), me = J[se + 1];
          switch (Ee[E.FIELDS.TYPE]) {
            case w.space:
              if (ge = !0, this.options.lossy) break;
              if (ae) {
                (0, A.ensureObject)(Y, "spaces", ae);
                var Oe = Y.spaces[ae].after || "";
                Y.spaces[ae].after = Oe + fe;
                var qe = (0, A.getProp)(Y, "raws", "spaces", ae, "after") || null;
                qe && (Y.raws.spaces[ae].after = qe + fe);
              } else z += fe, ie += fe;
              break;
            case w.asterisk:
              me[E.FIELDS.TYPE] === w.equals ? (Y.operator = fe, ae = "operator") : (!Y.namespace || ae === "namespace" && !ge) && me && (z && ((0, A.ensureObject)(Y, "spaces", "attribute"), Y.spaces.attribute.before = z, z = ""), ie && ((0, A.ensureObject)(Y, "raws", "spaces", "attribute"), Y.raws.spaces.attribute.before = z, ie = ""), Y.namespace = (Y.namespace || "") + fe, (0, A.getProp)(Y, "raws", "namespace") && (Y.raws.namespace += fe), ae = "namespace"), ge = !1;
              break;
            case w.dollar:
              if (ae === "value") {
                var Me = (0, A.getProp)(Y, "raws", "value");
                Y.value += "$", Me && (Y.raws.value = Me + "$");
                break;
              }
            case w.caret:
              me[E.FIELDS.TYPE] === w.equals && (Y.operator = fe, ae = "operator"), ge = !1;
              break;
            case w.combinator:
              if (fe === "~" && me[E.FIELDS.TYPE] === w.equals && (Y.operator = fe, ae = "operator"), fe !== "|") {
                ge = !1;
                break;
              }
              me[E.FIELDS.TYPE] === w.equals ? (Y.operator = fe, ae = "operator") : Y.namespace || Y.attribute || (Y.namespace = !0), ge = !1;
              break;
            case w.word:
              if (me && this.content(me) === "|" && J[se + 2] && J[se + 2][E.FIELDS.TYPE] !== w.equals && !Y.operator && !Y.namespace) Y.namespace = fe, ae = "namespace";
              else if (!Y.attribute || ae === "attribute" && !ge)
                z && ((0, A.ensureObject)(Y, "spaces", "attribute"), Y.spaces.attribute.before = z, z = ""), ie && ((0, A.ensureObject)(Y, "raws", "spaces", "attribute"), Y.raws.spaces.attribute.before = ie, ie = ""), Y.attribute = (Y.attribute || "") + fe, (0, A.getProp)(Y, "raws", "attribute") && (Y.raws.attribute += fe), ae = "attribute";
              else if (!Y.value && Y.value !== "" || ae === "value" && !ge && !Y.quoteMark) {
                var at = (0, A.unesc)(fe), St = (0, A.getProp)(Y, "raws", "value") || "", Zt = Y.value || "";
                Y.value = Zt + at, Y.quoteMark = null, (at !== fe || St) && ((0, A.ensureObject)(Y, "raws"), Y.raws.value = (St || Zt) + fe), ae = "value";
              } else {
                var hr = fe === "i" || fe === "I";
                !Y.value && Y.value !== "" || !Y.quoteMark && !ge ? (Y.value || Y.value === "") && (ae = "value", Y.value += fe, Y.raws.value && (Y.raws.value += fe)) : (Y.insensitive = hr, hr && fe !== "I" || ((0, A.ensureObject)(Y, "raws"), Y.raws.insensitiveFlag = fe), ae = "insensitive", z && ((0, A.ensureObject)(Y, "spaces", "insensitive"), Y.spaces.insensitive.before = z, z = ""), ie && ((0, A.ensureObject)(Y, "raws", "spaces", "insensitive"), Y.raws.spaces.insensitive.before = ie, ie = ""));
              }
              ge = !1;
              break;
            case w.str:
              if (!Y.attribute || !Y.operator) return this.error("Expected an attribute followed by an operator preceding the string.", { index: Ee[E.FIELDS.START_POS] });
              var os = (0, x.unescapeValue)(fe), Tn = os.unescaped, Dr = os.quoteMark;
              Y.value = Tn, Y.quoteMark = Dr, ae = "value", (0, A.ensureObject)(Y, "raws"), Y.raws.value = fe, ge = !1;
              break;
            case w.equals:
              if (!Y.attribute) return this.expected("attribute", Ee[E.FIELDS.START_POS], fe);
              if (Y.value) return this.error('Unexpected "=" found; an operator was already defined.', { index: Ee[E.FIELDS.START_POS] });
              Y.operator = Y.operator ? Y.operator + fe : fe, ae = "operator", ge = !1;
              break;
            case w.comment:
              if (ae) if (ge || me && me[E.FIELDS.TYPE] === w.space || ae === "insensitive") {
                var er = (0, A.getProp)(Y, "spaces", ae, "after") || "", Fr = (0, A.getProp)(Y, "raws", "spaces", ae, "after") || er;
                (0, A.ensureObject)(Y, "raws", "spaces", ae), Y.raws.spaces[ae].after = Fr + fe;
              } else {
                var Ka = Y[ae] || "", Ja = (0, A.getProp)(Y, "raws", ae) || Ka;
                (0, A.ensureObject)(Y, "raws"), Y.raws[ae] = Ja + fe;
              }
              else ie += fe;
              break;
            default:
              return this.error('Unexpected "' + fe + '" found.', { index: Ee[E.FIELDS.START_POS] });
          }
          se++;
        }
        ee(Y, "attribute"), ee(Y, "namespace"), this.newNode(new x.default(Y)), this.position++;
      }, pe.parseWhitespaceEquivalentTokens = function(J) {
        J < 0 && (J = this.tokens.length);
        var $ = this.position, oe = [], Y = "", se = void 0;
        do
          if (U[this.currToken[E.FIELDS.TYPE]]) this.options.lossy || (Y += this.content());
          else if (this.currToken[E.FIELDS.TYPE] === w.comment) {
            var z = {};
            Y && (z.before = Y, Y = ""), se = new l.default({ value: this.content(), source: q(this.currToken), sourceIndex: this.currToken[E.FIELDS.START_POS], spaces: z }), oe.push(se);
          }
        while (++this.position < J);
        if (Y) {
          if (se) se.spaces.after = Y;
          else if (!this.options.lossy) {
            var ie = this.tokens[$], ae = this.tokens[this.position - 1];
            oe.push(new g.default({ value: "", source: F(ie[E.FIELDS.START_LINE], ie[E.FIELDS.START_COL], ae[E.FIELDS.END_LINE], ae[E.FIELDS.END_COL]), sourceIndex: ie[E.FIELDS.START_POS], spaces: { before: Y, after: "" } }));
          }
        }
        return oe;
      }, pe.convertWhitespaceNodesToSpace = function(J, $) {
        var oe = this;
        $ === void 0 && ($ = !1);
        var Y = "", se = "";
        return J.forEach(function(z) {
          var ie = oe.lossySpace(z.spaces.before, $), ae = oe.lossySpace(z.rawSpaceBefore, $);
          Y += ie + oe.lossySpace(z.spaces.after, $ && ie.length === 0), se += ie + z.value + oe.lossySpace(z.rawSpaceAfter, $ && ae.length === 0);
        }), se === Y && (se = void 0), { space: Y, rawSpace: se };
      }, pe.isNamedCombinator = function(J) {
        return J === void 0 && (J = this.position), this.tokens[J + 0] && this.tokens[J + 0][E.FIELDS.TYPE] === w.slash && this.tokens[J + 1] && this.tokens[J + 1][E.FIELDS.TYPE] === w.word && this.tokens[J + 2] && this.tokens[J + 2][E.FIELDS.TYPE] === w.slash;
      }, pe.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var J = this.content(this.tokens[this.position + 1]), $ = (0, A.unesc)(J).toLowerCase(), oe = {};
          $ !== J && (oe.value = "/" + J + "/");
          var Y = new y.default({ value: "/" + $ + "/", source: F(this.currToken[E.FIELDS.START_LINE], this.currToken[E.FIELDS.START_COL], this.tokens[this.position + 2][E.FIELDS.END_LINE], this.tokens[this.position + 2][E.FIELDS.END_COL]), sourceIndex: this.currToken[E.FIELDS.START_POS], raws: oe });
          return this.position = this.position + 3, Y;
        }
        this.unexpected();
      }, pe.combinator = function() {
        var J = this;
        if (this.content() === "|") return this.namespace();
        var $ = this.locateNextMeaningfulToken(this.position);
        if (!($ < 0 || this.tokens[$][E.FIELDS.TYPE] === w.comma || this.tokens[$][E.FIELDS.TYPE] === w.closeParenthesis)) {
          var oe, Y = this.currToken, se = void 0;
          if ($ > this.position && (se = this.parseWhitespaceEquivalentTokens($)), this.isNamedCombinator() ? oe = this.namedCombinator() : this.currToken[E.FIELDS.TYPE] === w.combinator ? (oe = new y.default({ value: this.content(), source: q(this.currToken), sourceIndex: this.currToken[E.FIELDS.START_POS] }), this.position++) : U[this.currToken[E.FIELDS.TYPE]] || se || this.unexpected(), oe) {
            if (se) {
              var z = this.convertWhitespaceNodesToSpace(se), ie = z.space, ae = z.rawSpace;
              oe.spaces.before = ie, oe.rawSpaceBefore = ae;
            }
          } else {
            var ge = this.convertWhitespaceNodesToSpace(se, !0), Ee = ge.space, fe = ge.rawSpace;
            fe || (fe = Ee);
            var me = {}, Oe = { spaces: {} };
            Ee.endsWith(" ") && fe.endsWith(" ") ? (me.before = Ee.slice(0, Ee.length - 1), Oe.spaces.before = fe.slice(0, fe.length - 1)) : Ee.startsWith(" ") && fe.startsWith(" ") ? (me.after = Ee.slice(1), Oe.spaces.after = fe.slice(1)) : Oe.value = fe, oe = new y.default({ value: " ", source: G(Y, this.tokens[this.position - 1]), sourceIndex: Y[E.FIELDS.START_POS], spaces: me, raws: Oe });
          }
          return this.currToken && this.currToken[E.FIELDS.TYPE] === w.space && (oe.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(oe);
        }
        var qe = this.parseWhitespaceEquivalentTokens($);
        if (qe.length > 0) {
          var Me = this.current.last;
          if (Me) {
            var at = this.convertWhitespaceNodesToSpace(qe), St = at.space, Zt = at.rawSpace;
            Zt !== void 0 && (Me.rawSpaceAfter += Zt), Me.spaces.after += St;
          } else qe.forEach(function(hr) {
            return J.newNode(hr);
          });
        }
      }, pe.comma = function() {
        if (this.position === this.tokens.length - 1) return this.root.trailingComma = !0, void this.position++;
        this.current._inferEndPosition();
        var J = new o.default({ source: { start: W(this.tokens[this.position + 1]) }, sourceIndex: this.tokens[this.position + 1][E.FIELDS.START_POS] });
        this.current.parent.append(J), this.current = J, this.position++;
      }, pe.comment = function() {
        var J = this.currToken;
        this.newNode(new l.default({ value: this.content(), source: q(J), sourceIndex: J[E.FIELDS.START_POS] })), this.position++;
      }, pe.error = function(J, $) {
        throw this.root.error(J, $);
      }, pe.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[E.FIELDS.START_POS] });
      }, pe.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[E.FIELDS.START_POS]);
      }, pe.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[E.FIELDS.START_POS]);
      }, pe.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[E.FIELDS.START_POS]);
      }, pe.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[E.FIELDS.START_POS]);
      }, pe.namespace = function() {
        var J = this.prevToken && this.content(this.prevToken) || !0;
        return this.nextToken[E.FIELDS.TYPE] === w.word ? (this.position++, this.word(J)) : this.nextToken[E.FIELDS.TYPE] === w.asterisk ? (this.position++, this.universal(J)) : void this.unexpectedPipe();
      }, pe.nesting = function() {
        if (this.nextToken && this.content(this.nextToken) === "|") return void this.position++;
        var J = this.currToken;
        this.newNode(new v.default({ value: this.content(), source: q(J), sourceIndex: J[E.FIELDS.START_POS] })), this.position++;
      }, pe.parentheses = function() {
        var J = this.current.last, $ = 1;
        if (this.position++, J && J.type === C.PSEUDO) {
          var oe = new o.default({ source: { start: W(this.tokens[this.position]) }, sourceIndex: this.tokens[this.position][E.FIELDS.START_POS] }), Y = this.current;
          for (J.append(oe), this.current = oe; this.position < this.tokens.length && $; ) this.currToken[E.FIELDS.TYPE] === w.openParenthesis && $++, this.currToken[E.FIELDS.TYPE] === w.closeParenthesis && $--, $ ? this.parse() : (this.current.source.end = H(this.currToken), this.current.parent.source.end = H(this.currToken), this.position++);
          this.current = Y;
        } else {
          for (var se, z = this.currToken, ie = "("; this.position < this.tokens.length && $; ) this.currToken[E.FIELDS.TYPE] === w.openParenthesis && $++, this.currToken[E.FIELDS.TYPE] === w.closeParenthesis && $--, se = this.currToken, ie += this.parseParenthesisToken(this.currToken), this.position++;
          J ? J.appendToPropertyAndEscape("value", ie, ie) : this.newNode(new g.default({ value: ie, source: F(z[E.FIELDS.START_LINE], z[E.FIELDS.START_COL], se[E.FIELDS.END_LINE], se[E.FIELDS.END_COL]), sourceIndex: z[E.FIELDS.START_POS] }));
        }
        if ($) return this.expected("closing parenthesis", this.currToken[E.FIELDS.START_POS]);
      }, pe.pseudo = function() {
        for (var J = this, $ = "", oe = this.currToken; this.currToken && this.currToken[E.FIELDS.TYPE] === w.colon; ) $ += this.content(), this.position++;
        return this.currToken ? this.currToken[E.FIELDS.TYPE] !== w.word ? this.expected(["pseudo-class", "pseudo-element"], this.currToken[E.FIELDS.START_POS]) : void this.splitWord(!1, function(Y, se) {
          $ += Y, J.newNode(new f.default({ value: $, source: G(oe, J.currToken), sourceIndex: oe[E.FIELDS.START_POS] })), se > 1 && J.nextToken && J.nextToken[E.FIELDS.TYPE] === w.openParenthesis && J.error("Misplaced parenthesis.", { index: J.nextToken[E.FIELDS.START_POS] });
        }) : this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      }, pe.space = function() {
        var J = this.content();
        this.position === 0 || this.prevToken[E.FIELDS.TYPE] === w.comma || this.prevToken[E.FIELDS.TYPE] === w.openParenthesis || this.current.nodes.every(function($) {
          return $.type === "comment";
        }) ? (this.spaces = this.optionalSpace(J), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[E.FIELDS.TYPE] === w.comma || this.nextToken[E.FIELDS.TYPE] === w.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(J), this.position++) : this.combinator();
      }, pe.string = function() {
        var J = this.currToken;
        this.newNode(new g.default({ value: this.content(), source: q(J), sourceIndex: J[E.FIELDS.START_POS] })), this.position++;
      }, pe.universal = function(J) {
        var $ = this.nextToken;
        if ($ && this.content($) === "|") return this.position++, this.namespace();
        var oe = this.currToken;
        this.newNode(new m.default({ value: this.content(), source: q(oe), sourceIndex: oe[E.FIELDS.START_POS] }), J), this.position++;
      }, pe.splitWord = function(J, $) {
        for (var oe = this, Y = this.nextToken, se = this.content(); Y && ~[w.dollar, w.caret, w.equals, w.word].indexOf(Y[E.FIELDS.TYPE]); ) {
          this.position++;
          var z = this.content();
          if (se += z, z.lastIndexOf("\\") === z.length - 1) {
            var ie = this.nextToken;
            ie && ie[E.FIELDS.TYPE] === w.space && (se += this.requiredSpace(this.content(ie)), this.position++);
          }
          Y = this.nextToken;
        }
        var ae = ce(se, ".").filter(function(me) {
          var Oe = se[me - 1] === "\\", qe = /^\d+\.\d+%$/.test(se);
          return !Oe && !qe;
        }), ge = ce(se, "#").filter(function(me) {
          return se[me - 1] !== "\\";
        }), Ee = ce(se, "#{");
        Ee.length && (ge = ge.filter(function(me) {
          return !~Ee.indexOf(me);
        }));
        var fe = (0, b.default)((function() {
          var me = Array.prototype.concat.apply([], arguments);
          return me.filter(function(Oe, qe) {
            return qe === me.indexOf(Oe);
          });
        })([0].concat(ae, ge)));
        fe.forEach(function(me, Oe) {
          var qe, Me = fe[Oe + 1] || se.length, at = se.slice(me, Me);
          if (Oe === 0 && $) return $.call(oe, at, fe.length);
          var St = oe.currToken, Zt = St[E.FIELDS.START_POS] + fe[Oe], hr = F(St[1], St[2] + me, St[3], St[2] + (Me - 1));
          if (~ae.indexOf(me)) {
            var os = { value: at.slice(1), source: hr, sourceIndex: Zt };
            qe = new c.default(ee(os, "value"));
          } else if (~ge.indexOf(me)) {
            var Tn = { value: at.slice(1), source: hr, sourceIndex: Zt };
            qe = new p.default(ee(Tn, "value"));
          } else {
            var Dr = { value: at, source: hr, sourceIndex: Zt };
            ee(Dr, "value"), qe = new d.default(Dr);
          }
          oe.newNode(qe, J), J = null;
        }), this.position++;
      }, pe.word = function(J) {
        var $ = this.nextToken;
        return $ && this.content($) === "|" ? (this.position++, this.namespace()) : this.splitWord(J);
      }, pe.loop = function() {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.current._inferEndPosition(), this.root;
      }, pe.parse = function(J) {
        switch (this.currToken[E.FIELDS.TYPE]) {
          case w.space:
            this.space();
            break;
          case w.comment:
            this.comment();
            break;
          case w.openParenthesis:
            this.parentheses();
            break;
          case w.closeParenthesis:
            J && this.missingParenthesis();
            break;
          case w.openSquare:
            this.attribute();
            break;
          case w.dollar:
          case w.caret:
          case w.equals:
          case w.word:
            this.word();
            break;
          case w.colon:
            this.pseudo();
            break;
          case w.comma:
            this.comma();
            break;
          case w.asterisk:
            this.universal();
            break;
          case w.ampersand:
            this.nesting();
            break;
          case w.slash:
          case w.combinator:
            this.combinator();
            break;
          case w.str:
            this.string();
            break;
          case w.closeSquare:
            this.missingSquareBracket();
          case w.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, pe.expected = function(J, $, oe) {
        if (Array.isArray(J)) {
          var Y = J.pop();
          J = J.join(", ") + " or " + Y;
        }
        var se = /^[aeiou]/.test(J[0]) ? "an" : "a";
        return oe ? this.error("Expected " + se + " " + J + ', found "' + oe + '" instead.', { index: $ }) : this.error("Expected " + se + " " + J + ".", { index: $ });
      }, pe.requiredSpace = function(J) {
        return this.options.lossy ? " " : J;
      }, pe.optionalSpace = function(J) {
        return this.options.lossy ? "" : J;
      }, pe.lossySpace = function(J, $) {
        return this.options.lossy ? $ ? " " : "" : J;
      }, pe.parseParenthesisToken = function(J) {
        var $ = this.content(J);
        return J[E.FIELDS.TYPE] === w.space ? this.requiredSpace($) : $;
      }, pe.newNode = function(J, $) {
        return $ && (/^ +$/.test($) && (this.options.lossy || (this.spaces = (this.spaces || "") + $), $ = !0), J.namespace = $, ee(J, "namespace")), this.spaces && (J.spaces.before = this.spaces, this.spaces = ""), this.current.append(J);
      }, pe.content = function(J) {
        return J === void 0 && (J = this.currToken), this.css.slice(J[E.FIELDS.START_POS], J[E.FIELDS.END_POS]);
      }, pe.locateNextMeaningfulToken = function(J) {
        J === void 0 && (J = this.position + 1);
        for (var $ = J; $ < this.tokens.length; ) {
          if (!X[this.tokens[$][E.FIELDS.TYPE]]) return $;
          $++;
        }
        return -1;
      }, j(Q, [{ key: "currToken", get: function() {
        return this.tokens[this.position];
      } }, { key: "nextToken", get: function() {
        return this.tokens[this.position + 1];
      } }, { key: "prevToken", get: function() {
        return this.tokens[this.position - 1];
      } }]), Q;
    })();
    t.default = Te, e.exports = t.default;
  })(sl, sl.exports)), sl.exports;
}
function gE() {
  return qf || (qf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = mE()) && s.__esModule ? s : { default: s }, i = (function() {
      function o(l, p) {
        this.func = l || function() {
        }, this.funcRes = null, this.options = p;
      }
      var c = o.prototype;
      return c._shouldUpdateSelector = function(l, p) {
        return p === void 0 && (p = {}), Object.assign({}, this.options, p).updateSelector !== !1 && typeof l != "string";
      }, c._isLossy = function(l) {
        return l === void 0 && (l = {}), Object.assign({}, this.options, l).lossless === !1;
      }, c._root = function(l, p) {
        return p === void 0 && (p = {}), new n.default(l, this._parseOptions(p)).root;
      }, c._parseOptions = function(l) {
        return { lossy: this._isLossy(l) };
      }, c._run = function(l, p) {
        var d = this;
        return p === void 0 && (p = {}), new Promise(function(g, f) {
          try {
            var x = d._root(l, p);
            Promise.resolve(d.func(x)).then(function(m) {
              var y = void 0;
              return d._shouldUpdateSelector(l, p) && (y = x.toString(), l.selector = y), { transform: m, root: x, string: y };
            }).then(g, f);
          } catch (m) {
            return void f(m);
          }
        });
      }, c._runSync = function(l, p) {
        p === void 0 && (p = {});
        var d = this._root(l, p), g = this.func(d);
        if (g && typeof g.then == "function") throw new Error("Selector processor returned a promise to a synchronous call.");
        var f = void 0;
        return p.updateSelector && typeof l != "string" && (f = d.toString(), l.selector = f), { transform: g, root: d, string: f };
      }, c.ast = function(l, p) {
        return this._run(l, p).then(function(d) {
          return d.root;
        });
      }, c.astSync = function(l, p) {
        return this._runSync(l, p).root;
      }, c.transform = function(l, p) {
        return this._run(l, p).then(function(d) {
          return d.transform;
        });
      }, c.transformSync = function(l, p) {
        return this._runSync(l, p).transform;
      }, c.process = function(l, p) {
        return this._run(l, p).then(function(d) {
          return d.string || d.root.toString();
        });
      }, c.processSync = function(l, p) {
        var d = this._runSync(l, p);
        return d.string || d.root.toString();
      }, o;
    })();
    t.default = i, e.exports = t.default;
  })(rl, rl.exports)), rl.exports;
}
var Hf, zf = {}, Ge = {};
function yE() {
  if (Hf) return Ge;
  Hf = 1, Ge.__esModule = !0, Ge.universal = Ge.tag = Ge.string = Ge.selector = Ge.root = Ge.pseudo = Ge.nesting = Ge.id = Ge.comment = Ge.combinator = Ge.className = Ge.attribute = void 0;
  var e = x(gb()), t = x(pb()), s = x(xb()), n = x(hb()), i = x(ub()), o = x(bb()), c = x(mb()), l = x(cb()), p = x(lb()), d = x(fb()), g = x(db()), f = x(yb());
  function x(m) {
    return m && m.__esModule ? m : { default: m };
  }
  return Ge.attribute = function(m) {
    return new e.default(m);
  }, Ge.className = function(m) {
    return new t.default(m);
  }, Ge.combinator = function(m) {
    return new s.default(m);
  }, Ge.comment = function(m) {
    return new n.default(m);
  }, Ge.id = function(m) {
    return new i.default(m);
  }, Ge.nesting = function(m) {
    return new o.default(m);
  }, Ge.pseudo = function(m) {
    return new c.default(m);
  }, Ge.root = function(m) {
    return new l.default(m);
  }, Ge.selector = function(m) {
    return new p.default(m);
  }, Ge.string = function(m) {
    return new d.default(m);
  }, Ge.tag = function(m) {
    return new g.default(m);
  }, Ge.universal = function(m) {
    return new f.default(m);
  }, Ge;
}
var Wf, Gf, Xf, Be = {};
function xE() {
  if (Wf) return Be;
  Wf = 1, Be.__esModule = !0, Be.isComment = Be.isCombinator = Be.isClassName = Be.isAttribute = void 0, Be.isContainer = function(w) {
    return !(!n(w) || !w.walk);
  }, Be.isIdentifier = void 0, Be.isNamespace = function(w) {
    return o(w) || v(w);
  }, Be.isNesting = void 0, Be.isNode = n, Be.isPseudo = void 0, Be.isPseudoClass = function(w) {
    return f(w) && !E(w);
  }, Be.isPseudoElement = E, Be.isUniversal = Be.isTag = Be.isString = Be.isSelector = Be.isRoot = void 0;
  var e, t = Ct(), s = ((e = {})[t.ATTRIBUTE] = !0, e[t.CLASS] = !0, e[t.COMBINATOR] = !0, e[t.COMMENT] = !0, e[t.ID] = !0, e[t.NESTING] = !0, e[t.PSEUDO] = !0, e[t.ROOT] = !0, e[t.SELECTOR] = !0, e[t.STRING] = !0, e[t.TAG] = !0, e[t.UNIVERSAL] = !0, e);
  function n(w) {
    return typeof w == "object" && s[w.type];
  }
  function i(w, C) {
    return n(C) && C.type === w;
  }
  var o = i.bind(null, t.ATTRIBUTE);
  Be.isAttribute = o;
  var c = i.bind(null, t.CLASS);
  Be.isClassName = c;
  var l = i.bind(null, t.COMBINATOR);
  Be.isCombinator = l;
  var p = i.bind(null, t.COMMENT);
  Be.isComment = p;
  var d = i.bind(null, t.ID);
  Be.isIdentifier = d;
  var g = i.bind(null, t.NESTING);
  Be.isNesting = g;
  var f = i.bind(null, t.PSEUDO);
  Be.isPseudo = f;
  var x = i.bind(null, t.ROOT);
  Be.isRoot = x;
  var m = i.bind(null, t.SELECTOR);
  Be.isSelector = m;
  var y = i.bind(null, t.STRING);
  Be.isString = y;
  var v = i.bind(null, t.TAG);
  Be.isTag = v;
  var b = i.bind(null, t.UNIVERSAL);
  function E(w) {
    return f(w) && w.value && (w.value.startsWith("::") || w.value.toLowerCase() === ":before" || w.value.toLowerCase() === ":after" || w.value.toLowerCase() === ":first-letter" || w.value.toLowerCase() === ":first-line");
  }
  return Be.isUniversal = b, Be;
}
function bE() {
  return Gf || (Gf = 1, (function(e) {
    e.__esModule = !0;
    var t = Ct();
    Object.keys(t).forEach(function(i) {
      i !== "default" && i !== "__esModule" && (i in e && e[i] === t[i] || (e[i] = t[i]));
    });
    var s = yE();
    Object.keys(s).forEach(function(i) {
      i !== "default" && i !== "__esModule" && (i in e && e[i] === s[i] || (e[i] = s[i]));
    });
    var n = xE();
    Object.keys(n).forEach(function(i) {
      i !== "default" && i !== "__esModule" && (i in e && e[i] === n[i] || (e[i] = n[i]));
    });
  })(zf)), zf;
}
function TE() {
  return Xf || (Xf = 1, (function(e, t) {
    t.__esModule = !0, t.default = void 0;
    var s, n = (s = gE()) && s.__esModule ? s : { default: s }, i = (function(p, d) {
      if (p && p.__esModule) return p;
      if (p === null || typeof p != "object" && typeof p != "function") return { default: p };
      var g = o(d);
      if (g && g.has(p)) return g.get(p);
      var f = {}, x = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in p) if (m !== "default" && Object.prototype.hasOwnProperty.call(p, m)) {
        var y = x ? Object.getOwnPropertyDescriptor(p, m) : null;
        y && (y.get || y.set) ? Object.defineProperty(f, m, y) : f[m] = p[m];
      }
      return f.default = p, g && g.set(p, f), f;
    })(bE());
    function o(p) {
      if (typeof WeakMap != "function") return null;
      var d = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
      return (o = function(f) {
        return f ? g : d;
      })(p);
    }
    var c = function(p) {
      return new n.default(p);
    };
    Object.assign(c, i), delete c.__esModule;
    var l = c;
    t.default = l, e.exports = t.default;
  })(tl, tl.exports)), tl.exports;
}
var mo = xa(TE());
const vE = /^(?:-\w+-)?animation-name$/, kE = /^(?:-\w+-)?animation$/, Kf = /^(?:-\w+-)?keyframes$/, vb = (e = "") => {
  const t = /* @__PURE__ */ Object.create(null), s = e.replace(/^data-v-/, "");
  return { postcssPlugin: "vue-sfc-scoped", Rule(n) {
    (function(i, o) {
      if (Jf.has(o) || o.parent && o.parent.type === "atrule" && Kf.test(o.parent.name)) return;
      Jf.add(o);
      let c = !1, l = o.parent;
      for (; l && l.type !== "root"; ) {
        if (l.__deep) {
          c = !0;
          break;
        }
        l = l.parent;
      }
      o.selector = mo((p) => {
        p.each((d) => {
          gp(i, o, d, p, c);
        });
      }).processSync(o.selector);
    })(e, n);
  }, AtRule(n) {
    Kf.test(n.name) && !n.params.endsWith(`-${s}`) && (t[n.params] = n.params = n.params + "-" + s);
  }, OnceExit(n) {
    Object.keys(t).length && n.walkDecls((i) => {
      vE.test(i.prop) && (i.value = i.value.split(",").map((o) => t[o.trim()] || o.trim()).join(",")), kE.test(i.prop) && (i.value = i.value.split(",").map((o) => {
        const c = o.trim().split(/\s+/), l = c.findIndex((p) => t[p]);
        return l !== -1 ? (c.splice(l, 1, t[c[l]]), c.join(" ")) : o;
      }).join(","));
    });
  } };
}, Jf = /* @__PURE__ */ new WeakSet();
function gp(e, t, s, n, i, o = !1) {
  let c = null, l = !i;
  if (s.each((p) => {
    if (p.type === "combinator" && (p.value === ">>>" || p.value === "/deep/")) return p.value = " ", p.spaces.before = p.spaces.after = "", Vo("the >>> and /deep/ combinators have been deprecated. Use :deep() instead."), !1;
    if (p.type === "pseudo") {
      const { value: d } = p;
      if (d === ":deep" || d === "::v-deep") {
        if (t.__deep = !0, p.nodes.length) {
          let g = p;
          p.nodes[0].each((x) => {
            s.insertAfter(g, x), g = x;
          });
          const f = s.at(s.index(p) - 1);
          f && Yf(f) || s.insertAfter(p, mo.combinator({ value: " " })), s.removeChild(p);
        } else {
          Vo(`${d} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${d} <inner-selector>.`);
          const g = s.at(s.index(p) - 1);
          g && Yf(g) && s.removeChild(g), s.removeChild(p);
        }
        return !1;
      }
      if (d === ":slotted" || d === "::v-slotted") {
        gp(e, t, p.nodes[0], n, i, !0);
        let g = p;
        return p.nodes[0].each((f) => {
          s.insertAfter(g, f), g = f;
        }), s.removeChild(p), l = !1, !1;
      }
      if (d === ":global" || d === "::v-global") return s.replaceWith(p.nodes[0]), !1;
    }
    if (p.type === "universal") {
      const d = s.at(s.index(p) - 1), g = s.at(s.index(p) + 1);
      if (!d) return g ? (g.type === "combinator" && g.value === " " && s.removeChild(g), void s.removeChild(p)) : (c = mo.combinator({ value: "" }), s.insertBefore(p, c), s.removeChild(p), !1);
      if (c) return;
    }
    (p.type !== "pseudo" && p.type !== "combinator" || p.type === "pseudo" && (p.value === ":is" || p.value === ":where") && !c) && (c = p);
  }), t.nodes.some((p) => p.type === "rule")) {
    const p = t.__deep;
    if (!p) {
      Qf(t);
      const d = t.nodes.filter((g) => g.type === "atrule");
      for (const g of d) Qf(g);
    }
    l = p;
  }
  if (c) {
    const { type: p, value: d } = c;
    p !== "pseudo" || d !== ":is" && d !== ":where" || (c.nodes.forEach((g) => gp(e, t, g, n, i, o)), l = !1);
  }
  if (c ? c.spaces.after = "" : s.first.spaces.before = "", l) {
    const p = o ? e + "-s" : e;
    s.insertAfter(c, mo.attribute({ attribute: p, value: p, raws: {}, quoteMark: '"' }));
  }
}
function Yf(e) {
  return e.type === "combinator" && /^\s+$/.test(e.value);
}
function Qf(e) {
  if (!e.nodes) return;
  const t = e.nodes.filter((s) => s.type === "decl" || s.type === "comment");
  if (t.length) {
    for (const n of t) e.removeChild(n);
    const s = new cE({ nodes: t, selector: "&" });
    e.prepend(s);
  }
}
vb.postcss = !0;
var Zf, em, Ji = {}, Sl = {}, Yi = {}, Qi = {};
function SE() {
  if (Zf) return Qi;
  Zf = 1;
  var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Qi.encode = function(t) {
    if (0 <= t && t < e.length) return e[t];
    throw new TypeError("Must be between 0 and 63: " + t);
  }, Qi.decode = function(t) {
    return 65 <= t && t <= 90 ? t - 65 : 97 <= t && t <= 122 ? t - 97 + 26 : 48 <= t && t <= 57 ? t - 48 + 52 : t == 43 ? 62 : t == 47 ? 63 : -1;
  }, Qi;
}
function kb() {
  if (em) return Yi;
  em = 1;
  var e = SE();
  return Yi.encode = function(t) {
    var s, n = "", i = (function(o) {
      return o < 0 ? 1 + (-o << 1) : 0 + (o << 1);
    })(t);
    do
      s = 31 & i, (i >>>= 5) > 0 && (s |= 32), n += e.encode(s);
    while (i > 0);
    return n;
  }, Yi.decode = function(t, s, n) {
    var i, o, c, l, p = t.length, d = 0, g = 0;
    do {
      if (s >= p) throw new Error("Expected more digits in base 64 VLQ value.");
      if ((o = e.decode(t.charCodeAt(s++))) === -1) throw new Error("Invalid base64 digit: " + t.charAt(s - 1));
      i = !!(32 & o), d += (o &= 31) << g, g += 5;
    } while (i);
    n.value = (l = (c = d) >> 1, 1 & ~c ? l : -l), n.rest = s;
  }, Yi;
}
var tm, rm = {};
function Ei() {
  return tm || (tm = 1, (function(e) {
    e.getArg = function(f, x, m) {
      if (x in f) return f[x];
      if (arguments.length === 3) return m;
      throw new Error('"' + x + '" is a required argument.');
    };
    var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
    function n(f) {
      var x = f.match(t);
      return x ? { scheme: x[1], auth: x[2], host: x[3], port: x[4], path: x[5] } : null;
    }
    function i(f) {
      var x = "";
      return f.scheme && (x += f.scheme + ":"), x += "//", f.auth && (x += f.auth + "@"), f.host && (x += f.host), f.port && (x += ":" + f.port), f.path && (x += f.path), x;
    }
    function o(f) {
      var x = f, m = n(f);
      if (m) {
        if (!m.path) return f;
        x = m.path;
      }
      for (var y, v = e.isAbsolute(x), b = x.split(/\/+/), E = 0, w = b.length - 1; w >= 0; w--) (y = b[w]) === "." ? b.splice(w, 1) : y === ".." ? E++ : E > 0 && (y === "" ? (b.splice(w + 1, E), E = 0) : (b.splice(w, 2), E--));
      return (x = b.join("/")) === "" && (x = v ? "/" : "."), m ? (m.path = x, i(m)) : x;
    }
    function c(f, x) {
      f === "" && (f = "."), x === "" && (x = ".");
      var m = n(x), y = n(f);
      if (y && (f = y.path || "/"), m && !m.scheme) return y && (m.scheme = y.scheme), i(m);
      if (m || x.match(s)) return x;
      if (y && !y.host && !y.path) return y.host = x, i(y);
      var v = x.charAt(0) === "/" ? x : o(f.replace(/\/+$/, "") + "/" + x);
      return y ? (y.path = v, i(y)) : v;
    }
    e.urlParse = n, e.urlGenerate = i, e.normalize = o, e.join = c, e.isAbsolute = function(f) {
      return f.charAt(0) === "/" || t.test(f);
    }, e.relative = function(f, x) {
      f === "" && (f = "."), f = f.replace(/\/$/, "");
      for (var m = 0; x.indexOf(f + "/") !== 0; ) {
        var y = f.lastIndexOf("/");
        if (y < 0 || (f = f.slice(0, y)).match(/^([^\/]+:\/)?\/*$/)) return x;
        ++m;
      }
      return Array(m + 1).join("../") + x.substr(f.length + 1);
    };
    var l = !("__proto__" in /* @__PURE__ */ Object.create(null));
    function p(f) {
      return f;
    }
    function d(f) {
      if (!f) return !1;
      var x = f.length;
      if (x < 9 || f.charCodeAt(x - 1) !== 95 || f.charCodeAt(x - 2) !== 95 || f.charCodeAt(x - 3) !== 111 || f.charCodeAt(x - 4) !== 116 || f.charCodeAt(x - 5) !== 111 || f.charCodeAt(x - 6) !== 114 || f.charCodeAt(x - 7) !== 112 || f.charCodeAt(x - 8) !== 95 || f.charCodeAt(x - 9) !== 95) return !1;
      for (var m = x - 10; m >= 0; m--) if (f.charCodeAt(m) !== 36) return !1;
      return !0;
    }
    function g(f, x) {
      return f === x ? 0 : f === null ? 1 : x === null ? -1 : f > x ? 1 : -1;
    }
    e.toSetString = l ? p : function(f) {
      return d(f) ? "$" + f : f;
    }, e.fromSetString = l ? p : function(f) {
      return d(f) ? f.slice(1) : f;
    }, e.compareByOriginalPositions = function(f, x, m) {
      var y = g(f.source, x.source);
      return y !== 0 || (y = f.originalLine - x.originalLine) !== 0 || (y = f.originalColumn - x.originalColumn) !== 0 || m || (y = f.generatedColumn - x.generatedColumn) !== 0 || (y = f.generatedLine - x.generatedLine) !== 0 ? y : g(f.name, x.name);
    }, e.compareByGeneratedPositionsDeflated = function(f, x, m) {
      var y = f.generatedLine - x.generatedLine;
      return y !== 0 || (y = f.generatedColumn - x.generatedColumn) !== 0 || m || (y = g(f.source, x.source)) !== 0 || (y = f.originalLine - x.originalLine) !== 0 || (y = f.originalColumn - x.originalColumn) !== 0 ? y : g(f.name, x.name);
    }, e.compareByGeneratedPositionsInflated = function(f, x) {
      var m = f.generatedLine - x.generatedLine;
      return m !== 0 || (m = f.generatedColumn - x.generatedColumn) !== 0 || (m = g(f.source, x.source)) !== 0 || (m = f.originalLine - x.originalLine) !== 0 || (m = f.originalColumn - x.originalColumn) !== 0 ? m : g(f.name, x.name);
    }, e.parseSourceMapInput = function(f) {
      return JSON.parse(f.replace(/^\)]}'[^\n]*\n/, ""));
    }, e.computeSourceURL = function(f, x, m) {
      if (x = x || "", f && (f[f.length - 1] !== "/" && x[0] !== "/" && (f += "/"), x = f + x), m) {
        var y = n(m);
        if (!y) throw new Error("sourceMapURL could not be parsed");
        if (y.path) {
          var v = y.path.lastIndexOf("/");
          v >= 0 && (y.path = y.path.substring(0, v + 1));
        }
        x = c(i(y), x);
      }
      return o(x);
    };
  })(rm)), rm;
}
var sm, El = {};
function Sb() {
  if (sm) return El;
  sm = 1;
  var e = Ei(), t = Object.prototype.hasOwnProperty, s = typeof Map < "u";
  function n() {
    this._array = [], this._set = s ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return n.fromArray = function(i, o) {
    for (var c = new n(), l = 0, p = i.length; l < p; l++) c.add(i[l], o);
    return c;
  }, n.prototype.size = function() {
    return s ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, n.prototype.add = function(i, o) {
    var c = s ? i : e.toSetString(i), l = s ? this.has(i) : t.call(this._set, c), p = this._array.length;
    l && !o || this._array.push(i), l || (s ? this._set.set(i, p) : this._set[c] = p);
  }, n.prototype.has = function(i) {
    if (s) return this._set.has(i);
    var o = e.toSetString(i);
    return t.call(this._set, o);
  }, n.prototype.indexOf = function(i) {
    if (s) {
      var o = this._set.get(i);
      if (o >= 0) return o;
    } else {
      var c = e.toSetString(i);
      if (t.call(this._set, c)) return this._set[c];
    }
    throw new Error('"' + i + '" is not in the set.');
  }, n.prototype.at = function(i) {
    if (i >= 0 && i < this._array.length) return this._array[i];
    throw new Error("No element indexed by " + i);
  }, n.prototype.toArray = function() {
    return this._array.slice();
  }, El.ArraySet = n, El;
}
var nm, im, wl = {};
function EE() {
  if (nm) return wl;
  nm = 1;
  var e = Ei();
  function t() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return t.prototype.unsortedForEach = function(s, n) {
    this._array.forEach(s, n);
  }, t.prototype.add = function(s) {
    var n, i, o, c, l, p;
    n = this._last, i = s, o = n.generatedLine, c = i.generatedLine, l = n.generatedColumn, p = i.generatedColumn, c > o || c == o && p >= l || e.compareByGeneratedPositionsInflated(n, i) <= 0 ? (this._last = s, this._array.push(s)) : (this._sorted = !1, this._array.push(s));
  }, t.prototype.toArray = function() {
    return this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, wl.MappingList = t, wl;
}
function Eb() {
  if (im) return Sl;
  im = 1;
  var e = kb(), t = Ei(), s = Sb().ArraySet, n = EE().MappingList;
  function i(o) {
    o || (o = {}), this._file = t.getArg(o, "file", null), this._sourceRoot = t.getArg(o, "sourceRoot", null), this._skipValidation = t.getArg(o, "skipValidation", !1), this._sources = new s(), this._names = new s(), this._mappings = new n(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(o) {
    var c = o.sourceRoot, l = new i({ file: o.file, sourceRoot: c });
    return o.eachMapping(function(p) {
      var d = { generated: { line: p.generatedLine, column: p.generatedColumn } };
      p.source != null && (d.source = p.source, c != null && (d.source = t.relative(c, d.source)), d.original = { line: p.originalLine, column: p.originalColumn }, p.name != null && (d.name = p.name)), l.addMapping(d);
    }), o.sources.forEach(function(p) {
      var d = p;
      c !== null && (d = t.relative(c, p)), l._sources.has(d) || l._sources.add(d);
      var g = o.sourceContentFor(p);
      g != null && l.setSourceContent(p, g);
    }), l;
  }, i.prototype.addMapping = function(o) {
    var c = t.getArg(o, "generated"), l = t.getArg(o, "original", null), p = t.getArg(o, "source", null), d = t.getArg(o, "name", null);
    this._skipValidation || this._validateMapping(c, l, p, d), p != null && (p = String(p), this._sources.has(p) || this._sources.add(p)), d != null && (d = String(d), this._names.has(d) || this._names.add(d)), this._mappings.add({ generatedLine: c.line, generatedColumn: c.column, originalLine: l != null && l.line, originalColumn: l != null && l.column, source: p, name: d });
  }, i.prototype.setSourceContent = function(o, c) {
    var l = o;
    this._sourceRoot != null && (l = t.relative(this._sourceRoot, l)), c != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[t.toSetString(l)] = c) : this._sourcesContents && (delete this._sourcesContents[t.toSetString(l)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(o, c, l) {
    var p = c;
    if (c == null) {
      if (o.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      p = o.file;
    }
    var d = this._sourceRoot;
    d != null && (p = t.relative(d, p));
    var g = new s(), f = new s();
    this._mappings.unsortedForEach(function(x) {
      if (x.source === p && x.originalLine != null) {
        var m = o.originalPositionFor({ line: x.originalLine, column: x.originalColumn });
        m.source != null && (x.source = m.source, l != null && (x.source = t.join(l, x.source)), d != null && (x.source = t.relative(d, x.source)), x.originalLine = m.line, x.originalColumn = m.column, m.name != null && (x.name = m.name));
      }
      var y = x.source;
      y == null || g.has(y) || g.add(y);
      var v = x.name;
      v == null || f.has(v) || f.add(v);
    }, this), this._sources = g, this._names = f, o.sources.forEach(function(x) {
      var m = o.sourceContentFor(x);
      m != null && (l != null && (x = t.join(l, x)), d != null && (x = t.relative(d, x)), this.setSourceContent(x, m));
    }, this);
  }, i.prototype._validateMapping = function(o, c, l, p) {
    if (c && typeof c.line != "number" && typeof c.column != "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if ((!(o && "line" in o && "column" in o && o.line > 0 && o.column >= 0) || c || l || p) && !(o && "line" in o && "column" in o && c && "line" in c && "column" in c && o.line > 0 && o.column >= 0 && c.line > 0 && c.column >= 0 && l)) throw new Error("Invalid mapping: " + JSON.stringify({ generated: o, source: l, original: c, name: p }));
  }, i.prototype._serializeMappings = function() {
    for (var o, c, l, p, d = 0, g = 1, f = 0, x = 0, m = 0, y = 0, v = "", b = this._mappings.toArray(), E = 0, w = b.length; E < w; E++) {
      if (o = "", (c = b[E]).generatedLine !== g) for (d = 0; c.generatedLine !== g; ) o += ";", g++;
      else if (E > 0) {
        if (!t.compareByGeneratedPositionsInflated(c, b[E - 1])) continue;
        o += ",";
      }
      o += e.encode(c.generatedColumn - d), d = c.generatedColumn, c.source != null && (p = this._sources.indexOf(c.source), o += e.encode(p - y), y = p, o += e.encode(c.originalLine - 1 - x), x = c.originalLine - 1, o += e.encode(c.originalColumn - f), f = c.originalColumn, c.name != null && (l = this._names.indexOf(c.name), o += e.encode(l - m), m = l)), v += o;
    }
    return v;
  }, i.prototype._generateSourcesContent = function(o, c) {
    return o.map(function(l) {
      if (!this._sourcesContents) return null;
      c != null && (l = t.relative(c, l));
      var p = t.toSetString(l);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, p) ? this._sourcesContents[p] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var o = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return this._file != null && (o.file = this._file), this._sourceRoot != null && (o.sourceRoot = this._sourceRoot), this._sourcesContents && (o.sourcesContent = this._generateSourcesContent(o.sources, o.sourceRoot)), o;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Sl.SourceMapGenerator = i, Sl;
}
var om, An = {}, am = {};
function wE() {
  return om || (om = 1, (function(e) {
    function t(s, n, i, o, c, l) {
      var p = Math.floor((n - s) / 2) + s, d = c(i, o[p], !0);
      return d === 0 ? p : d > 0 ? n - p > 1 ? t(p, n, i, o, c, l) : l == e.LEAST_UPPER_BOUND ? n < o.length ? n : -1 : p : p - s > 1 ? t(s, p, i, o, c, l) : l == e.LEAST_UPPER_BOUND ? p : s < 0 ? -1 : s;
    }
    e.GREATEST_LOWER_BOUND = 1, e.LEAST_UPPER_BOUND = 2, e.search = function(s, n, i, o) {
      if (n.length === 0) return -1;
      var c = t(-1, n.length, s, n, i, o || e.GREATEST_LOWER_BOUND);
      if (c < 0) return -1;
      for (; c - 1 >= 0 && i(n[c], n[c - 1], !0) === 0; ) --c;
      return c;
    };
  })(am)), am;
}
var cm, lm, _l = {};
function _E() {
  if (cm) return _l;
  function e(s, n, i) {
    var o = s[n];
    s[n] = s[i], s[i] = o;
  }
  function t(s, n, i, o) {
    if (i < o) {
      var c = i - 1;
      e(s, (g = i, f = o, Math.round(g + Math.random() * (f - g))), o);
      for (var l = s[o], p = i; p < o; p++) n(s[p], l) <= 0 && e(s, c += 1, p);
      e(s, c + 1, p);
      var d = c + 1;
      t(s, n, i, d - 1), t(s, n, d + 1, o);
    }
    var g, f;
  }
  return cm = 1, _l.quickSort = function(s, n) {
    t(s, n, 0, s.length - 1);
  }, _l;
}
function PE() {
  if (lm) return An;
  lm = 1;
  var e = Ei(), t = wE(), s = Sb().ArraySet, n = kb(), i = _E().quickSort;
  function o(d, g) {
    var f = d;
    return typeof d == "string" && (f = e.parseSourceMapInput(d)), f.sections != null ? new p(f, g) : new c(f, g);
  }
  function c(d, g) {
    var f = d;
    typeof d == "string" && (f = e.parseSourceMapInput(d));
    var x = e.getArg(f, "version"), m = e.getArg(f, "sources"), y = e.getArg(f, "names", []), v = e.getArg(f, "sourceRoot", null), b = e.getArg(f, "sourcesContent", null), E = e.getArg(f, "mappings"), w = e.getArg(f, "file", null);
    if (x != this._version) throw new Error("Unsupported version: " + x);
    v && (v = e.normalize(v)), m = m.map(String).map(e.normalize).map(function(C) {
      return v && e.isAbsolute(v) && e.isAbsolute(C) ? e.relative(v, C) : C;
    }), this._names = s.fromArray(y.map(String), !0), this._sources = s.fromArray(m, !0), this._absoluteSources = this._sources.toArray().map(function(C) {
      return e.computeSourceURL(v, C, g);
    }), this.sourceRoot = v, this.sourcesContent = b, this._mappings = E, this._sourceMapURL = g, this.file = w;
  }
  function l() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  function p(d, g) {
    var f = d;
    typeof d == "string" && (f = e.parseSourceMapInput(d));
    var x = e.getArg(f, "version"), m = e.getArg(f, "sections");
    if (x != this._version) throw new Error("Unsupported version: " + x);
    this._sources = new s(), this._names = new s();
    var y = { line: -1, column: 0 };
    this._sections = m.map(function(v) {
      if (v.url) throw new Error("Support for url field in sections not implemented.");
      var b = e.getArg(v, "offset"), E = e.getArg(b, "line"), w = e.getArg(b, "column");
      if (E < y.line || E === y.line && w < y.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return y = b, { generatedOffset: { generatedLine: E + 1, generatedColumn: w + 1 }, consumer: new o(e.getArg(v, "map"), g) };
    });
  }
  return o.fromSourceMap = function(d, g) {
    return c.fromSourceMap(d, g);
  }, o.prototype._version = 3, o.prototype.__generatedMappings = null, Object.defineProperty(o.prototype, "_generatedMappings", { configurable: !0, enumerable: !0, get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  } }), o.prototype.__originalMappings = null, Object.defineProperty(o.prototype, "_originalMappings", { configurable: !0, enumerable: !0, get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  } }), o.prototype._charIsMappingSeparator = function(d, g) {
    var f = d.charAt(g);
    return f === ";" || f === ",";
  }, o.prototype._parseMappings = function(d, g) {
    throw new Error("Subclasses must implement _parseMappings");
  }, o.GENERATED_ORDER = 1, o.ORIGINAL_ORDER = 2, o.GREATEST_LOWER_BOUND = 1, o.LEAST_UPPER_BOUND = 2, o.prototype.eachMapping = function(d, g, f) {
    var x, m = g || null;
    switch (f || o.GENERATED_ORDER) {
      case o.GENERATED_ORDER:
        x = this._generatedMappings;
        break;
      case o.ORIGINAL_ORDER:
        x = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var y = this.sourceRoot;
    x.map(function(v) {
      var b = v.source === null ? null : this._sources.at(v.source);
      return { source: b = e.computeSourceURL(y, b, this._sourceMapURL), generatedLine: v.generatedLine, generatedColumn: v.generatedColumn, originalLine: v.originalLine, originalColumn: v.originalColumn, name: v.name === null ? null : this._names.at(v.name) };
    }, this).forEach(d, m);
  }, o.prototype.allGeneratedPositionsFor = function(d) {
    var g = e.getArg(d, "line"), f = { source: e.getArg(d, "source"), originalLine: g, originalColumn: e.getArg(d, "column", 0) };
    if (f.source = this._findSourceIndex(f.source), f.source < 0) return [];
    var x = [], m = this._findMapping(f, this._originalMappings, "originalLine", "originalColumn", e.compareByOriginalPositions, t.LEAST_UPPER_BOUND);
    if (m >= 0) {
      var y = this._originalMappings[m];
      if (d.column === void 0) for (var v = y.originalLine; y && y.originalLine === v; ) x.push({ line: e.getArg(y, "generatedLine", null), column: e.getArg(y, "generatedColumn", null), lastColumn: e.getArg(y, "lastGeneratedColumn", null) }), y = this._originalMappings[++m];
      else for (var b = y.originalColumn; y && y.originalLine === g && y.originalColumn == b; ) x.push({ line: e.getArg(y, "generatedLine", null), column: e.getArg(y, "generatedColumn", null), lastColumn: e.getArg(y, "lastGeneratedColumn", null) }), y = this._originalMappings[++m];
    }
    return x;
  }, An.SourceMapConsumer = o, c.prototype = Object.create(o.prototype), c.prototype.consumer = o, c.prototype._findSourceIndex = function(d) {
    var g, f = d;
    if (this.sourceRoot != null && (f = e.relative(this.sourceRoot, f)), this._sources.has(f)) return this._sources.indexOf(f);
    for (g = 0; g < this._absoluteSources.length; ++g) if (this._absoluteSources[g] == d) return g;
    return -1;
  }, c.fromSourceMap = function(d, g) {
    var f = Object.create(c.prototype), x = f._names = s.fromArray(d._names.toArray(), !0), m = f._sources = s.fromArray(d._sources.toArray(), !0);
    f.sourceRoot = d._sourceRoot, f.sourcesContent = d._generateSourcesContent(f._sources.toArray(), f.sourceRoot), f.file = d._file, f._sourceMapURL = g, f._absoluteSources = f._sources.toArray().map(function(O) {
      return e.computeSourceURL(f.sourceRoot, O, g);
    });
    for (var y = d._mappings.toArray().slice(), v = f.__generatedMappings = [], b = f.__originalMappings = [], E = 0, w = y.length; E < w; E++) {
      var C = y[E], A = new l();
      A.generatedLine = C.generatedLine, A.generatedColumn = C.generatedColumn, C.source && (A.source = m.indexOf(C.source), A.originalLine = C.originalLine, A.originalColumn = C.originalColumn, C.name && (A.name = x.indexOf(C.name)), b.push(A)), v.push(A);
    }
    return i(f.__originalMappings, e.compareByOriginalPositions), f;
  }, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", { get: function() {
    return this._absoluteSources.slice();
  } }), c.prototype._parseMappings = function(d, g) {
    for (var f, x, m, y, v, b = 1, E = 0, w = 0, C = 0, A = 0, O = 0, D = d.length, N = 0, j = {}, U = {}, X = [], W = []; N < D; ) if (d.charAt(N) === ";") b++, N++, E = 0;
    else if (d.charAt(N) === ",") N++;
    else {
      for ((f = new l()).generatedLine = b, y = N; y < D && !this._charIsMappingSeparator(d, y); y++) ;
      if (m = j[x = d.slice(N, y)]) N += x.length;
      else {
        for (m = []; N < y; ) n.decode(d, N, U), v = U.value, N = U.rest, m.push(v);
        if (m.length === 2) throw new Error("Found a source, but no line and column");
        if (m.length === 3) throw new Error("Found a source and line, but no column");
        j[x] = m;
      }
      f.generatedColumn = E + m[0], E = f.generatedColumn, m.length > 1 && (f.source = A + m[1], A += m[1], f.originalLine = w + m[2], w = f.originalLine, f.originalLine += 1, f.originalColumn = C + m[3], C = f.originalColumn, m.length > 4 && (f.name = O + m[4], O += m[4])), W.push(f), typeof f.originalLine == "number" && X.push(f);
    }
    i(W, e.compareByGeneratedPositionsDeflated), this.__generatedMappings = W, i(X, e.compareByOriginalPositions), this.__originalMappings = X;
  }, c.prototype._findMapping = function(d, g, f, x, m, y) {
    if (d[f] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + d[f]);
    if (d[x] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + d[x]);
    return t.search(d, g, m, y);
  }, c.prototype.computeColumnSpans = function() {
    for (var d = 0; d < this._generatedMappings.length; ++d) {
      var g = this._generatedMappings[d];
      if (d + 1 < this._generatedMappings.length) {
        var f = this._generatedMappings[d + 1];
        if (g.generatedLine === f.generatedLine) {
          g.lastGeneratedColumn = f.generatedColumn - 1;
          continue;
        }
      }
      g.lastGeneratedColumn = 1 / 0;
    }
  }, c.prototype.originalPositionFor = function(d) {
    var g = { generatedLine: e.getArg(d, "line"), generatedColumn: e.getArg(d, "column") }, f = this._findMapping(g, this._generatedMappings, "generatedLine", "generatedColumn", e.compareByGeneratedPositionsDeflated, e.getArg(d, "bias", o.GREATEST_LOWER_BOUND));
    if (f >= 0) {
      var x = this._generatedMappings[f];
      if (x.generatedLine === g.generatedLine) {
        var m = e.getArg(x, "source", null);
        m !== null && (m = this._sources.at(m), m = e.computeSourceURL(this.sourceRoot, m, this._sourceMapURL));
        var y = e.getArg(x, "name", null);
        return y !== null && (y = this._names.at(y)), { source: m, line: e.getArg(x, "originalLine", null), column: e.getArg(x, "originalColumn", null), name: y };
      }
    }
    return { source: null, line: null, column: null, name: null };
  }, c.prototype.hasContentsOfAllSources = function() {
    return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(d) {
      return d == null;
    });
  }, c.prototype.sourceContentFor = function(d, g) {
    if (!this.sourcesContent) return null;
    var f = this._findSourceIndex(d);
    if (f >= 0) return this.sourcesContent[f];
    var x, m = d;
    if (this.sourceRoot != null && (m = e.relative(this.sourceRoot, m)), this.sourceRoot != null && (x = e.urlParse(this.sourceRoot))) {
      var y = m.replace(/^file:\/\//, "");
      if (x.scheme == "file" && this._sources.has(y)) return this.sourcesContent[this._sources.indexOf(y)];
      if ((!x.path || x.path == "/") && this._sources.has("/" + m)) return this.sourcesContent[this._sources.indexOf("/" + m)];
    }
    if (g) return null;
    throw new Error('"' + m + '" is not in the SourceMap.');
  }, c.prototype.generatedPositionFor = function(d) {
    var g = e.getArg(d, "source");
    if ((g = this._findSourceIndex(g)) < 0) return { line: null, column: null, lastColumn: null };
    var f = { source: g, originalLine: e.getArg(d, "line"), originalColumn: e.getArg(d, "column") }, x = this._findMapping(f, this._originalMappings, "originalLine", "originalColumn", e.compareByOriginalPositions, e.getArg(d, "bias", o.GREATEST_LOWER_BOUND));
    if (x >= 0) {
      var m = this._originalMappings[x];
      if (m.source === f.source) return { line: e.getArg(m, "generatedLine", null), column: e.getArg(m, "generatedColumn", null), lastColumn: e.getArg(m, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  }, An.BasicSourceMapConsumer = c, p.prototype = Object.create(o.prototype), p.prototype.constructor = o, p.prototype._version = 3, Object.defineProperty(p.prototype, "sources", { get: function() {
    for (var d = [], g = 0; g < this._sections.length; g++) for (var f = 0; f < this._sections[g].consumer.sources.length; f++) d.push(this._sections[g].consumer.sources[f]);
    return d;
  } }), p.prototype.originalPositionFor = function(d) {
    var g = { generatedLine: e.getArg(d, "line"), generatedColumn: e.getArg(d, "column") }, f = t.search(g, this._sections, function(m, y) {
      var v = m.generatedLine - y.generatedOffset.generatedLine;
      return v || m.generatedColumn - y.generatedOffset.generatedColumn;
    }), x = this._sections[f];
    return x ? x.consumer.originalPositionFor({ line: g.generatedLine - (x.generatedOffset.generatedLine - 1), column: g.generatedColumn - (x.generatedOffset.generatedLine === g.generatedLine ? x.generatedOffset.generatedColumn - 1 : 0), bias: d.bias }) : { source: null, line: null, column: null, name: null };
  }, p.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(d) {
      return d.consumer.hasContentsOfAllSources();
    });
  }, p.prototype.sourceContentFor = function(d, g) {
    for (var f = 0; f < this._sections.length; f++) {
      var x = this._sections[f].consumer.sourceContentFor(d, !0);
      if (x) return x;
    }
    if (g) return null;
    throw new Error('"' + d + '" is not in the SourceMap.');
  }, p.prototype.generatedPositionFor = function(d) {
    for (var g = 0; g < this._sections.length; g++) {
      var f = this._sections[g];
      if (f.consumer._findSourceIndex(e.getArg(d, "source")) !== -1) {
        var x = f.consumer.generatedPositionFor(d);
        if (x) return { line: x.line + (f.generatedOffset.generatedLine - 1), column: x.column + (f.generatedOffset.generatedLine === x.line ? f.generatedOffset.generatedColumn - 1 : 0) };
      }
    }
    return { line: null, column: null };
  }, p.prototype._parseMappings = function(d, g) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var f = 0; f < this._sections.length; f++) for (var x = this._sections[f], m = x.consumer._generatedMappings, y = 0; y < m.length; y++) {
      var v = m[y], b = x.consumer._sources.at(v.source);
      b = e.computeSourceURL(x.consumer.sourceRoot, b, this._sourceMapURL), this._sources.add(b), b = this._sources.indexOf(b);
      var E = null;
      v.name && (E = x.consumer._names.at(v.name), this._names.add(E), E = this._names.indexOf(E));
      var w = { source: b, generatedLine: v.generatedLine + (x.generatedOffset.generatedLine - 1), generatedColumn: v.generatedColumn + (x.generatedOffset.generatedLine === v.generatedLine ? x.generatedOffset.generatedColumn - 1 : 0), originalLine: v.originalLine, originalColumn: v.originalColumn, name: E };
      this.__generatedMappings.push(w), typeof w.originalLine == "number" && this.__originalMappings.push(w);
    }
    i(this.__generatedMappings, e.compareByGeneratedPositionsDeflated), i(this.__originalMappings, e.compareByOriginalPositions);
  }, An.IndexedSourceMapConsumer = p, An;
}
var pm, hm, um, dm, Pl = {};
function AE() {
  if (pm) return Pl;
  pm = 1;
  var e = Eb().SourceMapGenerator, t = Ei(), s = /(\r?\n)/, n = "$$$isSourceNode$$$";
  function i(o, c, l, p, d) {
    this.children = [], this.sourceContents = {}, this.line = o ?? null, this.column = c ?? null, this.source = l ?? null, this.name = d ?? null, this[n] = !0, p != null && this.add(p);
  }
  return i.fromStringWithSourceMap = function(o, c, l) {
    var p = new i(), d = o.split(s), g = 0, f = function() {
      return b() + (b() || "");
      function b() {
        return g < d.length ? d[g++] : void 0;
      }
    }, x = 1, m = 0, y = null;
    return c.eachMapping(function(b) {
      if (y !== null) {
        if (!(x < b.generatedLine)) {
          var E = (w = d[g] || "").substr(0, b.generatedColumn - m);
          return d[g] = w.substr(b.generatedColumn - m), m = b.generatedColumn, v(y, E), void (y = b);
        }
        v(y, f()), x++, m = 0;
      }
      for (; x < b.generatedLine; ) p.add(f()), x++;
      if (m < b.generatedColumn) {
        var w = d[g] || "";
        p.add(w.substr(0, b.generatedColumn)), d[g] = w.substr(b.generatedColumn), m = b.generatedColumn;
      }
      y = b;
    }, this), g < d.length && (y && v(y, f()), p.add(d.splice(g).join(""))), c.sources.forEach(function(b) {
      var E = c.sourceContentFor(b);
      E != null && (l != null && (b = t.join(l, b)), p.setSourceContent(b, E));
    }), p;
    function v(b, E) {
      if (b === null || b.source === void 0) p.add(E);
      else {
        var w = l ? t.join(l, b.source) : b.source;
        p.add(new i(b.originalLine, b.originalColumn, w, E, b.name));
      }
    }
  }, i.prototype.add = function(o) {
    if (Array.isArray(o)) o.forEach(function(c) {
      this.add(c);
    }, this);
    else {
      if (!o[n] && typeof o != "string") throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o);
      o && this.children.push(o);
    }
    return this;
  }, i.prototype.prepend = function(o) {
    if (Array.isArray(o)) for (var c = o.length - 1; c >= 0; c--) this.prepend(o[c]);
    else {
      if (!o[n] && typeof o != "string") throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + o);
      this.children.unshift(o);
    }
    return this;
  }, i.prototype.walk = function(o) {
    for (var c, l = 0, p = this.children.length; l < p; l++) (c = this.children[l])[n] ? c.walk(o) : c !== "" && o(c, { source: this.source, line: this.line, column: this.column, name: this.name });
  }, i.prototype.join = function(o) {
    var c, l, p = this.children.length;
    if (p > 0) {
      for (c = [], l = 0; l < p - 1; l++) c.push(this.children[l]), c.push(o);
      c.push(this.children[l]), this.children = c;
    }
    return this;
  }, i.prototype.replaceRight = function(o, c) {
    var l = this.children[this.children.length - 1];
    return l[n] ? l.replaceRight(o, c) : typeof l == "string" ? this.children[this.children.length - 1] = l.replace(o, c) : this.children.push("".replace(o, c)), this;
  }, i.prototype.setSourceContent = function(o, c) {
    this.sourceContents[t.toSetString(o)] = c;
  }, i.prototype.walkSourceContents = function(o) {
    for (var c = 0, l = this.children.length; c < l; c++) this.children[c][n] && this.children[c].walkSourceContents(o);
    var p = Object.keys(this.sourceContents);
    for (c = 0, l = p.length; c < l; c++) o(t.fromSetString(p[c]), this.sourceContents[p[c]]);
  }, i.prototype.toString = function() {
    var o = "";
    return this.walk(function(c) {
      o += c;
    }), o;
  }, i.prototype.toStringWithSourceMap = function(o) {
    var c = { code: "", line: 1, column: 0 }, l = new e(o), p = !1, d = null, g = null, f = null, x = null;
    return this.walk(function(m, y) {
      c.code += m, y.source !== null && y.line !== null && y.column !== null ? (d === y.source && g === y.line && f === y.column && x === y.name || l.addMapping({ source: y.source, original: { line: y.line, column: y.column }, generated: { line: c.line, column: c.column }, name: y.name }), d = y.source, g = y.line, f = y.column, x = y.name, p = !0) : p && (l.addMapping({ generated: { line: c.line, column: c.column } }), d = null, p = !1);
      for (var v = 0, b = m.length; v < b; v++) m.charCodeAt(v) === 10 ? (c.line++, c.column = 0, v + 1 === b ? (d = null, p = !1) : p && l.addMapping({ source: y.source, original: { line: y.line, column: y.column }, generated: { line: c.line, column: c.column }, name: y.name })) : c.column++;
    }), this.walkSourceContents(function(m, y) {
      l.setSourceContent(m, y);
    }), { code: c.code, map: l };
  }, Pl.SourceNode = i, Pl;
}
function CE() {
  return hm || (hm = 1, Ji.SourceMapGenerator = Eb().SourceMapGenerator, Ji.SourceMapConsumer = PE().SourceMapConsumer, Ji.SourceNode = AE().SourceNode), Ji;
}
function IE() {
  if (dm) return um;
  dm = 1;
  var e = CE(), t = e.SourceMapConsumer, s = e.SourceMapGenerator;
  return um = function(n, i) {
    if (!n) return i;
    if (!i) return n;
    var o = new t(n), c = new t(i), l = new s();
    return c.eachMapping(function(p) {
      if (p.originalLine != null) {
        var d = o.originalPositionFor({ line: p.originalLine, column: p.originalColumn });
        d.source != null && l.addMapping({ original: { line: d.line, column: d.column }, generated: { line: p.generatedLine, column: p.generatedColumn }, source: d.source, name: d.name });
      }
    }), [o, c].forEach(function(p) {
      p.sources.forEach(function(d) {
        l._sources.add(d);
        var g = p.sourceContentFor(d);
        g != null && l.setSourceContent(d, g);
      });
    }), l._sourceRoot = n.sourceRoot, l._file = n.file, JSON.parse(l.toString());
  };
}
var su = xa(IE()), NE = Object.defineProperty, OE = Object.defineProperties, LE = Object.getOwnPropertyDescriptors, fm = Object.getOwnPropertySymbols, RE = Object.prototype.hasOwnProperty, ME = Object.prototype.propertyIsEnumerable, mm = (e, t, s) => t in e ? NE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, zo = (e, t) => {
  for (var s in t || (t = {})) RE.call(t, s) && mm(e, s, t[s]);
  if (fm) for (var s of fm(t)) ME.call(t, s) && mm(e, s, t[s]);
  return e;
}, Wo = (e, t) => OE(e, LE(t));
const gm = (e, t, s, n = require) => {
  const i = n("sass"), { compileString: o, renderSync: c } = i, l = wb(e, s.filename, s.additionalData);
  let p, d, g;
  try {
    if (o) {
      const { pathToFileURL: f, fileURLToPath: x } = n("url"), m = o(l, Wo(zo({}, s), { url: f(s.filename), sourceMap: !!t }));
      p = m.css, d = m.loadedUrls.map((y) => x(y)), g = t ? m.sourceMap : void 0;
    } else {
      const f = c(Wo(zo({}, s), { data: l, file: s.filename, outFile: s.filename, sourceMap: !!t }));
      p = f.css.toString(), d = f.stats.includedFiles, g = t ? JSON.parse(f.map.toString()) : void 0;
    }
    return t ? { code: p, errors: [], dependencies: d, map: su(t, g) } : { code: p, errors: [], dependencies: d };
  } catch (f) {
    return { code: "", errors: [f], dependencies: [] };
  }
}, ym = (e, t, s, n = require) => {
  const i = n("stylus");
  try {
    const o = i(e, s);
    t && o.set("sourcemap", { inline: !1, comment: !1 });
    const c = o.render(), l = o.deps();
    return t ? { code: c, map: su(t, o.sourcemap), errors: [], dependencies: l } : { code: c, errors: [], dependencies: l };
  } catch (o) {
    return { code: "", errors: [o], dependencies: [] };
  }
};
function wb(e, t, s) {
  return s ? Fg(s) ? s(e, t) : s + e : e;
}
const DE = { less: (e, t, s, n = require) => {
  const i = n("less");
  let o, c = null;
  if (i.render(wb(e, s.filename, s.additionalData), Wo(zo({}, s), { syncImport: !0 }), (p, d) => {
    c = p, o = d;
  }), c) return { code: "", errors: [c], dependencies: [] };
  const l = o.imports;
  return t ? { code: o.css.toString(), map: su(t, o.map), errors: [], dependencies: l } : { code: o.css.toString(), errors: [], dependencies: l };
}, sass: (e, t, s, n) => gm(e, t, Wo(zo({}, s), { indentedSyntax: !0 }), n), scss: gm, styl: ym, stylus: ym };
var FE = Object.defineProperty, jE = Object.defineProperties, BE = Object.getOwnPropertyDescriptors, xm = Object.getOwnPropertySymbols, UE = Object.prototype.hasOwnProperty, $E = Object.prototype.propertyIsEnumerable, bm = (e, t, s) => t in e ? FE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, Al = (e, t) => {
  for (var s in t || (t = {})) UE.call(t, s) && bm(e, s, t[s]);
  if (xm) for (var s of xm(t)) $E.call(t, s) && bm(e, s, t[s]);
  return e;
}, Tm = (e, t) => jE(e, BE(t));
function qE(e) {
  return (function(t) {
    const { filename: s, id: n, scoped: i = !1, trim: o = !0, isProd: c = !1, modules: l = !1, modulesOptions: p = {}, preprocessLang: d, postcssOptions: g, postcssPlugins: f } = t, x = d && DE[d], m = x && (function(W, H) {
      if (!W.preprocessCustomRequire) throw new Error("[@vue/compiler-sfc] Style preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor.");
      return H(W.source, W.inMap || W.map, Al({ filename: W.filename }, W.preprocessOptions), W.preprocessCustomRequire);
    })(t, x), y = m ? m.map : t.inMap || t.map, v = m ? m.code : t.source, b = n.replace(/^data-v-/, ""), E = `data-v-${b}`, w = (f || []).slice();
    w.unshift(My({ id: b, isProd: c })), o && w.push(ob()), i && w.push(vb(E));
    let C;
    if (l) throw new Error("[@vue/compiler-sfc] `modules` option is not supported in the browser build.");
    const A = Tm(Al({}, g), { to: s, from: s });
    y && (A.map = { inline: !1, annotation: !1, prev: y });
    let O, D, N;
    const j = new Set(m ? m.dependencies : []);
    j.delete(s);
    const U = [];
    m && m.errors.length && U.push(...m.errors);
    const X = (W) => (W.forEach((H) => {
      H.type === "dependency" && j.add(H.file);
    }), j);
    try {
      if (O = Je(w).process(v, A), t.isAsync) return O.then((W) => ({ code: W.css || "", map: W.map && W.map.toJSON(), errors: U, modules: C, rawResult: W, dependencies: X(W.messages) })).catch((W) => ({ code: "", map: void 0, errors: [...U, W], rawResult: void 0, dependencies: j }));
      X(O.messages), D = O.css, N = O.map;
    } catch (W) {
      U.push(W);
    }
    return { code: D || "", map: N && N.toJSON(), errors: U, rawResult: O, dependencies: j };
  })(Tm(Al({}, e), { isAsync: !0 }));
}
const Jt = "Unknown";
function nu(e, t) {
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(e.value);
    case "Identifier":
      if (!t) return e.name;
  }
}
function vm(e) {
  return e.filter((t) => !!t).join(", ");
}
function _b(e) {
  return e.type.endsWith("Literal");
}
function Ot(e, t) {
  return !!(e && t && e.type === "CallExpression" && e.callee.type === "Identifier" && (typeof t == "string" ? e.callee.name === t : t(e.callee.name)));
}
function Ks(e) {
  return e.length > 1 ? `[${e.join(", ")}]` : e[0];
}
function yp(e) {
  return e.type === "ImportSpecifier" ? e.imported.type === "Identifier" ? e.imported.name : e.imported.value : e.type === "ImportNamespaceSpecifier" ? "*" : "default";
}
function Ps(e) {
  return e.type === "Identifier" ? e.name : e.type === "StringLiteral" ? e.value : null;
}
const VE = (Rr.posix || Rr).normalize, HE = /\\/g;
function Pb(e) {
  return VE(e.replace(HE, "/"));
}
const Wn = (Rr.posix || Rr).join, zE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function Ab(e) {
  return zE.test(e) ? JSON.stringify(e) : e;
}
const Cb = (...e) => e.some((t) => t === "js" || t === "jsx"), Ib = (...e) => e.some((t) => t === "ts" || t === "tsx");
function Nb(e) {
  for (const t of e) if (t.type === "ExportDefaultDeclaration" && t.declaration.type === "ObjectExpression") return WE(t.declaration);
  return {};
}
function WE(e) {
  const t = {};
  Object.defineProperty(t, "__isScriptSetup", { enumerable: !1, value: !1 });
  for (const s of e.properties) if (s.type !== "ObjectProperty" || s.computed || s.key.type !== "Identifier") {
    if (s.type === "ObjectMethod" && s.key.type === "Identifier" && (s.key.name === "setup" || s.key.name === "data")) {
      for (const n of s.body.body) if (n.type === "ReturnStatement" && n.argument && n.argument.type === "ObjectExpression") for (const i of xp(n.argument)) t[i] = s.key.name === "setup" ? "setup-maybe-ref" : "data";
    }
  } else if (s.key.name === "props") for (const n of bp(s.value)) t[n] = "props";
  else if (s.key.name === "inject") for (const n of bp(s.value)) t[n] = "options";
  else if (s.value.type === "ObjectExpression" && (s.key.name === "computed" || s.key.name === "methods")) for (const n of xp(s.value)) t[n] = "options";
  return t;
}
function xp(e) {
  const t = [];
  for (const s of e.properties) {
    if (s.type === "SpreadElement") continue;
    const n = nu(s.key, s.computed);
    n && t.push(String(n));
  }
  return t;
}
function bp(e) {
  return e.type === "ArrayExpression" ? (function(t) {
    const s = [];
    for (const n of t.elements) n && n.type === "StringLiteral" && s.push(n.value);
    return s;
  })(e) : e.type === "ObjectExpression" ? xp(e) : [];
}
var GE = 44, XE = 59, KE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ob = new Uint8Array(64), JE = new Uint8Array(128);
for (let e = 0; e < 64; e++) {
  const t = KE.charCodeAt(e);
  Ob[e] = t, JE[t] = e;
}
function Cn(e, t, s) {
  let n = t - s;
  n = n < 0 ? -n << 1 | 1 : n << 1;
  do {
    let i = 31 & n;
    n >>>= 5, n > 0 && (i |= 32), e.write(Ob[i]);
  } while (n > 0);
  return t;
}
var km = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? { decode: (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString() } : { decode(e) {
  let t = "";
  for (let s = 0; s < e.length; s++) t += String.fromCharCode(e[s]);
  return t;
} }, YE = class {
  constructor() {
    this.pos = 0, this.out = "", this.buffer = new Uint8Array(16384);
  }
  write(e) {
    const { buffer: t } = this;
    t[this.pos++] = e, this.pos === 16384 && (this.out += km.decode(t), this.pos = 0);
  }
  flush() {
    const { buffer: e, out: t, pos: s } = this;
    return s > 0 ? t + km.decode(e.subarray(0, s)) : t;
  }
};
class Go {
  constructor(t) {
    this.bits = t instanceof Go ? t.bits.slice() : [];
  }
  add(t) {
    this.bits[t >> 5] |= 1 << (31 & t);
  }
  has(t) {
    return !!(this.bits[t >> 5] & 1 << (31 & t));
  }
}
class ci {
  constructor(t, s, n) {
    this.start = t, this.end = s, this.original = n, this.intro = "", this.outro = "", this.content = n, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
  }
  appendLeft(t) {
    this.outro += t;
  }
  appendRight(t) {
    this.intro = this.intro + t;
  }
  clone() {
    const t = new ci(this.start, this.end, this.original);
    return t.intro = this.intro, t.outro = this.outro, t.content = this.content, t.storeName = this.storeName, t.edited = this.edited, t;
  }
  contains(t) {
    return this.start < t && t < this.end;
  }
  eachNext(t) {
    let s = this;
    for (; s; ) t(s), s = s.next;
  }
  eachPrevious(t) {
    let s = this;
    for (; s; ) t(s), s = s.previous;
  }
  edit(t, s, n) {
    return this.content = t, n || (this.intro = "", this.outro = ""), this.storeName = s, this.edited = !0, this;
  }
  prependLeft(t) {
    this.outro = t + this.outro;
  }
  prependRight(t) {
    this.intro = t + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(t) {
    const s = t - this.start, n = this.original.slice(0, s), i = this.original.slice(s);
    this.original = n;
    const o = new ci(t, this.end, i);
    return o.outro = this.outro, this.outro = "", this.end = t, this.edited ? (o.edit("", !1), this.content = "") : this.content = n, o.next = this.next, o.next && (o.next.previous = o), o.previous = this, this.next = o, o;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(t) {
    if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
    const s = this.content.replace(t, "");
    return s.length ? (s !== this.content && (this.split(this.start + s.length).edit("", void 0, !0), this.edited && this.edit(s, this.storeName, !0)), !0) : (this.edit("", void 0, !0), this.intro = this.intro.replace(t, ""), !!this.intro.length || void 0);
  }
  trimStart(t) {
    if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
    const s = this.content.replace(t, "");
    if (s.length) {
      if (s !== this.content) {
        const n = this.split(this.end - s.length);
        this.edited && n.edit(s, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    }
    return this.edit("", void 0, !0), this.outro = this.outro.replace(t, ""), !!this.outro.length || void 0;
  }
}
function QE() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (e) => globalThis.btoa(unescape(encodeURIComponent(e))) : typeof Buffer == "function" ? (e) => Buffer.from(e, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
const ZE = QE();
class ew {
  constructor(t) {
    this.version = 3, this.file = t.file, this.sources = t.sources, this.sourcesContent = t.sourcesContent, this.names = t.names, this.mappings = (function(s) {
      const n = new YE();
      let i = 0, o = 0, c = 0, l = 0;
      for (let p = 0; p < s.length; p++) {
        const d = s[p];
        if (p > 0 && n.write(XE), d.length === 0) continue;
        let g = 0;
        for (let f = 0; f < d.length; f++) {
          const x = d[f];
          f > 0 && n.write(GE), g = Cn(n, x[0], g), x.length !== 1 && (i = Cn(n, x[1], i), o = Cn(n, x[2], o), c = Cn(n, x[3], c), x.length !== 4 && (l = Cn(n, x[4], l)));
        }
      }
      return n.flush();
    })(t.mappings), t.x_google_ignoreList !== void 0 && (this.x_google_ignoreList = t.x_google_ignoreList), t.debugId !== void 0 && (this.debugId = t.debugId);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + ZE(this.toString());
  }
}
function tw(e, t) {
  const s = e.split(/[/\\]/), n = t.split(/[/\\]/);
  for (s.pop(); s[0] === n[0]; ) s.shift(), n.shift();
  if (s.length) {
    let i = s.length;
    for (; i--; ) s[i] = "..";
  }
  return s.concat(n).join("/");
}
const rw = Object.prototype.toString;
function Sm(e) {
  const t = e.split(`
`), s = [];
  for (let n = 0, i = 0; n < t.length; n++) s.push(i), i += t[n].length + 1;
  return function(n) {
    let i = 0, o = s.length;
    for (; i < o; ) {
      const l = i + o >> 1;
      n < s[l] ? o = l : i = l + 1;
    }
    const c = i - 1;
    return { line: c, column: n - s[c] };
  };
}
const sw = /\w/;
class nw {
  constructor(t) {
    this.hires = t, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(t, s, n, i) {
    if (s.length) {
      const o = s.length - 1;
      let c = s.indexOf(`
`, 0), l = -1;
      for (; c >= 0 && o > c; ) {
        const d = [this.generatedCodeColumn, t, n.line, n.column];
        i >= 0 && d.push(i), this.rawSegments.push(d), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, l = c, c = s.indexOf(`
`, c + 1);
      }
      const p = [this.generatedCodeColumn, t, n.line, n.column];
      i >= 0 && p.push(i), this.rawSegments.push(p), this.advance(s.slice(l + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(s));
    this.pending = null;
  }
  addUneditedChunk(t, s, n, i, o) {
    let c = s.start, l = !0, p = !1;
    for (; c < s.end; ) {
      if (n[c] === `
`) i.line += 1, i.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, l = !0, p = !1;
      else {
        if (this.hires || l || o.has(c)) {
          const d = [this.generatedCodeColumn, t, i.line, i.column];
          this.hires === "boundary" ? sw.test(n[c]) ? p || (this.rawSegments.push(d), p = !0) : (this.rawSegments.push(d), p = !1) : this.rawSegments.push(d);
        }
        i.column += 1, this.generatedCodeColumn += 1, l = !1;
      }
      c += 1;
    }
    this.pending = null;
  }
  advance(t) {
    if (!t) return;
    const s = t.split(`
`);
    if (s.length > 1) {
      for (let n = 0; n < s.length - 1; n++) this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += s[s.length - 1].length;
  }
}
const In = `
`, Us = { insertLeft: !1, insertRight: !1, storeName: !1 };
class Ba {
  constructor(t, s = {}) {
    const n = new ci(0, t.length, t);
    Object.defineProperties(this, { original: { writable: !0, value: t }, outro: { writable: !0, value: "" }, intro: { writable: !0, value: "" }, firstChunk: { writable: !0, value: n }, lastChunk: { writable: !0, value: n }, lastSearchedChunk: { writable: !0, value: n }, byStart: { writable: !0, value: {} }, byEnd: { writable: !0, value: {} }, filename: { writable: !0, value: s.filename }, indentExclusionRanges: { writable: !0, value: s.indentExclusionRanges }, sourcemapLocations: { writable: !0, value: new Go() }, storedNames: { writable: !0, value: {} }, indentStr: { writable: !0, value: void 0 }, ignoreList: { writable: !0, value: s.ignoreList }, offset: { writable: !0, value: s.offset || 0 } }), this.byStart[0] = n, this.byEnd[t.length] = n;
  }
  addSourcemapLocation(t) {
    this.sourcemapLocations.add(t);
  }
  append(t) {
    if (typeof t != "string") throw new TypeError("outro content must be a string");
    return this.outro += t, this;
  }
  appendLeft(t, s) {
    if (t += this.offset, typeof s != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const n = this.byEnd[t];
    return n ? n.appendLeft(s) : this.intro += s, this;
  }
  appendRight(t, s) {
    if (t += this.offset, typeof s != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const n = this.byStart[t];
    return n ? n.appendRight(s) : this.outro += s, this;
  }
  clone() {
    const t = new Ba(this.original, { filename: this.filename, offset: this.offset });
    let s = this.firstChunk, n = t.firstChunk = t.lastSearchedChunk = s.clone();
    for (; s; ) {
      t.byStart[n.start] = n, t.byEnd[n.end] = n;
      const i = s.next, o = i && i.clone();
      o && (n.next = o, o.previous = n, n = o), s = i;
    }
    return t.lastChunk = n, this.indentExclusionRanges && (t.indentExclusionRanges = this.indentExclusionRanges.slice()), t.sourcemapLocations = new Go(this.sourcemapLocations), t.intro = this.intro, t.outro = this.outro, t;
  }
  generateDecodedMap(t) {
    t = t || {};
    const s = Object.keys(this.storedNames), n = new nw(t.hires), i = Sm(this.original);
    return this.intro && n.advance(this.intro), this.firstChunk.eachNext((o) => {
      const c = i(o.start);
      o.intro.length && n.advance(o.intro), o.edited ? n.addEdit(0, o.content, c, o.storeName ? s.indexOf(o.original) : -1) : n.addUneditedChunk(0, o, this.original, c, this.sourcemapLocations), o.outro.length && n.advance(o.outro);
    }), this.outro && n.advance(this.outro), { file: t.file ? t.file.split(/[/\\]/).pop() : void 0, sources: [t.source ? tw(t.file || "", t.source) : t.file || ""], sourcesContent: t.includeContent ? [this.original] : void 0, names: s, mappings: n.raw, x_google_ignoreList: this.ignoreList ? [0] : void 0 };
  }
  generateMap(t) {
    return new ew(this.generateDecodedMap(t));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = (function(t) {
      const s = t.split(`
`), n = s.filter((c) => /^\t+/.test(c)), i = s.filter((c) => /^ {2,}/.test(c));
      if (n.length === 0 && i.length === 0) return null;
      if (n.length >= i.length) return "	";
      const o = i.reduce((c, l) => {
        const p = /^ +/.exec(l)[0].length;
        return Math.min(p, c);
      }, 1 / 0);
      return new Array(o + 1).join(" ");
    })(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(t, s) {
    const n = /^[^\r\n]/gm;
    var i;
    if (i = t, rw.call(i) === "[object Object]" && (s = t, t = void 0), t === void 0 && (this._ensureindentStr(), t = this.indentStr || "	"), t === "") return this;
    const o = {};
    (s = s || {}).exclude && (typeof s.exclude[0] == "number" ? [s.exclude] : s.exclude).forEach((g) => {
      for (let f = g[0]; f < g[1]; f += 1) o[f] = !0;
    });
    let c = s.indentStart !== !1;
    const l = (g) => c ? `${t}${g}` : (c = !0, g);
    this.intro = this.intro.replace(n, l);
    let p = 0, d = this.firstChunk;
    for (; d; ) {
      const g = d.end;
      if (d.edited) o[p] || (d.content = d.content.replace(n, l), d.content.length && (c = d.content[d.content.length - 1] === `
`));
      else for (p = d.start; p < g; ) {
        if (!o[p]) {
          const f = this.original[p];
          f === `
` ? c = !0 : f !== "\r" && c && (c = !1, p === d.start || (this._splitChunk(d, p), d = d.next), d.prependRight(t));
        }
        p += 1;
      }
      p = d.end, d = d.next;
    }
    return this.outro = this.outro.replace(n, l), this;
  }
  insert() {
    throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
  }
  insertLeft(t, s) {
    return Us.insertLeft || (console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"), Us.insertLeft = !0), this.appendLeft(t, s);
  }
  insertRight(t, s) {
    return Us.insertRight || (console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"), Us.insertRight = !0), this.prependRight(t, s);
  }
  move(t, s, n) {
    if (t += this.offset, s += this.offset, (n += this.offset) >= t && n <= s) throw new Error("Cannot move a selection inside itself");
    this._split(t), this._split(s), this._split(n);
    const i = this.byStart[t], o = this.byEnd[s], c = i.previous, l = o.next, p = this.byStart[n];
    if (!p && o === this.lastChunk) return this;
    const d = p ? p.previous : this.lastChunk;
    return c && (c.next = l), l && (l.previous = c), d && (d.next = i), p && (p.previous = o), i.previous || (this.firstChunk = o.next), o.next || (this.lastChunk = i.previous, this.lastChunk.next = null), i.previous = d, o.next = p || null, d || (this.firstChunk = i), p || (this.lastChunk = o), this;
  }
  overwrite(t, s, n, i) {
    return i = i || {}, this.update(t, s, n, { ...i, overwrite: !i.contentOnly });
  }
  update(t, s, n, i) {
    if (t += this.offset, s += this.offset, typeof n != "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; s < 0; ) s += this.original.length;
    }
    if (s > this.original.length) throw new Error("end is out of bounds");
    if (t === s) throw new Error("Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead");
    this._split(t), this._split(s), i === !0 && (Us.storeName || (console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"), Us.storeName = !0), i = { storeName: !0 });
    const o = i !== void 0 && i.storeName, c = i !== void 0 && i.overwrite;
    if (o) {
      const d = this.original.slice(t, s);
      Object.defineProperty(this.storedNames, d, { writable: !0, value: !0, enumerable: !0 });
    }
    const l = this.byStart[t], p = this.byEnd[s];
    if (l) {
      let d = l;
      for (; d !== p; ) {
        if (d.next !== this.byStart[d.end]) throw new Error("Cannot overwrite across a split point");
        d = d.next, d.edit("", !1);
      }
      l.edit(n, o, !c);
    } else {
      const d = new ci(t, s, "").edit(n, o);
      p.next = d, d.previous = p;
    }
    return this;
  }
  prepend(t) {
    if (typeof t != "string") throw new TypeError("outro content must be a string");
    return this.intro = t + this.intro, this;
  }
  prependLeft(t, s) {
    if (t += this.offset, typeof s != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const n = this.byEnd[t];
    return n ? n.prependLeft(s) : this.intro = s + this.intro, this;
  }
  prependRight(t, s) {
    if (t += this.offset, typeof s != "string") throw new TypeError("inserted content must be a string");
    this._split(t);
    const n = this.byStart[t];
    return n ? n.prependRight(s) : this.outro = s + this.outro, this;
  }
  remove(t, s) {
    if (t += this.offset, s += this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; s < 0; ) s += this.original.length;
    }
    if (t === s) return this;
    if (t < 0 || s > this.original.length) throw new Error("Character is out of bounds");
    if (t > s) throw new Error("end must be greater than start");
    this._split(t), this._split(s);
    let n = this.byStart[t];
    for (; n; ) n.intro = "", n.outro = "", n.edit(""), n = s > n.end ? this.byStart[n.end] : null;
    return this;
  }
  reset(t, s) {
    if (t += this.offset, s += this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; s < 0; ) s += this.original.length;
    }
    if (t === s) return this;
    if (t < 0 || s > this.original.length) throw new Error("Character is out of bounds");
    if (t > s) throw new Error("end must be greater than start");
    this._split(t), this._split(s);
    let n = this.byStart[t];
    for (; n; ) n.reset(), n = s > n.end ? this.byStart[n.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let t = this.lastChunk;
    do {
      if (t.outro.length) return t.outro[t.outro.length - 1];
      if (t.content.length) return t.content[t.content.length - 1];
      if (t.intro.length) return t.intro[t.intro.length - 1];
    } while (t = t.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let t = this.outro.lastIndexOf(In);
    if (t !== -1) return this.outro.substr(t + 1);
    let s = this.outro, n = this.lastChunk;
    do {
      if (n.outro.length > 0) {
        if (t = n.outro.lastIndexOf(In), t !== -1) return n.outro.substr(t + 1) + s;
        s = n.outro + s;
      }
      if (n.content.length > 0) {
        if (t = n.content.lastIndexOf(In), t !== -1) return n.content.substr(t + 1) + s;
        s = n.content + s;
      }
      if (n.intro.length > 0) {
        if (t = n.intro.lastIndexOf(In), t !== -1) return n.intro.substr(t + 1) + s;
        s = n.intro + s;
      }
    } while (n = n.previous);
    return t = this.intro.lastIndexOf(In), t !== -1 ? this.intro.substr(t + 1) + s : this.intro + s;
  }
  slice(t = 0, s = this.original.length - this.offset) {
    if (t += this.offset, s += this.offset, this.original.length !== 0) {
      for (; t < 0; ) t += this.original.length;
      for (; s < 0; ) s += this.original.length;
    }
    let n = "", i = this.firstChunk;
    for (; i && (i.start > t || i.end <= t); ) {
      if (i.start < s && i.end >= s) return n;
      i = i.next;
    }
    if (i && i.edited && i.start !== t) throw new Error(`Cannot use replaced character ${t} as slice start anchor.`);
    const o = i;
    for (; i; ) {
      !i.intro || o === i && i.start !== t || (n += i.intro);
      const c = i.start < s && i.end >= s;
      if (c && i.edited && i.end !== s) throw new Error(`Cannot use replaced character ${s} as slice end anchor.`);
      const l = o === i ? t - i.start : 0, p = c ? i.content.length + s - i.end : i.content.length;
      if (n += i.content.slice(l, p), !i.outro || c && i.end !== s || (n += i.outro), c) break;
      i = i.next;
    }
    return n;
  }
  snip(t, s) {
    const n = this.clone();
    return n.remove(0, t), n.remove(s, n.original.length), n;
  }
  _split(t) {
    if (this.byStart[t] || this.byEnd[t]) return;
    let s = this.lastSearchedChunk, n = s;
    const i = t > s.end;
    for (; s; ) {
      if (s.contains(t)) return this._splitChunk(s, t);
      if (s = i ? this.byStart[s.end] : this.byEnd[s.start], s === n) return;
      n = s;
    }
  }
  _splitChunk(t, s) {
    if (t.edited && t.content.length) {
      const i = Sm(this.original)(s);
      throw new Error(`Cannot split a chunk that has already been edited (${i.line}:${i.column} â€“ "${t.original}")`);
    }
    const n = t.split(s);
    return this.byEnd[s] = t, this.byStart[s] = n, this.byEnd[n.end] = n, t === this.lastChunk && (this.lastChunk = n), this.lastSearchedChunk = t, !0;
  }
  toString() {
    let t = this.intro, s = this.firstChunk;
    for (; s; ) t += s.toString(), s = s.next;
    return t + this.outro;
  }
  isEmpty() {
    let t = this.firstChunk;
    do
      if (t.intro.length && t.intro.trim() || t.content.length && t.content.trim() || t.outro.length && t.outro.trim()) return !1;
    while (t = t.next);
    return !0;
  }
  length() {
    let t = this.firstChunk, s = 0;
    do
      s += t.intro.length + t.content.length + t.outro.length;
    while (t = t.next);
    return s;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(t) {
    return this.trimStart(t).trimEnd(t);
  }
  trimEndAborted(t) {
    const s = new RegExp((t || "\\s") + "+$");
    if (this.outro = this.outro.replace(s, ""), this.outro.length) return !0;
    let n = this.lastChunk;
    do {
      const i = n.end, o = n.trimEnd(s);
      if (n.end !== i && (this.lastChunk === n && (this.lastChunk = n.next), this.byEnd[n.end] = n, this.byStart[n.next.start] = n.next, this.byEnd[n.next.end] = n.next), o) return !0;
      n = n.previous;
    } while (n);
    return !1;
  }
  trimEnd(t) {
    return this.trimEndAborted(t), this;
  }
  trimStartAborted(t) {
    const s = new RegExp("^" + (t || "\\s") + "+");
    if (this.intro = this.intro.replace(s, ""), this.intro.length) return !0;
    let n = this.firstChunk;
    do {
      const i = n.end, o = n.trimStart(s);
      if (n.end !== i && (n === this.lastChunk && (this.lastChunk = n.next), this.byEnd[n.end] = n, this.byStart[n.next.start] = n.next, this.byEnd[n.next.end] = n.next), o) return !0;
      n = n.next;
    } while (n);
    return !1;
  }
  trimStart(t) {
    return this.trimStartAborted(t), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(t, s) {
    function n(i, o) {
      return typeof s == "string" ? s.replace(/\$(\$|&|\d+)/g, (c, l) => l === "$" ? "$" : l === "&" ? i[0] : +l < i.length ? i[+l] : `$${l}`) : s(...i, i.index, o, i.groups);
    }
    if (t.global)
      (function(o, c) {
        let l;
        const p = [];
        for (; l = o.exec(c); ) p.push(l);
        return p;
      })(t, this.original).forEach((o) => {
        if (o.index != null) {
          const c = n(o, this.original);
          c !== o[0] && this.overwrite(o.index, o.index + o[0].length, c);
        }
      });
    else {
      const i = this.original.match(t);
      if (i && i.index != null) {
        const o = n(i, this.original);
        o !== i[0] && this.overwrite(i.index, i.index + i[0].length, o);
      }
    }
    return this;
  }
  _replaceString(t, s) {
    const { original: n } = this, i = n.indexOf(t);
    return i !== -1 && (typeof s == "function" && (s = s(t, i, n)), t !== s && this.overwrite(i, i + t.length, s)), this;
  }
  replace(t, s) {
    return typeof t == "string" ? this._replaceString(t, s) : this._replaceRegexp(t, s);
  }
  _replaceAllString(t, s) {
    const { original: n } = this, i = t.length;
    for (let o = n.indexOf(t); o !== -1; o = n.indexOf(t, o + i)) {
      const c = n.slice(o, o + i);
      let l = s;
      typeof s == "function" && (l = s(c, o, n)), c !== l && this.overwrite(o, o + i, l);
    }
    return this;
  }
  replaceAll(t, s) {
    if (typeof t == "string") return this._replaceAllString(t, s);
    if (!t.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
    return this._replaceRegexp(t, s);
  }
}
var Em, wm;
class _m {
  constructor(t, s) {
    this.descriptor = t, this.options = s, this.isCE = !1, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new Ba(this.source), this.startOffset = (Em = this.descriptor.scriptSetup) == null ? void 0 : Em.loc.start.offset, this.endOffset = (wm = this.descriptor.scriptSetup) == null ? void 0 : wm.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = !1, this.hasDefineEmitCall = !1, this.hasDefineExposeCall = !1, this.hasDefaultExportName = !1, this.hasDefaultExportRender = !1, this.hasDefineOptionsCall = !1, this.hasDefineSlotsCall = !1, this.hasDefineModelCall = !1, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
    const { script: n, scriptSetup: i } = t, o = n && n.lang, c = i && i.lang;
    this.isJS = Cb(o, c), this.isTS = Ib(o, c);
    const l = s.customElement, p = this.descriptor.filename;
    l && (this.isCE = typeof l == "boolean" ? l : l(p));
    const d = go(o || c, s.babelParserPlugins);
    function g(f, x) {
      try {
        return ar.parse(f, { plugins: d, sourceType: "module" }).program;
      } catch (m) {
        throw m.message = `[vue/compiler-sfc] ${m.message}

${t.filename}
${mi(t.source, m.pos + x, m.pos + x + 1)}`, m;
      }
    }
    this.scriptAst = t.script && g(t.script.content, t.script.loc.start.offset), this.scriptSetupAst = t.scriptSetup && g(t.scriptSetup.content, this.startOffset);
  }
  helper(t) {
    return this.helperImports.add(t), `_${t}`;
  }
  getString(t, s = !0) {
    return (s ? this.descriptor.scriptSetup : this.descriptor.script).content.slice(t.start, t.end);
  }
  warn(t, s, n) {
    Vo(Pm(t, s, this, n));
  }
  error(t, s, n) {
    throw new Error(`[@vue/compiler-sfc] ${Pm(t, s, this, n)}`);
  }
}
function Pm(e, t, s, n) {
  const i = n ? n.offset : s.startOffset;
  return `${e}

${(n || s.descriptor).filename}
${mi((n || s.descriptor).source, t.start + i, t.end + i)}`;
}
function go(e, t, s = !1) {
  const n = [];
  return t && t.some((i) => i === "importAssertions" || i === "importAttributes" || gt(i) && i[0] === "importAttributes") || n.push("importAttributes"), e === "jsx" || e === "tsx" || e === "mtsx" ? n.push("jsx") : t && (t = t.filter((i) => i !== "jsx")), e !== "ts" && e !== "mts" && e !== "tsx" && e !== "mtsx" || (n.push(["typescript", { dts: s }], "explicitResourceManagement"), t && t.includes("decorators") || n.push("decorators-legacy")), t && n.push(...t), n;
}
function Cl(e, t, s) {
  let n = !1, i = t;
  for (; t < s; ) if (/\s/.test(e.slice(t, t + 1))) t++;
  else {
    if (e.slice(t, t + 1) === ",") {
      t++, n = !0;
      break;
    }
    if (e.slice(t, t + 1) === "}") break;
  }
  return n ? t : i;
}
var iw = Object.defineProperty, ow = Object.defineProperties, aw = Object.getOwnPropertyDescriptors, Am = Object.getOwnPropertySymbols, cw = Object.prototype.hasOwnProperty, lw = Object.prototype.propertyIsEnumerable, Cm = (e, t, s) => t in e ? iw(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
const Ws = "__default__";
function pw(e, t) {
  var s;
  const n = e.descriptor.script;
  try {
    let c = n.content, l = n.map;
    const p = e.scriptAst, d = Nb(p.body), { cssVars: g } = e.descriptor, { genDefaultAs: f, isProd: x } = e.options;
    if (g.length || f) {
      const m = f || Ws, y = new Ba(c);
      (function(v, b, E) {
        (function(w) {
          for (const C of w)
            if (C.type === "ExportDefaultDeclaration" || C.type === "ExportNamedDeclaration" && C.specifiers.some((A) => A.exported.name === "default")) return !0;
          return !1;
        })(v) ? v.forEach((w) => {
          if (w.type === "ExportDefaultDeclaration") if (w.declaration.type === "ClassDeclaration" && w.declaration.id) {
            const C = w.declaration.decorators && w.declaration.decorators.length > 0 ? w.declaration.decorators[w.declaration.decorators.length - 1].end : w.start;
            b.overwrite(C, w.declaration.id.start, " class "), b.append(`
const ${E} = ${w.declaration.id.name}`);
          } else b.overwrite(w.start, w.declaration.start, `const ${E} = `);
          else if (w.type === "ExportNamedDeclaration") {
            for (const C of w.specifiers) if (C.type === "ExportSpecifier" && C.exported.type === "Identifier" && C.exported.name === "default") {
              if (w.source) {
                if (C.local.name === "default") {
                  b.prepend(`import { default as __VUE_DEFAULT__ } from '${w.source.value}'
`);
                  const O = Cl(b, C.local.end, w.end);
                  b.remove(C.start, O), b.append(`
const ${E} = __VUE_DEFAULT__`);
                  continue;
                }
                {
                  b.prepend(`import { ${b.slice(C.local.start, C.local.end)} as __VUE_DEFAULT__ } from '${w.source.value}'
`);
                  const O = Cl(b, C.exported.end, w.end);
                  b.remove(C.start, O), b.append(`
const ${E} = __VUE_DEFAULT__`);
                  continue;
                }
              }
              const A = Cl(b, C.end, w.end);
              b.remove(C.start, A), b.append(`
const ${E} = ${C.local.name}`);
            }
          }
        }) : b.append(`
const ${E} = {}`);
      })(p.body, y, m), c = y.toString(), g.length && !((s = e.options.templateOptions) != null && s.ssr) && (c += (function(v, b, E, w, C) {
        return `
import { ${Ro} as _${Ro} } from 'vue'
const __injectCSSVars__ = () => {
${Dy(v, b, E, w)}}
const __setup__ = ${C}.setup
${C}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
      })(g, d, t, !!x, m)), f || (c += `
export default ${m}`);
    }
    return i = ((m, y) => {
      for (var v in y || (y = {})) cw.call(y, v) && Cm(m, v, y[v]);
      if (Am) for (var v of Am(y)) lw.call(y, v) && Cm(m, v, y[v]);
      return m;
    })({}, n), o = { content: c, map: l, bindings: d, scriptAst: p.body }, ow(i, aw(o));
  } catch {
    return n;
  }
  var i, o;
}
var hw = Object.defineProperty, uw = Object.defineProperties, dw = Object.getOwnPropertyDescriptors, Im = Object.getOwnPropertySymbols, fw = Object.prototype.hasOwnProperty, mw = Object.prototype.propertyIsEnumerable, Nm = (e, t, s) => t in e ? hw(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, yo = (e, t) => {
  for (var s in t || (t = {})) fw.call(t, s) && Nm(e, s, t[s]);
  if (Im) for (var s of Im(t)) mw.call(t, s) && Nm(e, s, t[s]);
  return e;
}, xo = (e, t) => uw(e, dw(t));
class iu {
  constructor(t, s, n = 0, i = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null)) {
    this.filename = t, this.source = s, this.offset = n, this.imports = i, this.types = o, this.declares = c, this.isGenericScope = !1, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function wt(e, t, s, n) {
  const i = !n;
  if (i && t._resolvedElements) return t._resolvedElements;
  const o = (function(c, l, p, d) {
    var g, f;
    if (l.leadingComments && l.leadingComments.some((x) => x.value.includes("@vue-ignore"))) return { props: {} };
    switch (l.type) {
      case "TSTypeLiteral":
        return Om(c, l.members, p, d);
      case "TSInterfaceDeclaration":
        return (function(x, m, y, v) {
          const b = Om(x, m.body.body, m._ownerScope, v);
          if (m.extends) for (const E of m.extends) try {
            const { props: w, calls: C } = wt(x, E, y);
            for (const A in w) Bp(b.props, A) || (b.props[A] = w[A]);
            C && (b.calls || (b.calls = [])).push(...C);
          } catch {
            x.error(`Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`, E, y);
          }
          return b;
        })(c, l, p, d);
      case "TSTypeAliasDeclaration":
      case "TSTypeAnnotation":
      case "TSParenthesizedType":
        return wt(c, l.typeAnnotation, p, d);
      case "TSFunctionType":
        return { props: {}, calls: [l] };
      case "TSUnionType":
      case "TSIntersectionType":
        return Lm(l.types.map((x) => wt(c, x, p, d)), l.type);
      case "TSMappedType":
        return (function(x, m, y, v) {
          const b = { props: {} };
          let E;
          if (m.nameType) {
            const { name: w, constraint: C } = m.typeParameter;
            y = lu(y), Object.assign(y.types, xo(yo({}, v), { [w]: C })), E = nr(x, m.nameType, y);
          } else E = nr(x, m.typeParameter.constraint, y);
          for (const w of E) b.props[w] = Gn({ type: "Identifier", name: w }, m.typeAnnotation, y, !!m.optional);
          return b;
        })(c, l, p, d);
      case "TSIndexedAccessType":
        return Lm(Lb(c, l, p).map((x) => wt(c, x, x._ownerScope)), "TSUnionType");
      case "TSExpressionWithTypeArguments":
      case "TSTypeReference": {
        const x = au(l);
        if ((x === "ExtractPropTypes" || x === "ExtractPublicPropTypes") && l.typeParameters && ((g = p.imports[x]) == null ? void 0 : g.source) === "vue") return Fm(wt(c, l.typeParameters.params[0], p, d), p);
        const m = Tr(c, l, p);
        if (m) {
          let y;
          return (m.type === "TSTypeAliasDeclaration" || m.type === "TSInterfaceDeclaration") && m.typeParameters && l.typeParameters && (y = /* @__PURE__ */ Object.create(null), m.typeParameters.params.forEach((v, b) => {
            let E = d && d[v.name];
            E || (E = l.typeParameters.params[b]), y[v.name] = E;
          })), wt(c, m, m._ownerScope, y);
        }
        if (typeof x == "string") {
          if (d && d[x]) return wt(c, d[x], p, d);
          if (gw.has(x)) return (function(y, v, b, E, w) {
            const C = wt(y, v.typeParameters.params[0], E, w);
            switch (b) {
              case "Partial": {
                const D = { props: {}, calls: C.calls };
                return Object.keys(C.props).forEach((N) => {
                  D.props[N] = xo(yo({}, C.props[N]), { optional: !0 });
                }), D;
              }
              case "Required": {
                const D = { props: {}, calls: C.calls };
                return Object.keys(C.props).forEach((N) => {
                  D.props[N] = xo(yo({}, C.props[N]), { optional: !1 });
                }), D;
              }
              case "Readonly":
                return C;
              case "Pick": {
                const D = nr(y, v.typeParameters.params[1], E, w), N = { props: {}, calls: C.calls };
                for (const j of D) N.props[j] = C.props[j];
                return N;
              }
              case "Omit":
                const A = nr(y, v.typeParameters.params[1], E, w), O = { props: {}, calls: C.calls };
                for (const D in C.props) A.includes(D) || (O.props[D] = C.props[D]);
                return O;
            }
          })(c, l, x, p, d);
          if (x === "ReturnType" && l.typeParameters) {
            const y = (function(v, b, E) {
              var w;
              let C = b;
              if (b.type !== "TSTypeReference" && b.type !== "TSTypeQuery" && b.type !== "TSImportType" || (C = Tr(v, b, E)), !!C) {
                if (C.type === "TSFunctionType") return (w = C.typeAnnotation) == null ? void 0 : w.typeAnnotation;
                if (C.type === "TSDeclareFunction") return C.returnType;
              }
            })(c, l.typeParameters.params[0], p);
            if (y) return wt(c, y, p);
          }
        }
        return c.error("Unresolvable type reference or unsupported built-in utility type", l, p);
      }
      case "TSImportType": {
        if (Ps(l.argument) === "vue" && ((f = l.qualifier) == null ? void 0 : f.type) === "Identifier" && l.qualifier.name === "ExtractPropTypes" && l.typeParameters) return Fm(wt(c, l.typeParameters.params[0], p), p);
        const x = Ua(c, l.argument, p, l.argument.value), m = Tr(c, l, x);
        if (m) return wt(c, m, m._ownerScope);
        break;
      }
      case "TSTypeQuery": {
        const x = Tr(c, l, p);
        if (x) return wt(c, x, x._ownerScope);
      }
    }
    return c.error(`Unresolvable type: ${l.type}`, l, p);
  })(e, t, t._ownerScope || s || $a(e), n);
  return i ? t._resolvedElements = o : o;
}
function Om(e, t, s = $a(e), n) {
  const i = { props: {} };
  for (const o of t) if (o.type === "TSPropertySignature" || o.type === "TSMethodSignature") {
    n && ((s = lu(s)).isGenericScope = !0, Object.assign(s.types, n)), o._ownerScope = s;
    const c = Ps(o.key);
    if (c && !o.computed) i.props[c] = o;
    else if (o.key.type === "TemplateLiteral") for (const l of ou(e, o.key, s)) i.props[l] = o;
    else e.error("Unsupported computed key in type referenced by a macro", o.key, s);
  } else o.type === "TSCallSignatureDeclaration" && (i.calls || (i.calls = [])).push(o);
  return i;
}
function Lm(e, t) {
  if (e.length === 1) return e[0];
  const s = { props: {} }, { props: n } = s;
  for (const { props: i, calls: o } of e) {
    for (const c in i) Bp(n, c) ? n[c] = Gn(n[c].key, { type: t, types: [n[c], i[c]] }, n[c]._ownerScope, n[c].optional || i[c].optional) : n[c] = i[c];
    o && (s.calls || (s.calls = [])).push(...o);
  }
  return s;
}
function Gn(e, t, s, n) {
  return { type: "TSPropertySignature", key: e, kind: "get", optional: n, typeAnnotation: { type: "TSTypeAnnotation", typeAnnotation: t }, _ownerScope: s };
}
function Lb(e, t, s) {
  var n, i;
  if (t.indexType.type === "TSNumberKeyword") return Rb(e, t.objectType, s);
  const { indexType: o, objectType: c } = t, l = [];
  let p, d;
  o.type === "TSStringKeyword" ? (d = wt(e, c, s), p = Object.keys(d.props)) : (p = nr(e, o, s), d = wt(e, c, s));
  for (const g of p) {
    const f = (i = (n = d.props[g]) == null ? void 0 : n.typeAnnotation) == null ? void 0 : i.typeAnnotation;
    f && (f._ownerScope = d.props[g]._ownerScope, l.push(f));
  }
  return l;
}
function Rb(e, t, s) {
  if (t.type === "TSArrayType") return [t.elementType];
  if (t.type === "TSTupleType") return t.elementTypes.map((n) => n.type === "TSNamedTupleMember" ? n.elementType : n);
  if (t.type === "TSTypeReference") {
    if (au(t) === "Array" && t.typeParameters) return t.typeParameters.params;
    {
      const n = Tr(e, t, s);
      if (n) return Rb(e, n, s);
    }
  }
  return e.error("Failed to resolve element type from target type", t, s);
}
function nr(e, t, s, n) {
  switch (t.type) {
    case "StringLiteral":
      return [t.value];
    case "TSLiteralType":
      return nr(e, t.literal, s, n);
    case "TSUnionType":
      return t.types.map((i) => nr(e, i, s, n)).flat();
    case "TemplateLiteral":
      return ou(e, t, s);
    case "TSTypeReference": {
      const i = Tr(e, t, s);
      if (i) return nr(e, i, s, n);
      if (t.typeName.type === "Identifier") {
        const o = t.typeName.name;
        if (n && n[o]) return nr(e, n[o], s, n);
        const c = (l = 0) => nr(e, t.typeParameters.params[l], s, n);
        switch (o) {
          case "Extract":
            return c(1);
          case "Exclude": {
            const l = c(1);
            return c().filter((p) => !l.includes(p));
          }
          case "Uppercase":
            return c().map((l) => l.toUpperCase());
          case "Lowercase":
            return c().map((l) => l.toLowerCase());
          case "Capitalize":
            return c().map(Yr);
          case "Uncapitalize":
            return c().map((l) => l[0].toLowerCase() + l.slice(1));
          default:
            e.error("Unsupported type when resolving index type", t.typeName, s);
        }
      }
    }
  }
  return e.error("Failed to resolve index type into finite keys", t, s);
}
function ou(e, t, s) {
  if (!t.expressions.length) return [t.quasis[0].value.raw];
  const n = [], i = t.expressions[0], o = t.quasis[0], c = o ? o.value.raw : "", l = nr(e, i, s), p = ou(e, xo(yo({}, t), { expressions: t.expressions.slice(1), quasis: o ? t.quasis.slice(1) : t.quasis }), s);
  for (const d of l) for (const g of p) n.push(c + d + g);
  return n;
}
const gw = /* @__PURE__ */ new Set(["Partial", "Required", "Readonly", "Pick", "Omit"]);
function Tr(e, t, s, n, i = !1) {
  const o = !s?.isGenericScope;
  if (o && t._resolvedReference) return t._resolvedReference;
  const c = Tp(e, s || $a(e), n || au(t), t, i);
  return o ? t._resolvedReference = c : c;
}
function Tp(e, t, s, n, i) {
  if (typeof s == "string") {
    if (t.imports[s]) return (function(o, c, l, p) {
      const { source: d, imported: g } = p.imports[l], f = Ua(o, c, p, d);
      return Tr(o, c, f, g, !0);
    })(e, n, s, t);
    {
      const o = n.type === "TSTypeQuery" ? i ? t.exportedDeclares : t.declares : i ? t.exportedTypes : t.types;
      if (o[s]) return o[s];
      {
        const c = (function(l) {
          if (l.options.globalTypeFiles) {
            if (!cu(l)) throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
            return l.options.globalTypeFiles.map((p) => Db(l, Pb(p), !0));
          }
        })(e);
        if (c) for (const l of c) {
          const p = n.type === "TSTypeQuery" ? l.declares : l.types;
          if (p[s]) return (e.deps || (e.deps = /* @__PURE__ */ new Set())).add(l.filename), p[s];
        }
      }
    }
  } else {
    let o = Tp(e, t, s[0], n, i);
    if (o && (o.type !== "TSModuleDeclaration" && (o = o._ns), o)) {
      const c = (function(l, p, d) {
        if (p._resolvedChildScope) return p._resolvedChildScope;
        const g = lu(d);
        if (p.body.type === "TSModuleDeclaration") {
          const f = p.body;
          f._ownerScope = g;
          const x = Ps(f.id);
          g.types[x] = g.exportedTypes[x] = f;
        } else pu(l, p.body.body, g);
        return p._resolvedChildScope = g;
      })(e, o, o._ownerScope || t);
      return Tp(e, c, s.length > 2 ? s.slice(1) : s[s.length - 1], n, !o.declare);
    }
  }
}
function au(e) {
  const t = e.type === "TSTypeReference" ? e.typeName : e.type === "TSExpressionWithTypeArguments" ? e.expression : e.type === "TSImportType" ? e.qualifier : e.exprName;
  return t?.type === "Identifier" ? t.name : t?.type === "TSQualifiedName" ? Mb(t) : "default";
}
function Mb(e) {
  return e.type === "Identifier" ? [e.name] : [...Mb(e.left), e.right.name];
}
function cu(e) {
  if (e.fs) return e.fs;
  const t = e.options.fs || void 0;
  return t ? e.fs = { fileExists: (s) => (s.endsWith(".vue.ts") && !s.endsWith(".d.vue.ts") && (s = s.replace(/\.ts$/, "")), t.fileExists(s)), readFile: (s) => (s.endsWith(".vue.ts") && !s.endsWith(".d.vue.ts") && (s = s.replace(/\.ts$/, "")), t.readFile(s)), realpath: t.realpath } : void 0;
}
function Ua(e, t, s, n) {
  let i;
  try {
    i = cu(e);
  } catch (c) {
    return e.error(c.message, t, s);
  }
  if (!i) return e.error("No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.", t, s);
  let o = s.resolvedImportSources[n];
  if (!o) {
    if (n.startsWith(".."))
      o = Rm(Wn(Do(s.filename), n), i);
    else {
      if (n[0] !== ".") return e.error("Type import from non-relative sources is not supported in the browser build.", t, s);
      o = Rm(Wn(Do(s.filename), n), i);
    }
    o && (o = s.resolvedImportSources[n] = Pb(o));
  }
  return o ? ((e.deps || (e.deps = /* @__PURE__ */ new Set())).add(o), Db(e, o)) : e.error(`Failed to resolve import source ${JSON.stringify(n)}.`, t, s);
}
function Rm(e, t) {
  const s = (n) => {
    if (t.fileExists(n)) return n;
  };
  return s(e = e.replace(/\.js$/, "")) || s(e + ".ts") || s(e + ".tsx") || s(e + ".d.ts") || s(Wn(e, "index.ts")) || s(Wn(e, "index.tsx")) || s(Wn(e, "index.d.ts"));
}
const Mm = Ph();
function Db(e, t, s = !1) {
  const n = Mm.get(t);
  if (n) return n;
  const i = cu(e), o = i.readFile(t) || "", c = (function(p, d, g, f) {
    const x = Nh(p);
    if (x === ".ts" || x === ".mts" || x === ".tsx" || x === ".mtsx") return ar.parse(d, { plugins: go(x.slice(1), f, /\.d\.m?ts$/.test(p)), sourceType: "module" }).program.body;
    const m = !/\.[cm]?[tj]sx?$/.test(p), y = `${p.slice(0, -x.length)}.d${x}.ts`;
    if (m && g.fileExists(y)) return ar.parse(g.readFile(y), { plugins: go("ts", f, !0), sourceType: "module" }).program.body;
    if (x === ".vue") {
      const { descriptor: { script: b, scriptSetup: E } } = Hy(d);
      if (!b && !E) return [];
      const w = b ? b.loc.start.offset : 1 / 0, C = E ? E.loc.start.offset : 1 / 0, A = w < C ? b : E, O = w < C ? E : b;
      let D = " ".repeat(Math.min(w, C)) + A.content;
      O && (D += " ".repeat(O.loc.start.offset - b.loc.end.offset) + O.content);
      const N = b?.lang || E?.lang;
      return ar.parse(D, { plugins: go(N, f), sourceType: "module" }).program.body;
    }
    return [];
  })(t, o, i, e.options.babelParserPlugins), l = new iu(t, o, 0, Fb(c));
  return pu(e, c, l, s), Mm.set(t, l), l;
}
function $a(e) {
  if (e.scope) return e.scope;
  const t = "ast" in e ? e.ast : e.scriptAst ? [...e.scriptAst.body, ...e.scriptSetupAst.body] : e.scriptSetupAst.body, s = new iu(e.filename, e.source, "startOffset" in e ? e.startOffset : 0, "userImports" in e ? Object.create(e.userImports) : Fb(t));
  return pu(e, t, s), e.scope = s;
}
function lu(e) {
  return new iu(e.filename, e.source, e.offset, Object.create(e.imports), Object.create(e.types), Object.create(e.declares));
}
const yw = /^Import|^Export/;
function pu(e, t, s, n = !1) {
  const { types: i, declares: o, exportedTypes: c, exportedDeclares: l, imports: p } = s, d = !!n && !t.some((g) => yw.test(g.type));
  for (const g of t) if (n) {
    if (d) g.declare && $r(g, i, o);
    else if (g.type === "TSModuleDeclaration" && g.global) for (const f of g.body.body) f.type === "ExportNamedDeclaration" && f.declaration ? $r(f.declaration, i, o) : $r(f, i, o);
  } else $r(g, i, o);
  if (!n) for (const g of t) if (g.type === "ExportNamedDeclaration") {
    if (g.declaration) $r(g.declaration, i, o), $r(g.declaration, c, l);
    else for (const f of g.specifiers) if (f.type === "ExportSpecifier") {
      const x = f.local.name, m = Ps(f.exported);
      g.source ? (p[m] = { source: g.source.value, imported: x }, c[m] = { type: "TSTypeReference", typeName: { type: "Identifier", name: x }, _ownerScope: s }) : i[x] && (c[m] = i[x]);
    }
  } else if (g.type === "ExportAllDeclaration") {
    const f = Ua(e, g.source, s, g.source.value);
    Object.assign(s.exportedTypes, f.exportedTypes);
  } else g.type === "ExportDefaultDeclaration" && g.declaration && (g.declaration.type !== "Identifier" ? ($r(g.declaration, i, o, "default"), $r(g.declaration, c, l, "default")) : i[g.declaration.name] && (c.default = i[g.declaration.name]));
  for (const g of Object.keys(i)) {
    const f = i[g];
    f._ownerScope = s, f._ns && (f._ns._ownerScope = s);
  }
  for (const g of Object.keys(o)) o[g]._ownerScope = s;
}
function $r(e, t, s, n) {
  switch (e.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const i = n || Ps(e.id);
      let o = t[i];
      if (o) {
        if (e.type === "TSModuleDeclaration") {
          o.type === "TSModuleDeclaration" ? hu(o, e) : Dm(o, e);
          break;
        }
        if (o.type === "TSModuleDeclaration") {
          t[i] = e, Dm(e, o);
          break;
        }
        if (o.type !== e.type) break;
        e.type === "TSInterfaceDeclaration" ? o.body.body.push(...e.body.body) : o.members.push(...e.members);
      } else t[i] = e;
      break;
    }
    case "ClassDeclaration":
      (n || e.id) && (t[n || Ps(e.id)] = e);
      break;
    case "TSTypeAliasDeclaration":
      t[e.id.name] = e.typeParameters ? e : e.typeAnnotation;
      break;
    case "TSDeclareFunction":
      e.id && (s[e.id.name] = e);
      break;
    case "VariableDeclaration":
      if (e.declare) for (const i of e.declarations) i.id.type === "Identifier" && i.id.typeAnnotation && (s[i.id.name] = i.id.typeAnnotation.typeAnnotation);
  }
}
function hu(e, t) {
  const s = e.body, n = t.body;
  s.type === "TSModuleDeclaration" ? n.type === "TSModuleDeclaration" ? hu(s, n) : n.body.push({ type: "ExportNamedDeclaration", declaration: s, exportKind: "type", specifiers: [] }) : n.type === "TSModuleDeclaration" ? s.body.push({ type: "ExportNamedDeclaration", declaration: n, exportKind: "type", specifiers: [] }) : s.body.push(...n.body);
}
function Dm(e, t) {
  e._ns ? hu(e._ns, t) : e._ns = t;
}
function Fb(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const s of e) xw(s, t);
  return t;
}
function xw(e, t) {
  if (e.type === "ImportDeclaration") for (const s of e.specifiers) t[s.local.name] = { imported: yp(s), source: e.source.value };
}
function pt(e, t, s = t._ownerScope || $a(e), n = !1, i) {
  if (t.leadingComments && t.leadingComments.some((o) => o.value.includes("@vue-ignore"))) return [Jt];
  try {
    switch (t.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const o = /* @__PURE__ */ new Set(), c = t.type === "TSTypeLiteral" ? t.members : t.body.body;
        for (const l of c) if (n) if (l.type === "TSPropertySignature" && l.key.type === "NumericLiteral") o.add("Number");
        else if (l.type === "TSIndexSignature") {
          const p = l.parameters[0].typeAnnotation;
          if (p && p.type !== "Noop") {
            const d = pt(e, p.typeAnnotation, s)[0];
            if (d === Jt) return [Jt];
            o.add(d);
          }
        } else o.add("String");
        else l.type === "TSCallSignatureDeclaration" || l.type === "TSConstructSignatureDeclaration" ? o.add("Function") : o.add("Object");
        return o.size ? Array.from(o) : [n ? Jt : "Object"];
      }
      case "TSPropertySignature":
        if (t.typeAnnotation) return pt(e, t.typeAnnotation.typeAnnotation, s);
        break;
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (t.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [Jt];
        }
      case "TSTypeReference": {
        const o = Tr(e, t, s);
        if (o) {
          if (o.type === "TSTypeAliasDeclaration") {
            if (o.typeAnnotation.type === "TSFunctionType") return ["Function"];
            if (t.typeParameters) {
              const c = /* @__PURE__ */ Object.create(null);
              return o.typeParameters && o.typeParameters.params.forEach((l, p) => {
                c[l.name] = t.typeParameters.params[p];
              }), pt(e, o.typeAnnotation, o._ownerScope, n, c);
            }
          }
          return pt(e, o, o._ownerScope, n);
        }
        if (t.typeName.type === "Identifier") {
          if (i && i[t.typeName.name]) return pt(e, i[t.typeName.name], s, n, i);
          if (n) switch (t.typeName.name) {
            case "String":
            case "Array":
            case "ArrayLike":
            case "Parameters":
            case "ConstructorParameters":
            case "ReadonlyArray":
              return ["String", "Number"];
            case "Record":
            case "Partial":
            case "Required":
            case "Readonly":
              if (t.typeParameters && t.typeParameters.params[0]) return pt(e, t.typeParameters.params[0], s, !0);
              break;
            case "Pick":
            case "Extract":
              if (t.typeParameters && t.typeParameters.params[1]) return pt(e, t.typeParameters.params[1], s);
              break;
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
            case "Error":
            case "Uppercase":
            case "Lowercase":
            case "Capitalize":
            case "Uncapitalize":
            case "ReadonlyMap":
            case "ReadonlySet":
              return ["String"];
          }
          else switch (t.typeName.name) {
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
            case "Error":
              return [t.typeName.name];
            case "Partial":
            case "Required":
            case "Readonly":
            case "Record":
            case "Pick":
            case "Omit":
            case "InstanceType":
              return ["Object"];
            case "Uppercase":
            case "Lowercase":
            case "Capitalize":
            case "Uncapitalize":
              return ["String"];
            case "Parameters":
            case "ConstructorParameters":
            case "ReadonlyArray":
              return ["Array"];
            case "ReadonlyMap":
              return ["Map"];
            case "ReadonlySet":
              return ["Set"];
            case "NonNullable":
              if (t.typeParameters && t.typeParameters.params[0]) return pt(e, t.typeParameters.params[0], s).filter((c) => c !== "null");
              break;
            case "Extract":
              if (t.typeParameters && t.typeParameters.params[1]) return pt(e, t.typeParameters.params[1], s);
              break;
            case "Exclude":
            case "OmitThisParameter":
              if (t.typeParameters && t.typeParameters.params[0]) return pt(e, t.typeParameters.params[0], s);
          }
        }
        break;
      }
      case "TSParenthesizedType":
        return pt(e, t.typeAnnotation, s);
      case "TSUnionType":
        return Il(e, t.types, s, n, i);
      case "TSIntersectionType":
        return Il(e, t.types, s, n, i).filter((o) => o !== Jt);
      case "TSMappedType": {
        const { typeAnnotation: o, typeParameter: c } = t;
        if (o && o.type === "TSIndexedAccessType" && c && c.constraint && i) {
          const l = c.constraint;
          if (l.type === "TSTypeOperator" && l.operator === "keyof" && l.typeAnnotation && l.typeAnnotation.type === "TSTypeReference" && l.typeAnnotation.typeName.type === "Identifier") {
            const p = l.typeAnnotation.typeName.name, d = o.indexType, g = o.objectType;
            if (g && g.type === "TSTypeReference" && g.typeName.type === "Identifier" && g.typeName.name === p && d && d.type === "TSTypeReference" && d.typeName.type === "Identifier" && d.typeName.name === c.name) {
              const f = i[p];
              if (f) return pt(e, f, s);
            }
          }
        }
        return [Jt];
      }
      case "TSEnumDeclaration":
        return (function(o) {
          const c = /* @__PURE__ */ new Set();
          for (const l of o.members) if (l.initializer) switch (l.initializer.type) {
            case "StringLiteral":
              c.add("String");
              break;
            case "NumericLiteral":
              c.add("Number");
          }
          return c.size ? [...c] : ["Number"];
        })(t);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType":
        return Il(e, Lb(e, t, s), s, n);
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const o = Ua(e, t.argument, s, t.argument.value), c = Tr(e, t, o);
        if (c) return pt(e, c, c._ownerScope);
        break;
      }
      case "TSTypeQuery": {
        const o = t.exprName;
        if (o.type === "Identifier") {
          const c = s.declares[o.name];
          if (c) return pt(e, c, c._ownerScope, n);
        }
        break;
      }
      case "TSTypeOperator":
        return pt(e, t.typeAnnotation, s, t.operator === "keyof");
      case "TSAnyKeyword":
        if (n) return ["String", "Number", "Symbol"];
    }
  } catch {
  }
  return [Jt];
}
function Il(e, t, s, n = !1, i = void 0) {
  return t.length === 1 ? pt(e, t[0], s, n, i) : [...new Set([].concat(...t.map((o) => pt(e, o, s, n, i))))];
}
function Fm({ props: e }, t) {
  const s = { props: {} };
  for (const n in e) {
    const i = e[n];
    s.props[n] = vp(i.key, i.typeAnnotation.typeAnnotation, t);
  }
  return s;
}
function vp(e, t, s, n = !0, i = !0) {
  if (i && t.type === "TSTypeLiteral") {
    const o = jm(t, "type");
    if (o) {
      const c = jm(t, "required");
      return vp(e, o, s, !c || c.type !== "TSLiteralType" || c.literal.type !== "BooleanLiteral" || !c.literal.value, !1);
    }
  } else if (t.type === "TSTypeReference" && t.typeName.type === "Identifier") {
    if (t.typeName.name.endsWith("Constructor")) return Gn(e, (function(o) {
      const c = o.slice(0, -11);
      switch (c) {
        case "String":
        case "Number":
        case "Boolean":
          return { type: `TS${c}Keyword` };
        case "Array":
        case "Function":
        case "Object":
        case "Set":
        case "Map":
        case "WeakSet":
        case "WeakMap":
        case "Date":
        case "Promise":
          return { type: "TSTypeReference", typeName: { type: "Identifier", name: c } };
      }
      return { type: "TSNullKeyword" };
    })(t.typeName.name), s, n);
    if (t.typeName.name === "PropType" && t.typeParameters) return Gn(e, t.typeParameters.params[0], s, n);
  }
  if ((t.type === "TSTypeReference" || t.type === "TSImportType") && t.typeParameters) for (const o of t.typeParameters.params) {
    const c = vp(e, o, s, n);
    if (c) return c;
  }
  return Gn(e, { type: "TSNullKeyword" }, s, n);
}
function jm(e, t) {
  const s = e.members.find((n) => n.type === "TSPropertySignature" && !n.computed && Ps(n.key) === t && n.typeAnnotation);
  return s && s.typeAnnotation.typeAnnotation;
}
function jb(e, t, s) {
  if (t.type === "TSTypeReference") {
    const i = Tr(e, t, s);
    i && (t = i);
  }
  let n;
  return n = t.type === "TSUnionType" ? t.types.flatMap((i) => jb(e, i, s)) : [t], n;
}
const qa = "defineModel";
function Bm(e, t, s) {
  if (!Ot(t, qa)) return !1;
  e.hasDefineModelCall = !0;
  const n = t.typeParameters && t.typeParameters.params[0] || void 0;
  let i, o;
  const c = t.arguments[0] && Gt(t.arguments[0]), l = c && c.type === "StringLiteral";
  l ? (i = c.value, o = t.arguments[1]) : (i = "modelValue", o = c), e.modelDecls[i] && e.error(`duplicate model name ${JSON.stringify(i)}`, t);
  let p = o && e.getString(o), d = !o;
  const g = [];
  if (o && o.type === "ObjectExpression" && !o.properties.some((f) => f.type === "SpreadElement" || f.computed)) {
    let f = 0;
    for (let x = o.properties.length - 1; x >= 0; x--) {
      const m = o.properties[x], y = o.properties[x + 1], v = m.start, b = y ? y.start : o.end - 1;
      m.type !== "ObjectProperty" && m.type !== "ObjectMethod" || (m.key.type !== "Identifier" || m.key.name !== "get" && m.key.name !== "set") && (m.key.type !== "StringLiteral" || m.key.value !== "get" && m.key.value !== "set") ? (f++, e.s.remove(e.startOffset + v, e.startOffset + b), g.push(m)) : p = p.slice(0, v - o.start) + p.slice(b - o.start);
    }
    f === o.properties.length && (d = !0, e.s.remove(e.startOffset + (l ? c.end : o.start), e.startOffset + o.end));
  }
  return e.modelDecls[i] = { type: n, options: p, runtimeOptionNodes: g, identifier: s && s.type === "Identifier" ? s.name : void 0 }, e.bindingMetadata[i] = "props", e.s.overwrite(e.startOffset + t.callee.start, e.startOffset + t.callee.end, e.helper("useModel")), e.s.appendLeft(e.startOffset + (t.arguments.length ? t.arguments[0].start : t.end - 1), "__props, " + (l ? "" : `${JSON.stringify(i)}${d ? "" : ", "}`)), !0;
}
const Tt = "defineProps", ms = "withDefaults";
function kp(e, t, s, n = !1) {
  if (!Ot(t, Tt)) return (function(i, o, c) {
    return Ot(o, ms) ? (kp(i, o.arguments[0], c, !0) || i.error(`${ms}' first argument must be a ${Tt} call.`, o.arguments[0] || o), i.propsRuntimeDecl && i.error(`${ms} can only be used with type-based ${Tt} declaration.`, o), c && c.type === "ObjectPattern" && i.warn(`${ms}() is unnecessary when using destructure with ${Tt}().
Reactive destructure will be disabled when using withDefaults().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...). `, o.callee), i.propsRuntimeDefaults = o.arguments[1], i.propsRuntimeDefaults || i.error(`The 2nd argument of ${ms} is required.`, o), i.propsCall = o, !0) : !1;
  })(e, t, s);
  if (e.hasDefinePropsCall && e.error(`duplicate ${Tt}() call`, t), e.hasDefinePropsCall = !0, e.propsRuntimeDecl = t.arguments[0], e.propsRuntimeDecl) for (const i of bp(e.propsRuntimeDecl)) i in e.bindingMetadata || (e.bindingMetadata[i] = "props");
  return t.typeParameters && (e.propsRuntimeDecl && e.error(`${Tt}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t), e.propsTypeDecl = t.typeParameters.params[0]), !n && s && s.type === "ObjectPattern" && (function(i, o) {
    if (i.options.propsDestructure === "error") i.error("Props destructure is explicitly prohibited via config.", o);
    else if (i.options.propsDestructure === !1) return;
    i.propsDestructureDecl = o;
    const c = (l, p, d) => {
      i.propsDestructuredBindings[l] = { local: p, default: d }, p !== l && (i.bindingMetadata[p] = "props-aliased", (i.bindingMetadata.__propsAliases || (i.bindingMetadata.__propsAliases = {}))[p] = l);
    };
    for (const l of o.properties) if (l.type === "ObjectProperty") {
      const p = nu(l.key, l.computed);
      if (p || i.error(`${Tt}() destructure cannot use computed key.`, l.key), l.value.type === "AssignmentPattern") {
        const { left: d, right: g } = l.value;
        d.type !== "Identifier" && i.error(`${Tt}() destructure does not support nested patterns.`, d), c(p, d.name, g);
      } else l.value.type === "Identifier" ? c(p, l.value.name) : i.error(`${Tt}() destructure does not support nested patterns.`, l.value);
    } else i.propsDestructureRestId = l.argument.name, i.bindingMetadata[i.propsDestructureRestId] = "setup-reactive-const";
  })(e, s), e.propsCall = t, e.propsDecl = s, !0;
}
function bw(e) {
  let t;
  if (e.propsRuntimeDecl) {
    if (t = e.getString(e.propsRuntimeDecl).trim(), e.propsDestructureDecl) {
      const n = [];
      for (const i in e.propsDestructuredBindings) {
        const o = Bb(e, i), c = Ab(i);
        o && n.push(`${c}: ${o.valueString}${o.needSkipFactory ? `, __skip_${c}: true` : ""}`);
      }
      n.length && (t = `/*@__PURE__*/${e.helper("mergeDefaults")}(${t}, {
  ${n.join(`,
  `)}
})`);
    }
  } else e.propsTypeDecl && (t = (function(n) {
    const i = (function(p, d) {
      const g = [], f = wt(p, d);
      for (const x in f.props) {
        const m = f.props[x];
        let y = pt(p, m), v = !1;
        y.includes(Jt) && (y.includes("Boolean") || y.includes("Function") ? (y = y.filter((b) => b !== Jt), v = !0) : y = ["null"]), g.push({ key: x, required: !m.optional, type: y || ["null"], skipCheck: v });
      }
      return g;
    })(n, n.propsTypeDecl);
    if (!i.length) return;
    const o = [], c = (function(p) {
      return !(!p.propsRuntimeDefaults || p.propsRuntimeDefaults.type !== "ObjectExpression" || !p.propsRuntimeDefaults.properties.every((d) => d.type !== "SpreadElement" && (!d.computed || d.key.type.endsWith("Literal"))));
    })(n);
    for (const p of i) o.push(Tw(n, p, c)), "bindingMetadata" in n && !(p.key in n.bindingMetadata) && (n.bindingMetadata[p.key] = "props");
    let l = `{
    ${o.join(`,
    `)}
  }`;
    return n.propsRuntimeDefaults && !c && (l = `/*@__PURE__*/${n.helper("mergeDefaults")}(${l}, ${n.getString(n.propsRuntimeDefaults)})`), l;
  })(e));
  const s = (function(n) {
    if (!n.hasDefineModelCall) return;
    const i = !!n.options.isProd;
    let o = "";
    for (const [c, { type: l, options: p }] of Object.entries(n.modelDecls)) {
      let d, g = !1, f = "", x = l && pt(n, l);
      if (x) {
        const m = x.includes("Boolean"), y = x.includes("Function");
        x.includes(Jt) && (m || y ? (x = x.filter((v) => v !== Jt), g = !0) : x = ["null"]), i ? (m || p && y) && (f = `type: ${Ks(x)}`) : f = `type: ${Ks(x)}` + (g ? ", skipCheck: true" : "");
      }
      d = f && p ? n.isTS ? `{ ${f}, ...${p} }` : `Object.assign({ ${f} }, ${p})` : f ? `{ ${f} }` : p || "{}", o += `
    ${JSON.stringify(c)}: ${d},`, o += `
    ${JSON.stringify(c === "modelValue" ? "modelModifiers" : `${c}Modifiers`)}: {},`;
    }
    return `{${o}
  }`;
  })(e);
  return t && s ? `/*@__PURE__*/${e.helper("mergeModels")}(${t}, ${s})` : s || t;
}
function Tw(e, { key: t, required: s, type: n, skipCheck: i }, o) {
  let c;
  const l = Bb(e, t, n);
  if (l) c = `default: ${l.valueString}${l.needSkipFactory ? ", skipFactory: true" : ""}`;
  else if (o) {
    const d = e.propsRuntimeDefaults.properties.find((g) => g.type !== "SpreadElement" && nu(g.key, g.computed) === t);
    d && (c = d.type === "ObjectProperty" ? `default: ${e.getString(d.value)}` : `${d.async ? "async " : ""}${d.kind !== "method" ? `${d.kind} ` : ""}default() ${e.getString(d.body)}`);
  }
  const p = Ab(t);
  return e.options.isProd ? n.some((d) => d === "Boolean" || (!o || c) && d === "Function") ? `${p}: { ${vm([`type: ${Ks(n)}`, c])} }` : e.isCE ? c ? `${p}: { ${c}, type: ${Ks(n)} }` : `${p}: {type: ${Ks(n)}}` : `${p}: ${c ? `{ ${c} }` : "{}"}` : `${p}: { ${vm([`type: ${Ks(n)}`, `required: ${s}`, i && "skipCheck: true", c])} }`;
}
function Bb(e, t, s) {
  const n = e.propsDestructuredBindings[t], i = n && n.default;
  if (i) {
    const o = e.getString(i), c = Gt(i);
    if (s && s.length && !s.includes("null")) {
      const p = (function(d) {
        switch (d.type) {
          case "StringLiteral":
            return "String";
          case "NumericLiteral":
            return "Number";
          case "BooleanLiteral":
            return "Boolean";
          case "ObjectExpression":
            return "Object";
          case "ArrayExpression":
            return "Array";
          case "FunctionExpression":
          case "ArrowFunctionExpression":
            return "Function";
        }
      })(c);
      p && !s.includes(p) && e.error(`Default value of prop "${t}" does not match declared type.`, c);
    }
    const l = !s && (Wr(c) || c.type === "Identifier");
    return { valueString: !l && !_b(c) && !s?.includes("Function") ? `() => (${o})` : o, needSkipFactory: l };
  }
}
function vw(e, t) {
  if (e.options.propsDestructure === !1) return;
  const s = /* @__PURE__ */ Object.create(null), n = [s];
  let i = s;
  const o = /* @__PURE__ */ new WeakSet(), c = [], l = /* @__PURE__ */ Object.create(null);
  for (const y in e.propsDestructuredBindings) {
    const { local: v } = e.propsDestructuredBindings[y];
    s[v] = !0, l[v] = y;
  }
  function p() {
    n.push(i = Object.create(i));
  }
  function d(y) {
    o.add(y), i ? i[y.name] = !1 : e.error("registerBinding called without active scope, something is wrong.", y);
  }
  function g(y, v = !1) {
    for (const b of y.body) if (b.type === "VariableDeclaration") f(b, v);
    else if (b.type === "FunctionDeclaration" || b.type === "ClassDeclaration") {
      if (b.declare || !b.id) continue;
      d(b.id);
    } else b.type !== "ForOfStatement" && b.type !== "ForInStatement" || b.left.type !== "VariableDeclaration" ? b.type === "ExportNamedDeclaration" && b.declaration && b.declaration.type === "VariableDeclaration" ? f(b.declaration, v) : b.type === "LabeledStatement" && b.body.type === "VariableDeclaration" && f(b.body, v) : f(b.left);
  }
  function f(y, v = !1) {
    if (!y.declare) for (const b of y.declarations) {
      const E = v && b.init && Ot(Gt(b.init), "defineProps");
      for (const w of Yt(b.id)) E ? o.add(w) : d(w);
    }
  }
  function x(y, v, b = v) {
    if (Ot(y, b)) {
      const E = Gt(y.arguments[0]);
      E.type === "Identifier" && i[E.name] && e.error(`"${E.name}" is a destructured prop and should not be passed directly to ${v}(). Pass a getter () => ${E.name} instead.`, E);
    }
  }
  const m = e.scriptSetupAst;
  g(m, !0), Yp(m, { enter(y, v) {
    return v && c.push(v), v && v.type.startsWith("TS") && !ka.includes(v.type) ? this.skip() : (x(y, "watch", t.watch), x(y, "toRef", t.toRef), Wr(y) ? (p(), Zp(y, d), void (y.body.type === "BlockStatement" && g(y.body))) : y.type === "CatchClause" ? (p(), y.param && y.param.type === "Identifier" && d(y.param), void g(y.body)) : y.type !== "BlockStatement" || Wr(v) ? void (y.type === "Identifier" && Qp(y, v, c) && !o.has(y) && i[y.name] && (function(b, E, w) {
      (E.type === "AssignmentExpression" && b === E.left || E.type === "UpdateExpression") && e.error("Cannot assign to destructured props as they are readonly.", b), va(E) && E.shorthand ? E.inPattern && !ri(E, w) || e.s.appendLeft(b.end + e.startOffset, `: ${So(l[b.name])}`) : e.s.overwrite(b.start + e.startOffset, b.end + e.startOffset, So(l[b.name]));
    })(y, v, c)) : (p(), void g(y)));
  }, leave(y, v) {
    v && c.pop(), (y.type === "BlockStatement" && !Wr(v) || Wr(y) || y.type === "CatchClause") && (n.pop(), i = n[n.length - 1] || null);
  } });
}
const ks = "defineEmits";
function Um(e, t, s) {
  return !!Ot(t, ks) && (e.hasDefineEmitCall && e.error(`duplicate ${ks}() call`, t), e.hasDefineEmitCall = !0, e.emitsRuntimeDecl = t.arguments[0], t.typeParameters && (e.emitsRuntimeDecl && e.error(`${ks}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t), e.emitsTypeDecl = t.typeParameters.params[0]), e.emitDecl = s, !0);
}
function kw(e) {
  let t = "";
  if (e.emitsRuntimeDecl) t = e.getString(e.emitsRuntimeDecl).trim();
  else if (e.emitsTypeDecl) {
    const s = (function(n) {
      const i = /* @__PURE__ */ new Set(), o = n.emitsTypeDecl;
      if (o.type === "TSFunctionType") return $m(n, o.parameters[0], i), i;
      const { props: c, calls: l } = wt(n, o);
      let p = !1;
      for (const d in c) i.add(d), p = !0;
      if (l) {
        p && n.error("defineEmits() type cannot mixed call signature and property syntax.", o);
        for (const d of l) $m(n, d.parameters[0], i);
      }
      return i;
    })(e);
    t = s.size ? `[${Array.from(s).map((n) => JSON.stringify(n)).join(", ")}]` : "";
  }
  if (e.hasDefineModelCall) {
    let s = `[${Object.keys(e.modelDecls).map((n) => JSON.stringify(`update:${n}`)).join(", ")}]`;
    t = t ? `/*@__PURE__*/${e.helper("mergeModels")}(${t}, ${s})` : s;
  }
  return t;
}
function $m(e, t, s) {
  if (t.type === "Identifier" && t.typeAnnotation && t.typeAnnotation.type === "TSTypeAnnotation") {
    const n = jb(e, t.typeAnnotation.typeAnnotation);
    for (const i of n) i.type === "TSLiteralType" && i.literal.type !== "UnaryExpression" && i.literal.type !== "TemplateLiteral" && s.add(String(i.literal.value));
  }
}
const Xo = "defineExpose";
function Sw(e, t) {
  return !!Ot(t, Xo) && (e.hasDefineExposeCall && e.error(`duplicate ${Xo}() call`, t), e.hasDefineExposeCall = !0, !0);
}
const en = "defineSlots";
function qm(e, t, s) {
  return !!Ot(t, en) && (e.hasDefineSlotsCall && e.error(`duplicate ${en}() call`, t), e.hasDefineSlotsCall = !0, t.arguments.length > 0 && e.error(`${en}() cannot accept arguments`, t), s && e.s.overwrite(e.startOffset + t.start, e.startOffset + t.end, `${e.helper("useSlots")}()`), !0);
}
const dr = "defineOptions";
function Vm(e, t) {
  if (!Ot(t, dr)) return !1;
  if (e.hasDefineOptionsCall && e.error(`duplicate ${dr}() call`, t), t.typeParameters && e.error(`${dr}() cannot accept type arguments`, t), !t.arguments[0]) return !0;
  let s, n, i, o;
  if (e.hasDefineOptionsCall = !0, e.optionsRuntimeDecl = Gt(t.arguments[0]), e.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const c of e.optionsRuntimeDecl.properties) if ((c.type === "ObjectProperty" || c.type === "ObjectMethod") && c.key.type === "Identifier") switch (c.key.name) {
      case "props":
        s = c;
        break;
      case "emits":
        n = c;
        break;
      case "expose":
        i = c;
        break;
      case "slots":
        o = c;
    }
  }
  return s && e.error(`${dr}() cannot be used to declare props. Use ${Tt}() instead.`, s), n && e.error(`${dr}() cannot be used to declare emits. Use ${ks}() instead.`, n), i && e.error(`${dr}() cannot be used to declare expose. Use ${Xo}() instead.`, i), o && e.error(`${dr}() cannot be used to declare slots. Use ${en}() instead.`, o), !0;
}
function Ew(e, t, s, n) {
  const i = t.argument.extra && t.argument.extra.parenthesized ? t.argument.extra.parenStart : t.argument.start, o = e.startOffset, c = e.descriptor.source.slice(i + o, t.argument.end + o), l = /\bawait\b/.test(c);
  e.s.overwrite(t.start + o, i + o, `${s ? ";" : ""}(
  ([__temp,__restore] = ${e.helper("withAsyncContext")}(${l ? "async " : ""}() => `), e.s.appendLeft(t.end + o, `)),
  ${n ? "" : "__temp = "}await __temp,
  __restore()${n ? "" : `,
  __temp`}
)`);
}
var ww = Object.defineProperty, _w = Object.defineProperties, Pw = Object.getOwnPropertyDescriptors, Hm = Object.getOwnPropertySymbols, Aw = Object.prototype.hasOwnProperty, Cw = Object.prototype.propertyIsEnumerable, zm = (e, t, s) => t in e ? ww(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, Nn = (e, t) => {
  for (var s in t || (t = {})) Aw.call(t, s) && zm(e, s, t[s]);
  if (Hm) for (var s of Hm(t)) Cw.call(t, s) && zm(e, s, t[s]);
  return e;
}, Nl = (e, t) => _w(e, Pw(t));
const Iw = [Tt, ks, Xo, dr, en, qa, ms];
function Nw(e, t) {
  var s, n, i;
  t.id || zn("compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals.");
  const { script: o, scriptSetup: c, source: l, filename: p } = e, d = t.hoistStatic !== !1 && !o, g = t.id ? t.id.replace(/^data-v-/, "") : "", f = o && o.lang, x = c && c.lang, m = Cb(f, x) || Ib(f, x);
  if (o && c && f !== x) throw new Error("[@vue/compiler-sfc] <script> and <script setup> must have the same language type.");
  if (!c) {
    if (!o) throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
    return o.lang && !m ? o : pw(new _m(e, t), g);
  }
  if (x && !m) return c;
  const y = new _m(e, t), v = /* @__PURE__ */ Object.create(null), b = /* @__PURE__ */ Object.create(null);
  let E, w = !1, C = !1;
  const A = y.startOffset, O = y.endOffset, D = o && o.loc.start.offset, N = o && o.loc.end.offset;
  function j(z) {
    const ie = z.start + A;
    let ae = z.end + A;
    for (z.trailingComments && z.trailingComments.length > 0 && (ae = z.trailingComments[z.trailingComments.length - 1].end + A); ae <= l.length && /\s/.test(l.charAt(ae)); ) ae++;
    y.s.move(ie, ae, 0);
  }
  function U(z, ie, ae, ge, Ee, fe) {
    let me = fe;
    fe && y.isTS && e.template && !e.template.src && !e.template.lang && (me = qy(ie, e)), y.userImports[ie] = { isType: ge, imported: ae, local: ie, source: z, isFromSetup: Ee, isUsedInTemplate: me };
  }
  function X(z, ie) {
    z && Ta(z, (ae) => {
      const ge = b[ae.name];
      ge && ge !== "literal-const" && y.error(`\`${ie}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`, ae);
    });
  }
  const W = y.scriptAst, H = y.scriptSetupAst;
  if (W) {
    for (const z of W.body) if (z.type === "ImportDeclaration") for (const ie of z.specifiers) {
      const ae = yp(ie);
      U(z.source.value, ie.local.name, ae, z.importKind === "type" || ie.type === "ImportSpecifier" && ie.importKind === "type", !1, !t.inlineTemplate);
    }
  }
  for (const z of H.body) if (z.type === "ImportDeclaration") {
    j(z);
    let ie = 0;
    const ae = (ge) => {
      const Ee = ge > ie;
      ie++;
      const fe = z.specifiers[ge], me = z.specifiers[ge + 1];
      y.s.remove(Ee ? z.specifiers[ge - 1].end + A : fe.start + A, me && !Ee ? me.start + A : fe.end + A);
    };
    for (let ge = 0; ge < z.specifiers.length; ge++) {
      const Ee = z.specifiers[ge], fe = Ee.local.name, me = yp(Ee), Oe = z.source.value, qe = y.userImports[fe];
      Oe === "vue" && Iw.includes(me) ? (fe === me ? zn(`\`${me}\` is a compiler macro and no longer needs to be imported.`) : y.error(`\`${me}\` is a compiler macro and cannot be aliased to a different name.`, Ee), ae(ge)) : qe ? qe.source === Oe && qe.imported === me ? ae(ge) : y.error("different imports aliased to same local name.", Ee) : U(Oe, fe, me, z.importKind === "type" || Ee.type === "ImportSpecifier" && Ee.importKind === "type", !0, !t.inlineTemplate);
    }
    z.specifiers.length && ie === z.specifiers.length && y.s.remove(z.start + A, z.end + A);
  }
  const F = {};
  for (const z in y.userImports) {
    const { source: ie, imported: ae, local: ge } = y.userImports[z];
    ie === "vue" && (F[ae] = ge);
  }
  if (o && W) {
    for (const z of W.body) if (z.type === "ExportDefaultDeclaration") {
      let ie;
      if (E = z, E.declaration.type === "ObjectExpression" ? ie = E.declaration.properties : E.declaration.type === "CallExpression" && E.declaration.arguments[0] && E.declaration.arguments[0].type === "ObjectExpression" && (ie = E.declaration.arguments[0].properties), ie) for (const Ee of ie) Ee.type === "ObjectProperty" && Ee.key.type === "Identifier" && Ee.key.name === "name" && (y.hasDefaultExportName = !0), Ee.type !== "ObjectMethod" && Ee.type !== "ObjectProperty" || Ee.key.type !== "Identifier" || Ee.key.name !== "render" || (y.hasDefaultExportRender = !0);
      const ae = z.start + D, ge = z.declaration.start + D;
      y.s.overwrite(ae, ge, `const ${Ws} = `);
    } else if (z.type === "ExportNamedDeclaration") {
      const ie = z.specifiers.find((ae) => ae.exported.type === "Identifier" && ae.exported.name === "default");
      ie && (E = z, z.specifiers.length > 1 ? y.s.remove(ie.start + D, ie.end + D) : y.s.remove(z.start + D, z.end + D), z.source ? y.s.prepend(`import { ${ie.local.name} as ${Ws} } from '${z.source.value}'
`) : y.s.appendLeft(N, `
const ${Ws} = ${ie.local.name}
`)), z.declaration && Ol("script", z.declaration, v, F, d);
    } else z.type !== "VariableDeclaration" && z.type !== "FunctionDeclaration" && z.type !== "ClassDeclaration" && z.type !== "TSEnumDeclaration" || z.declare || Ol("script", z, v, F, d);
    D > A && (/\n$/.test(o.content.trim()) || y.s.appendLeft(N, `
`), y.s.move(D, N, 0));
  }
  for (const z of H.body) {
    if (z.type === "ExpressionStatement") {
      const ae = Gt(z.expression);
      if (kp(y, ae) || Um(y, ae) || Vm(y, ae) || qm(y, ae)) y.s.remove(z.start + A, z.end + A);
      else if (Sw(y, ae)) {
        const ge = ae.callee;
        y.s.overwrite(ge.start + A, ge.end + A, "__expose");
      } else Bm(y, ae);
    }
    if (z.type === "VariableDeclaration" && !z.declare) {
      const ae = z.declarations.length;
      let ge, Ee = ae;
      for (let fe = 0; fe < ae; fe++) {
        const me = z.declarations[fe], Oe = me.init && Gt(me.init);
        if (Oe) {
          Vm(y, Oe) && y.error(`${dr}() has no returning value, it cannot be assigned.`, z);
          const qe = kp(y, Oe, me.id);
          y.propsDestructureRestId && (b[y.propsDestructureRestId] = "setup-reactive-const");
          const Me = !qe && Um(y, Oe, me.id);
          if (!Me && (qm(y, Oe, me.id) || Bm(y, Oe, me.id)), qe && !y.propsDestructureRestId && y.propsDestructureDecl) if (Ee === 1) y.s.remove(z.start + A, z.end + A);
          else {
            let at = me.start + A, St = me.end + A;
            fe === ae - 1 ? at = z.declarations[ge].end + A : St = z.declarations[fe + 1].start + A, y.s.remove(at, St), Ee--;
          }
          else Me ? y.s.overwrite(A + Oe.start, A + Oe.end, "__emit") : ge = fe;
        }
      }
    }
    let ie = !1;
    if (z.type !== "VariableDeclaration" && z.type !== "FunctionDeclaration" && z.type !== "ClassDeclaration" && z.type !== "TSEnumDeclaration" || z.declare || (ie = Ol("scriptSetup", z, b, F, d, !!y.propsDestructureDecl)), d && ie && j(z), z.type === "VariableDeclaration" && !z.declare || z.type.endsWith("Statement")) {
      const ae = [H.body];
      Yp(z, { enter(ge, Ee) {
        if (Wr(ge) && this.skip(), ge.type === "BlockStatement" && ae.push(ge.body), ge.type === "AwaitExpression") {
          w = !0;
          const fe = ae[ae.length - 1].some((me, Oe) => (ae.length === 1 || Oe > 0) && me.type === "ExpressionStatement" && me.start === ge.start);
          Ew(y, ge, fe, Ee.type === "ExpressionStatement");
        }
      }, exit(ge) {
        ge.type === "BlockStatement" && ae.pop();
      } });
    }
    (z.type === "ExportNamedDeclaration" && z.exportKind !== "type" || z.type === "ExportAllDeclaration" || z.type === "ExportDefaultDeclaration") && y.error("<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.", z), y.isTS && (z.type.startsWith("TS") || z.type === "ExportNamedDeclaration" && z.exportKind === "type" || z.type === "VariableDeclaration" && z.declare) && z.type !== "TSEnumDeclaration" && j(z);
  }
  y.propsDestructureDecl && vw(y, F), X(y.propsRuntimeDecl, Tt), X(y.propsRuntimeDefaults, Tt), X(y.propsDestructureDecl, Tt), X(y.emitsRuntimeDecl, ks), X(y.optionsRuntimeDecl, dr);
  for (const { runtimeOptionNodes: z } of Object.values(y.modelDecls)) for (const ie of z) X(ie, qa);
  o ? A < D ? (y.s.remove(0, A), y.s.remove(O, D), y.s.remove(N, l.length)) : (y.s.remove(0, D), y.s.remove(N, A), y.s.remove(O, l.length)) : (y.s.remove(0, A), y.s.remove(O, l.length)), W && Object.assign(y.bindingMetadata, Nb(W.body));
  for (const [z, { isType: ie, imported: ae, source: ge }] of Object.entries(y.userImports)) ie || (y.bindingMetadata[z] = ae === "*" || ae === "default" && ge.endsWith(".vue") || ge === "vue" ? "setup-const" : "setup-maybe-ref");
  for (const z in v) y.bindingMetadata[z] = v[z];
  for (const z in b) y.bindingMetadata[z] = b[z];
  e.cssVars.length && !((s = t.templateOptions) != null && s.ssr) && (y.helperImports.add(Ro), y.helperImports.add("unref"), y.s.prependLeft(A, `
${Dy(e.cssVars, y.bindingMetadata, g, !!t.isProd)}
`));
  let q = "__props";
  if (y.propsTypeDecl && (q += ": any"), y.propsDecl && (y.propsDestructureRestId ? (y.s.overwrite(A + y.propsCall.start, A + y.propsCall.end, `${y.helper("createPropsRestProxy")}(__props, ${JSON.stringify(Object.keys(y.propsDestructuredBindings))})`), y.s.overwrite(A + y.propsDestructureDecl.start, A + y.propsDestructureDecl.end, y.propsDestructureRestId)) : y.propsDestructureDecl || y.s.overwrite(A + y.propsCall.start, A + y.propsCall.end, "__props")), w) {
    const z = y.isTS ? ": any" : "";
    y.s.prependLeft(A, `
let __temp${z}, __restore${z}
`);
  }
  const G = y.hasDefineExposeCall || !t.inlineTemplate ? ["expose: __expose"] : [];
  let ee, ce;
  y.emitDecl && G.push("emit: __emit"), G.length && (q += `, { ${G.join(", ")} }`);
  const Te = bw(y);
  if (!t.inlineTemplate || !e.template && y.hasDefaultExportRender) {
    const z = Nn(Nn({}, v), b);
    for (const ie in y.userImports) !y.userImports[ie].isType && y.userImports[ie].isUsedInTemplate && (z[ie] = !0);
    ce = "{ ";
    for (const ie in z) if (z[ie] !== !0 || y.userImports[ie].source === "vue" || y.userImports[ie].source.endsWith(".vue")) if (y.bindingMetadata[ie] === "setup-let") {
      const ae = ie === "v" ? "_v" : "v";
      ce += `get ${ie}() { return ${ie} }, set ${ie}(${ae}) { ${ie} = ${ae} }, `;
    } else ce += `${ie}, `;
    else ce += `get ${ie}() { return ${ie} }, `;
    ce = ce.replace(/, $/, "") + " }";
  } else if (e.template && !e.template.src) {
    t.templateOptions && t.templateOptions.ssr && (C = !0);
    const { code: z, ast: ie, preamble: ae, tips: ge, errors: Ee, map: fe } = Xx(Nl(Nn({ filename: p, ast: e.template.ast, source: e.template.content, inMap: e.template.map }, t.templateOptions), { id: g, scoped: e.styles.some((Oe) => Oe.scoped), isProd: t.isProd, ssrCssVars: e.cssVars, compilerOptions: Nl(Nn({}, t.templateOptions && t.templateOptions.compilerOptions), { inline: !0, isTS: y.isTS, bindingMetadata: y.bindingMetadata }) }));
    ee = fe, ge.length && ge.forEach(zn);
    const me = Ee[0];
    if (typeof me == "string") throw new Error(me);
    if (me) throw me.loc && (me.message += `

` + e.filename + `
` + mi(l, me.loc.start.offset, me.loc.end.offset) + `
`), me;
    ae && y.s.prepend(ae), ie && ie.helpers.has(nn) && y.helperImports.delete("unref"), ce = z;
  } else ce = "() => {}";
  t.inlineTemplate ? y.s.appendRight(O, `
return ${ce}
}

`) : y.s.appendRight(O, `
const __returned__ = ${ce}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
  const Q = t.genDefaultAs ? `const ${t.genDefaultAs} =` : "export default";
  let pe = "";
  if (!y.hasDefaultExportName && p && p !== Vy) {
    const z = p.match(/([^/\\]+)\.\w+$/);
    z && (pe += `
  __name: '${z[1]}',`);
  }
  C && (pe += `
  __ssrInlineRender: true,`), Te && (pe += `
  props: ${Te},`);
  const J = kw(y);
  J && (pe += `
  emits: ${J},`);
  let $ = "";
  y.optionsRuntimeDecl && ($ = c.content.slice(y.optionsRuntimeDecl.start, y.optionsRuntimeDecl.end).trim());
  const oe = y.hasDefineExposeCall || t.inlineTemplate ? "" : `  __expose();
`;
  if (y.isTS) {
    const z = (E ? `
  ...${Ws},` : "") + ($ ? `
  ...${$},` : "");
    y.s.prependLeft(A, `
${Q} /*@__PURE__*/${y.helper("defineComponent")}({${z}${pe}
  ${w ? "async " : ""}setup(${q}) {
${oe}`), y.s.appendRight(O, "})");
  } else E || $ ? (y.s.prependLeft(A, `
${Q} /*@__PURE__*/Object.assign(${E ? `${Ws}, ` : ""}${$ ? `${$}, ` : ""}{${pe}
  ${w ? "async " : ""}setup(${q}) {
${oe}`), y.s.appendRight(O, "})")) : (y.s.prependLeft(A, `
${Q} {${pe}
  ${w ? "async " : ""}setup(${q}) {
${oe}`), y.s.appendRight(O, "}"));
  if (y.helperImports.size > 0) {
    const z = (i = (n = t.templateOptions) == null ? void 0 : n.compilerOptions) == null ? void 0 : i.runtimeModuleName, ie = z ? JSON.stringify(z) : "'vue'";
    y.s.prepend(`import { ${[...y.helperImports].map((ae) => `${ae} as _${ae}`).join(", ")} } from ${ie}
`);
  }
  const Y = y.s.toString();
  let se = t.sourceMap !== !1 ? y.s.generateMap({ source: p, hires: !0, includeContent: !0 }) : void 0;
  if (ee && se) {
    const z = Y.indexOf(ce);
    se = (function(ie, ae, ge) {
      const Ee = new vs.SourceMapGenerator(), fe = (me, Oe = 0) => {
        const qe = new vs.SourceMapConsumer(me);
        qe.sources.forEach((Me) => {
          Ee._sources.add(Me);
          const at = qe.sourceContentFor(Me);
          at != null && Ee.setSourceContent(Me, at);
        }), qe.eachMapping((Me) => {
          Me.originalLine != null && Ee.addMapping({ generated: { line: Me.generatedLine + Oe, column: Me.generatedColumn }, original: { line: Me.originalLine, column: Me.originalColumn }, source: Me.source, name: Me.name });
        });
      };
      return fe(ie), fe(ae, ge), Ee._sourceRoot = ie.sourceRoot, Ee._file = ie.file, Ee.toJSON();
    })(se, ee, Y.slice(0, z).split(/\r?\n/).length - 1);
  }
  return Nl(Nn({}, c), { bindings: y.bindingMetadata, imports: y.userImports, content: Y, map: se, scriptAst: W?.body, scriptSetupAst: H?.body, deps: y.deps ? [...y.deps] : void 0 });
}
function tn(e, t, s) {
  e[t.name] = s;
}
function Ol(e, t, s, n, i, o = !1) {
  let c = !1;
  if (t.type === "VariableDeclaration") {
    const l = t.kind === "const";
    c = l && t.declarations.every((p) => p.id.type === "Identifier" && sr(p.init));
    for (const { id: p, init: d } of t.declarations) {
      const g = d && Gt(d), f = l && Ot(g, (x) => x === Tt || x === ks || x === ms || x === en);
      if (p.type === "Identifier") {
        let x;
        const m = n.reactive;
        x = (i || e === "script") && (c || l && sr(g)) ? "literal-const" : Ot(g, m) ? l ? "setup-reactive-const" : "setup-let" : f || l && qb(g, m) ? Ot(g, Tt) ? "setup-reactive-const" : "setup-const" : l ? Ot(g, (y) => y === n.ref || y === n.computed || y === n.shallowRef || y === n.customRef || y === n.toRef || y === n.useTemplateRef || y === qa) ? "setup-ref" : "setup-maybe-ref" : "setup-let", tn(s, p, x);
      } else {
        if (Ot(g, Tt) && o) continue;
        p.type === "ObjectPattern" ? Ub(p, s, l, f) : p.type === "ArrayPattern" && $b(p, s, l, f);
      }
    }
  } else t.type === "TSEnumDeclaration" ? (c = t.members.every((l) => !l.initializer || sr(l.initializer)), s[t.id.name] = c ? "literal-const" : "setup-const") : t.type !== "FunctionDeclaration" && t.type !== "ClassDeclaration" || (s[t.id.name] = "setup-const");
  return c;
}
function Ub(e, t, s, n = !1) {
  for (const i of e.properties) if (i.type === "ObjectProperty") if (i.key.type === "Identifier" && i.key === i.value) {
    const o = n ? "setup-const" : s ? "setup-maybe-ref" : "setup-let";
    tn(t, i.key, o);
  } else uu(i.value, t, s, n);
  else {
    const o = s ? "setup-const" : "setup-let";
    tn(t, i.argument, o);
  }
}
function $b(e, t, s, n = !1) {
  for (const i of e.elements) i && uu(i, t, s, n);
}
function uu(e, t, s, n = !1) {
  if (e.type === "Identifier")
    tn(t, e, n ? "setup-const" : s ? "setup-maybe-ref" : "setup-let");
  else if (e.type === "RestElement") {
    const i = s ? "setup-const" : "setup-let";
    tn(t, e.argument, i);
  } else if (e.type === "ObjectPattern") Ub(e, t, s);
  else if (e.type === "ArrayPattern") $b(e, t, s);
  else if (e.type === "AssignmentPattern") if (e.left.type === "Identifier") {
    const i = n ? "setup-const" : s ? "setup-maybe-ref" : "setup-let";
    tn(t, e.left, i);
  } else uu(e.left, t, s);
}
function qb(e, t) {
  if (Ot(e, t)) return !0;
  switch (e.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return !0;
    case "SequenceExpression":
      return qb(e.expressions[e.expressions.length - 1], t);
    default:
      return !!_b(e);
  }
}
function sr(e) {
  switch ((e = Gt(e)).type) {
    case "UnaryExpression":
      return sr(e.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return sr(e.left) && sr(e.right);
    case "ConditionalExpression":
      return sr(e.test) && sr(e.consequent) && sr(e.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return e.expressions.every((t) => sr(t));
    case "ParenthesizedExpression":
      return sr(e.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return !0;
  }
  return !1;
}
var Ow = Object.defineProperty, Wm = Object.getOwnPropertySymbols, Lw = Object.prototype.hasOwnProperty, Rw = Object.prototype.propertyIsEnumerable, Gm = (e, t, s) => t in e ? Ow(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, Xm = (e, t) => {
  for (var s in t || (t = {})) Lw.call(t, s) && Gm(e, s, t[s]);
  if (Wm) for (var s of Wm(t)) Rw.call(t, s) && Gm(e, s, t[s]);
  return e;
};
Xm(Xm({}, Jp), _h), ar.parse;
const Mw = typeof window < "u" && typeof document < "u";
function Dw(e, t = !0, s) {
  AT() ? ET(e, s) : t ? e() : wT(e);
}
const Fw = Mw ? window.document : void 0;
let jw = 0;
function Bw(e, t = {}) {
  const s = i1(!1), { document: n = Fw, immediate: i = !0, manual: o = !1, id: c = "vueuse_styletag_" + ++jw } = t, l = i1(e);
  let p = () => {
  };
  const d = () => {
    if (!n) return;
    const x = n.getElementById(c) || n.createElement("style");
    x.isConnected || (x.id = c, t.nonce && (x.nonce = t.nonce), t.media && (x.media = t.media), n.head.appendChild(x)), s.value || (p = IT(l, (m) => {
      x.textContent = m;
    }, { immediate: !0 }), s.value = !0);
  }, g = () => {
    n && s.value && (p(), n.head.removeChild(n.getElementById(c)), s.value = !1);
  };
  var f;
  return i && !o && Dw(d), o || (f = g, _T() && PT(f)), { id: c, css: l, unload: g, load: d, isLoaded: CT(s) };
}
function Uw(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ll, Km, $w = (function() {
  if (Km) return Ll;
  function e(s, n) {
    var i, o;
    if (n.length === 0) return s;
    for (i = 0, o = n.length; i < o; i++) s = (s << 5) - s + n.charCodeAt(i), s |= 0;
    return s < 0 ? -2 * s : s;
  }
  function t(s, n, i, o) {
    var c, l = e(e(e(s, i), (c = n, Object.prototype.toString.call(c))), typeof n);
    if (n === null) return e(l, "null");
    if (n === void 0) return e(l, "undefined");
    if (typeof n == "object" || typeof n == "function") {
      if (o.indexOf(n) !== -1) return e(l, "[Circular]" + i);
      o.push(n);
      var p = (function(d, g, f) {
        return Object.keys(g).sort().reduce(function(x, m) {
          return t(x, g[m], m, f);
        }, d);
      })(l, n, o);
      if (!("valueOf" in n) || typeof n.valueOf != "function") return p;
      try {
        return e(p, String(n.valueOf()));
      } catch (d) {
        return e(p, "[valueOf exception]" + (d.stack || d.message));
      }
    }
    return e(l, n.toString());
  }
  return Km = 1, Ll = function(s) {
    return (function(n, i) {
      for (; n.length < i; ) n = "0" + n;
      return n;
    })(t(0, s, "", []).toString(16), 8);
  }, Ll;
})();
const qw = Uw($w);
var B, h, V;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e._abstract = 1] = "_abstract", e[e._accessor = 2] = "_accessor", e[e._as = 3] = "_as", e[e._assert = 4] = "_assert", e[e._asserts = 5] = "_asserts", e[e._async = 6] = "_async", e[e._await = 7] = "_await", e[e._checks = 8] = "_checks", e[e._constructor = 9] = "_constructor", e[e._declare = 10] = "_declare", e[e._enum = 11] = "_enum", e[e._exports = 12] = "_exports", e[e._from = 13] = "_from", e[e._get = 14] = "_get", e[e._global = 15] = "_global", e[e._implements = 16] = "_implements", e[e._infer = 17] = "_infer", e[e._interface = 18] = "_interface", e[e._is = 19] = "_is", e[e._keyof = 20] = "_keyof", e[e._mixins = 21] = "_mixins", e[e._module = 22] = "_module", e[e._namespace = 23] = "_namespace", e[e._of = 24] = "_of", e[e._opaque = 25] = "_opaque", e[e._out = 26] = "_out", e[e._override = 27] = "_override", e[e._private = 28] = "_private", e[e._protected = 29] = "_protected", e[e._proto = 30] = "_proto", e[e._public = 31] = "_public", e[e._readonly = 32] = "_readonly", e[e._require = 33] = "_require", e[e._satisfies = 34] = "_satisfies", e[e._set = 35] = "_set", e[e._static = 36] = "_static", e[e._symbol = 37] = "_symbol", e[e._type = 38] = "_type", e[e._unique = 39] = "_unique", e[e._using = 40] = "_using";
})(B || (B = {})), (function(e) {
  e[e.PRECEDENCE_MASK = 15] = "PRECEDENCE_MASK", e[e.IS_KEYWORD = 16] = "IS_KEYWORD", e[e.IS_ASSIGN = 32] = "IS_ASSIGN", e[e.IS_RIGHT_ASSOCIATIVE = 64] = "IS_RIGHT_ASSOCIATIVE", e[e.IS_PREFIX = 128] = "IS_PREFIX", e[e.IS_POSTFIX = 256] = "IS_POSTFIX", e[e.IS_EXPRESSION_START = 512] = "IS_EXPRESSION_START", e[e.num = 512] = "num", e[e.bigint = 1536] = "bigint", e[e.decimal = 2560] = "decimal", e[e.regexp = 3584] = "regexp", e[e.string = 4608] = "string", e[e.name = 5632] = "name", e[e.eof = 6144] = "eof", e[e.bracketL = 7680] = "bracketL", e[e.bracketR = 8192] = "bracketR", e[e.braceL = 9728] = "braceL", e[e.braceBarL = 10752] = "braceBarL", e[e.braceR = 11264] = "braceR", e[e.braceBarR = 12288] = "braceBarR", e[e.parenL = 13824] = "parenL", e[e.parenR = 14336] = "parenR", e[e.comma = 15360] = "comma", e[e.semi = 16384] = "semi", e[e.colon = 17408] = "colon", e[e.doubleColon = 18432] = "doubleColon", e[e.dot = 19456] = "dot", e[e.question = 20480] = "question", e[e.questionDot = 21504] = "questionDot", e[e.arrow = 22528] = "arrow", e[e.template = 23552] = "template", e[e.ellipsis = 24576] = "ellipsis", e[e.backQuote = 25600] = "backQuote", e[e.dollarBraceL = 27136] = "dollarBraceL", e[e.at = 27648] = "at", e[e.hash = 29184] = "hash", e[e.eq = 29728] = "eq", e[e.assign = 30752] = "assign", e[e.preIncDec = 32640] = "preIncDec", e[e.postIncDec = 33664] = "postIncDec", e[e.bang = 34432] = "bang", e[e.tilde = 35456] = "tilde", e[e.pipeline = 35841] = "pipeline", e[e.nullishCoalescing = 36866] = "nullishCoalescing", e[e.logicalOR = 37890] = "logicalOR", e[e.logicalAND = 38915] = "logicalAND", e[e.bitwiseOR = 39940] = "bitwiseOR", e[e.bitwiseXOR = 40965] = "bitwiseXOR", e[e.bitwiseAND = 41990] = "bitwiseAND", e[e.equality = 43015] = "equality", e[e.lessThan = 44040] = "lessThan", e[e.greaterThan = 45064] = "greaterThan", e[e.relationalOrEqual = 46088] = "relationalOrEqual", e[e.bitShiftL = 47113] = "bitShiftL", e[e.bitShiftR = 48137] = "bitShiftR", e[e.plus = 49802] = "plus", e[e.minus = 50826] = "minus", e[e.modulo = 51723] = "modulo", e[e.star = 52235] = "star", e[e.slash = 53259] = "slash", e[e.exponent = 54348] = "exponent", e[e.jsxName = 55296] = "jsxName", e[e.jsxText = 56320] = "jsxText", e[e.jsxEmptyText = 57344] = "jsxEmptyText", e[e.jsxTagStart = 58880] = "jsxTagStart", e[e.jsxTagEnd = 59392] = "jsxTagEnd", e[e.typeParameterStart = 60928] = "typeParameterStart", e[e.nonNullAssertion = 61440] = "nonNullAssertion", e[e._break = 62480] = "_break", e[e._case = 63504] = "_case", e[e._catch = 64528] = "_catch", e[e._continue = 65552] = "_continue", e[e._debugger = 66576] = "_debugger", e[e._default = 67600] = "_default", e[e._do = 68624] = "_do", e[e._else = 69648] = "_else", e[e._finally = 70672] = "_finally", e[e._for = 71696] = "_for", e[e._function = 73232] = "_function", e[e._if = 73744] = "_if", e[e._return = 74768] = "_return", e[e._switch = 75792] = "_switch", e[e._throw = 77456] = "_throw", e[e._try = 77840] = "_try", e[e._var = 78864] = "_var", e[e._let = 79888] = "_let", e[e._const = 80912] = "_const", e[e._while = 81936] = "_while", e[e._with = 82960] = "_with", e[e._new = 84496] = "_new", e[e._this = 85520] = "_this", e[e._super = 86544] = "_super", e[e._class = 87568] = "_class", e[e._extends = 88080] = "_extends", e[e._export = 89104] = "_export", e[e._import = 90640] = "_import", e[e._yield = 91664] = "_yield", e[e._null = 92688] = "_null", e[e._true = 93712] = "_true", e[e._false = 94736] = "_false", e[e._in = 95256] = "_in", e[e._instanceof = 96280] = "_instanceof", e[e._typeof = 97936] = "_typeof", e[e._void = 98960] = "_void", e[e._delete = 99984] = "_delete", e[e._async = 100880] = "_async", e[e._get = 101904] = "_get", e[e._set = 102928] = "_set", e[e._declare = 103952] = "_declare", e[e._readonly = 104976] = "_readonly", e[e._abstract = 106e3] = "_abstract", e[e._static = 107024] = "_static", e[e._public = 107536] = "_public", e[e._private = 108560] = "_private", e[e._protected = 109584] = "_protected", e[e._override = 110608] = "_override", e[e._as = 112144] = "_as", e[e._enum = 113168] = "_enum", e[e._type = 114192] = "_type", e[e._implements = 115216] = "_implements";
})(h || (h = {}));
class Er {
  constructor(t, s, n) {
    this.startTokenIndex = t, this.endTokenIndex = s, this.isFunctionScope = n;
  }
}
class Vw {
  constructor(t, s, n, i, o, c, l, p, d, g, f, x, m) {
    this.potentialArrowAt = t, this.noAnonFunctionType = s, this.inDisallowConditionalTypesContext = n, this.tokensLength = i, this.scopesLength = o, this.pos = c, this.type = l, this.contextualKeyword = p, this.start = d, this.end = g, this.isType = f, this.scopeDepth = x, this.error = m;
  }
}
class Nt {
  constructor() {
    Nt.prototype.__init.call(this), Nt.prototype.__init2.call(this), Nt.prototype.__init3.call(this), Nt.prototype.__init4.call(this), Nt.prototype.__init5.call(this), Nt.prototype.__init6.call(this), Nt.prototype.__init7.call(this), Nt.prototype.__init8.call(this), Nt.prototype.__init9.call(this), Nt.prototype.__init10.call(this), Nt.prototype.__init11.call(this), Nt.prototype.__init12.call(this), Nt.prototype.__init13.call(this);
  }
  __init() {
    this.potentialArrowAt = -1;
  }
  __init2() {
    this.noAnonFunctionType = !1;
  }
  __init3() {
    this.inDisallowConditionalTypesContext = !1;
  }
  __init4() {
    this.tokens = [];
  }
  __init5() {
    this.scopes = [];
  }
  __init6() {
    this.pos = 0;
  }
  __init7() {
    this.type = h.eof;
  }
  __init8() {
    this.contextualKeyword = B.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = !1;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new Vw(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
  }
  restoreFromSnapshot(t) {
    this.potentialArrowAt = t.potentialArrowAt, this.noAnonFunctionType = t.noAnonFunctionType, this.inDisallowConditionalTypesContext = t.inDisallowConditionalTypesContext, this.tokens.length = t.tokensLength, this.scopes.length = t.scopesLength, this.pos = t.pos, this.type = t.type, this.contextualKeyword = t.contextualKeyword, this.start = t.start, this.end = t.end, this.isType = t.isType, this.scopeDepth = t.scopeDepth, this.error = t.error;
  }
}
let Va, Le, je, k, he, Vb;
function li() {
  return Vb++;
}
function Hw(e) {
  if ("pos" in e) {
    const t = (function(s) {
      let n = 1, i = 1;
      for (let o = 0; o < s; o++) he.charCodeAt(o) === V.lineFeed ? (n++, i = 1) : i++;
      return new zw(n, i);
    })(e.pos);
    e.message += ` (${t.line}:${t.column})`, e.loc = t;
  }
  return e;
}
(function(e) {
  e[e.backSpace = 8] = "backSpace", e[e.lineFeed = 10] = "lineFeed", e[e.tab = 9] = "tab", e[e.carriageReturn = 13] = "carriageReturn", e[e.shiftOut = 14] = "shiftOut", e[e.space = 32] = "space", e[e.exclamationMark = 33] = "exclamationMark", e[e.quotationMark = 34] = "quotationMark", e[e.numberSign = 35] = "numberSign", e[e.dollarSign = 36] = "dollarSign", e[e.percentSign = 37] = "percentSign", e[e.ampersand = 38] = "ampersand", e[e.apostrophe = 39] = "apostrophe", e[e.leftParenthesis = 40] = "leftParenthesis", e[e.rightParenthesis = 41] = "rightParenthesis", e[e.asterisk = 42] = "asterisk", e[e.plusSign = 43] = "plusSign", e[e.comma = 44] = "comma", e[e.dash = 45] = "dash", e[e.dot = 46] = "dot", e[e.slash = 47] = "slash", e[e.digit0 = 48] = "digit0", e[e.digit1 = 49] = "digit1", e[e.digit2 = 50] = "digit2", e[e.digit3 = 51] = "digit3", e[e.digit4 = 52] = "digit4", e[e.digit5 = 53] = "digit5", e[e.digit6 = 54] = "digit6", e[e.digit7 = 55] = "digit7", e[e.digit8 = 56] = "digit8", e[e.digit9 = 57] = "digit9", e[e.colon = 58] = "colon", e[e.semicolon = 59] = "semicolon", e[e.lessThan = 60] = "lessThan", e[e.equalsTo = 61] = "equalsTo", e[e.greaterThan = 62] = "greaterThan", e[e.questionMark = 63] = "questionMark", e[e.atSign = 64] = "atSign", e[e.uppercaseA = 65] = "uppercaseA", e[e.uppercaseB = 66] = "uppercaseB", e[e.uppercaseC = 67] = "uppercaseC", e[e.uppercaseD = 68] = "uppercaseD", e[e.uppercaseE = 69] = "uppercaseE", e[e.uppercaseF = 70] = "uppercaseF", e[e.uppercaseG = 71] = "uppercaseG", e[e.uppercaseH = 72] = "uppercaseH", e[e.uppercaseI = 73] = "uppercaseI", e[e.uppercaseJ = 74] = "uppercaseJ", e[e.uppercaseK = 75] = "uppercaseK", e[e.uppercaseL = 76] = "uppercaseL", e[e.uppercaseM = 77] = "uppercaseM", e[e.uppercaseN = 78] = "uppercaseN", e[e.uppercaseO = 79] = "uppercaseO", e[e.uppercaseP = 80] = "uppercaseP", e[e.uppercaseQ = 81] = "uppercaseQ", e[e.uppercaseR = 82] = "uppercaseR", e[e.uppercaseS = 83] = "uppercaseS", e[e.uppercaseT = 84] = "uppercaseT", e[e.uppercaseU = 85] = "uppercaseU", e[e.uppercaseV = 86] = "uppercaseV", e[e.uppercaseW = 87] = "uppercaseW", e[e.uppercaseX = 88] = "uppercaseX", e[e.uppercaseY = 89] = "uppercaseY", e[e.uppercaseZ = 90] = "uppercaseZ", e[e.leftSquareBracket = 91] = "leftSquareBracket", e[e.backslash = 92] = "backslash", e[e.rightSquareBracket = 93] = "rightSquareBracket", e[e.caret = 94] = "caret", e[e.underscore = 95] = "underscore", e[e.graveAccent = 96] = "graveAccent", e[e.lowercaseA = 97] = "lowercaseA", e[e.lowercaseB = 98] = "lowercaseB", e[e.lowercaseC = 99] = "lowercaseC", e[e.lowercaseD = 100] = "lowercaseD", e[e.lowercaseE = 101] = "lowercaseE", e[e.lowercaseF = 102] = "lowercaseF", e[e.lowercaseG = 103] = "lowercaseG", e[e.lowercaseH = 104] = "lowercaseH", e[e.lowercaseI = 105] = "lowercaseI", e[e.lowercaseJ = 106] = "lowercaseJ", e[e.lowercaseK = 107] = "lowercaseK", e[e.lowercaseL = 108] = "lowercaseL", e[e.lowercaseM = 109] = "lowercaseM", e[e.lowercaseN = 110] = "lowercaseN", e[e.lowercaseO = 111] = "lowercaseO", e[e.lowercaseP = 112] = "lowercaseP", e[e.lowercaseQ = 113] = "lowercaseQ", e[e.lowercaseR = 114] = "lowercaseR", e[e.lowercaseS = 115] = "lowercaseS", e[e.lowercaseT = 116] = "lowercaseT", e[e.lowercaseU = 117] = "lowercaseU", e[e.lowercaseV = 118] = "lowercaseV", e[e.lowercaseW = 119] = "lowercaseW", e[e.lowercaseX = 120] = "lowercaseX", e[e.lowercaseY = 121] = "lowercaseY", e[e.lowercaseZ = 122] = "lowercaseZ", e[e.leftCurlyBrace = 123] = "leftCurlyBrace", e[e.verticalBar = 124] = "verticalBar", e[e.rightCurlyBrace = 125] = "rightCurlyBrace", e[e.tilde = 126] = "tilde", e[e.nonBreakingSpace = 160] = "nonBreakingSpace", e[e.oghamSpaceMark = 5760] = "oghamSpaceMark", e[e.lineSeparator = 8232] = "lineSeparator", e[e.paragraphSeparator = 8233] = "paragraphSeparator";
})(V || (V = {}));
class zw {
  constructor(t, s) {
    this.line = t, this.column = s;
  }
}
function Ww(e, t, s, n) {
  he = e, k = new Nt(), Vb = 1, Va = t, Le = s, je = n;
}
function be(e) {
  return k.contextualKeyword === e;
}
function du(e) {
  const t = _i();
  return t.type === h.name && t.contextualKeyword === e;
}
function lt(e) {
  return k.contextualKeyword === e && Z(h.name);
}
function st(e) {
  lt(e) || Ae();
}
function zt() {
  return L(h.eof) || L(h.braceR) || Lt();
}
function Lt() {
  const e = k.tokens[k.tokens.length - 1];
  for (let t = e ? e.end : 0; t < k.start; t++) {
    const s = he.charCodeAt(t);
    if (s === V.lineFeed || s === V.carriageReturn || s === 8232 || s === 8233) return !0;
  }
  return !1;
}
function Hb() {
  const e = fu();
  for (let t = k.end; t < e; t++) {
    const s = he.charCodeAt(t);
    if (s === V.lineFeed || s === V.carriageReturn || s === 8232 || s === 8233) return !0;
  }
  return !1;
}
function vr() {
  return Z(h.semi) || zt();
}
function Ke() {
  vr() || Ae('Unexpected token, expected ";"');
}
function te(e) {
  Z(e) || Ae(`Unexpected token, expected "${(function(t) {
    switch (t) {
      case h.num:
        return "num";
      case h.bigint:
        return "bigint";
      case h.decimal:
        return "decimal";
      case h.regexp:
        return "regexp";
      case h.string:
        return "string";
      case h.name:
        return "name";
      case h.eof:
        return "eof";
      case h.bracketL:
        return "[";
      case h.bracketR:
        return "]";
      case h.braceL:
        return "{";
      case h.braceBarL:
        return "{|";
      case h.braceR:
        return "}";
      case h.braceBarR:
        return "|}";
      case h.parenL:
        return "(";
      case h.parenR:
        return ")";
      case h.comma:
        return ",";
      case h.semi:
        return ";";
      case h.colon:
        return ":";
      case h.doubleColon:
        return "::";
      case h.dot:
        return ".";
      case h.question:
        return "?";
      case h.questionDot:
        return "?.";
      case h.arrow:
        return "=>";
      case h.template:
        return "template";
      case h.ellipsis:
        return "...";
      case h.backQuote:
        return "`";
      case h.dollarBraceL:
        return "${";
      case h.at:
        return "@";
      case h.hash:
        return "#";
      case h.eq:
        return "=";
      case h.assign:
        return "_=";
      case h.preIncDec:
      case h.postIncDec:
        return "++/--";
      case h.bang:
        return "!";
      case h.tilde:
        return "~";
      case h.pipeline:
        return "|>";
      case h.nullishCoalescing:
        return "??";
      case h.logicalOR:
        return "||";
      case h.logicalAND:
        return "&&";
      case h.bitwiseOR:
        return "|";
      case h.bitwiseXOR:
        return "^";
      case h.bitwiseAND:
        return "&";
      case h.equality:
        return "==/!=";
      case h.lessThan:
        return "<";
      case h.greaterThan:
        return ">";
      case h.relationalOrEqual:
        return "<=/>=";
      case h.bitShiftL:
        return "<<";
      case h.bitShiftR:
        return ">>/>>>";
      case h.plus:
        return "+";
      case h.minus:
        return "-";
      case h.modulo:
        return "%";
      case h.star:
        return "*";
      case h.slash:
        return "/";
      case h.exponent:
        return "**";
      case h.jsxName:
        return "jsxName";
      case h.jsxText:
        return "jsxText";
      case h.jsxEmptyText:
        return "jsxEmptyText";
      case h.jsxTagStart:
        return "jsxTagStart";
      case h.jsxTagEnd:
        return "jsxTagEnd";
      case h.typeParameterStart:
        return "typeParameterStart";
      case h.nonNullAssertion:
        return "nonNullAssertion";
      case h._break:
        return "break";
      case h._case:
        return "case";
      case h._catch:
        return "catch";
      case h._continue:
        return "continue";
      case h._debugger:
        return "debugger";
      case h._default:
        return "default";
      case h._do:
        return "do";
      case h._else:
        return "else";
      case h._finally:
        return "finally";
      case h._for:
        return "for";
      case h._function:
        return "function";
      case h._if:
        return "if";
      case h._return:
        return "return";
      case h._switch:
        return "switch";
      case h._throw:
        return "throw";
      case h._try:
        return "try";
      case h._var:
        return "var";
      case h._let:
        return "let";
      case h._const:
        return "const";
      case h._while:
        return "while";
      case h._with:
        return "with";
      case h._new:
        return "new";
      case h._this:
        return "this";
      case h._super:
        return "super";
      case h._class:
        return "class";
      case h._extends:
        return "extends";
      case h._export:
        return "export";
      case h._import:
        return "import";
      case h._yield:
        return "yield";
      case h._null:
        return "null";
      case h._true:
        return "true";
      case h._false:
        return "false";
      case h._in:
        return "in";
      case h._instanceof:
        return "instanceof";
      case h._typeof:
        return "typeof";
      case h._void:
        return "void";
      case h._delete:
        return "delete";
      case h._async:
        return "async";
      case h._get:
        return "get";
      case h._set:
        return "set";
      case h._declare:
        return "declare";
      case h._readonly:
        return "readonly";
      case h._abstract:
        return "abstract";
      case h._static:
        return "static";
      case h._public:
        return "public";
      case h._private:
        return "private";
      case h._protected:
        return "protected";
      case h._override:
        return "override";
      case h._as:
        return "as";
      case h._enum:
        return "enum";
      case h._type:
        return "type";
      case h._implements:
        return "implements";
      default:
        return "";
    }
  })(e)}"`);
}
function Ae(e = "Unexpected token", t = k.start) {
  if (k.error) return;
  const s = new SyntaxError(e);
  s.pos = t, k.error = s, k.pos = he.length, Ne(h.eof);
}
const zb = [9, 11, 12, V.space, V.nonBreakingSpace, V.oghamSpaceMark, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], Jm = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Wb = new Uint8Array(65536);
for (const e of zb) Wb[e] = 1;
function Gw(e) {
  if (e < 48) return e === 36;
  if (e < 58) return !0;
  if (e < 65) return !1;
  if (e < 91) return !0;
  if (e < 97) return e === 95;
  if (e < 123) return !0;
  if (e < 128) return !1;
  throw new Error("Should not be called with non-ASCII char code.");
}
const cr = new Uint8Array(65536);
for (let e = 0; e < 128; e++) cr[e] = Gw(e) ? 1 : 0;
for (let e = 128; e < 65536; e++) cr[e] = 1;
for (const e of zb) cr[e] = 0;
cr[8232] = 0, cr[8233] = 0;
const wi = cr.slice();
for (let e = V.digit0; e <= V.digit9; e++) wi[e] = 0;
const Ym = new Int32Array([-1, 27, 783, 918, 1755, 2376, 2862, 3483, -1, 3699, -1, 4617, 4752, 4833, 5130, 5508, 5940, -1, 6480, 6939, 7749, 8181, 8451, 8613, -1, 8829, -1, -1, -1, 54, 243, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, 675, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, B._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 270, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 405, -1, -1, -1, -1, -1, -1, -1, -1, B._accessor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 459, -1, -1, -1, -1, -1, 594, -1, -1, -1, -1, -1, -1, 486, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 513, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1, B._assert << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1, -1, B._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 729, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 756, -1, -1, -1, -1, -1, -1, B._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 837, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._break << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 945, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, 1242, -1, -1, 1350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 972, 1026, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._case << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1053, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._catch << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, -1, -1, -1, -1, -1, -1, -1, B._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1269, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1, 1 + (h._class << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, 1620, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1431, -1, -1, -1, -1, -1, -1, 1 + (h._const << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1, -1, -1, -1, 1512, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1566, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1, B._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._continue << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1782, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1809, 1971, -1, -1, 2106, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1917, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._debugger << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2025, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, -1, -1, -1, -1, -1, 1 + (h._default << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2295, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._delete << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._do << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, 2484, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2565, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._else << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2673, -1, -1, -1, -1, -1, -1, 1 + (h._export << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2700, -1, -1, -1, -1, -1, -1, -1, B._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1, 1 + (h._extends << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2889, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, 3159, -1, -1, 3213, -1, -1, 3294, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2970, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._false << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3024, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1, 1 + (h._finally << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._for << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3348, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._function << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3510, -1, -1, -1, -1, -1, -1, 3564, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1, B._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3618, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, 3753, 4077, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1, 1 + (h._if << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3807, -1, -1, 3996, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3888, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1, B._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4050, -1, -1, -1, -1, -1, -1, 1 + (h._import << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._in << 1), -1, -1, -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4185, 4401, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1, B._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4212, -1, -1, -1, -1, -1, -1, -1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._instanceof << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4428, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4482, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4563, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4644, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1, 1 + (h._let << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4941, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4968, -1, -1, -1, -1, -1, -1, -1, B._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5157, -1, -1, -1, 5373, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5319, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5400, -1, -1, -1, 1 + (h._new << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._null << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5535, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, 5697, 5751, -1, -1, -1, -1, B._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5589, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, -1, -1, -1, -1, B._out << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5778, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5805, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5913, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._override << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5967, -1, -1, 6345, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6021, -1, -1, -1, -1, -1, 6048, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6237, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6264, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6291, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6399, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6453, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6507, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6534, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6696, -1, -1, 6831, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6588, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6615, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1, B._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6723, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6777, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6912, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._return << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6966, -1, -1, -1, 7182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7236, 7371, -1, 7479, -1, 7614, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7020, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7155, -1, -1, -1, -1, -1, -1, -1, B._satisfies << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1, B._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7398, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7425, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7452, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._super << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7560, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7587, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._switch << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7722, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._symbol << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7938, -1, -1, -1, -1, -1, -1, 8046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1, 7857, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1, 1 + (h._this << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7911, -1, -1, -1, 1 + (h._throw << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, 8019, -1, -1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._true << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._try << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8073, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._typeof << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8208, -1, -1, -1, -1, 8343, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8289, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8316, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8370, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8397, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8424, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, B._using << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8478, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8532, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8505, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._var << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8559, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8586, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._void << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8640, 8748, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8667, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8694, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8721, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._while << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8775, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8802, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._with << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8856, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8883, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8910, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8937, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1 + (h._yield << 1), -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
var ke, ir;
function Gb(e) {
  const t = e.identifierRole;
  return t === ke.TopLevelDeclaration || t === ke.FunctionScopedDeclaration || t === ke.BlockScopedDeclaration || t === ke.ObjectShorthandTopLevelDeclaration || t === ke.ObjectShorthandFunctionScopedDeclaration || t === ke.ObjectShorthandBlockScopedDeclaration;
}
function Xw(e) {
  const t = e.identifierRole;
  return t === ke.FunctionScopedDeclaration || t === ke.BlockScopedDeclaration || t === ke.ObjectShorthandFunctionScopedDeclaration || t === ke.ObjectShorthandBlockScopedDeclaration;
}
function Xb(e) {
  const t = e.identifierRole;
  return t === ke.TopLevelDeclaration || t === ke.ObjectShorthandTopLevelDeclaration || t === ke.ImportDeclaration;
}
function Kw(e) {
  const t = e.identifierRole;
  return t === ke.TopLevelDeclaration || t === ke.BlockScopedDeclaration || t === ke.ObjectShorthandTopLevelDeclaration || t === ke.ObjectShorthandBlockScopedDeclaration;
}
function Jw(e) {
  const t = e.identifierRole;
  return t === ke.FunctionScopedDeclaration || t === ke.ObjectShorthandFunctionScopedDeclaration;
}
function Yw(e) {
  return e.identifierRole === ke.ObjectShorthandTopLevelDeclaration || e.identifierRole === ke.ObjectShorthandBlockScopedDeclaration || e.identifierRole === ke.ObjectShorthandFunctionScopedDeclaration;
}
(function(e) {
  e[e.Access = 0] = "Access", e[e.ExportAccess = 1] = "ExportAccess", e[e.TopLevelDeclaration = 2] = "TopLevelDeclaration", e[e.FunctionScopedDeclaration = 3] = "FunctionScopedDeclaration", e[e.BlockScopedDeclaration = 4] = "BlockScopedDeclaration", e[e.ObjectShorthandTopLevelDeclaration = 5] = "ObjectShorthandTopLevelDeclaration", e[e.ObjectShorthandFunctionScopedDeclaration = 6] = "ObjectShorthandFunctionScopedDeclaration", e[e.ObjectShorthandBlockScopedDeclaration = 7] = "ObjectShorthandBlockScopedDeclaration", e[e.ObjectShorthand = 8] = "ObjectShorthand", e[e.ImportDeclaration = 9] = "ImportDeclaration", e[e.ObjectKey = 10] = "ObjectKey", e[e.ImportAccess = 11] = "ImportAccess";
})(ke || (ke = {})), (function(e) {
  e[e.NoChildren = 0] = "NoChildren", e[e.OneChild = 1] = "OneChild", e[e.StaticChildren = 2] = "StaticChildren", e[e.KeyAfterPropSpread = 3] = "KeyAfterPropSpread";
})(ir || (ir = {}));
class Ha {
  constructor() {
    this.type = k.type, this.contextualKeyword = k.contextualKeyword, this.start = k.start, this.end = k.end, this.scopeDepth = k.scopeDepth, this.isType = k.isType, this.identifierRole = null, this.jsxRole = null, this.shadowsGlobal = !1, this.isAsyncOperation = !1, this.contextId = null, this.rhsEndIndex = null, this.isExpression = !1, this.numNullishCoalesceStarts = 0, this.numNullishCoalesceEnds = 0, this.isOptionalChainStart = !1, this.isOptionalChainEnd = !1, this.subscriptStartIndex = null, this.nullishStartIndex = null;
  }
}
function re() {
  k.tokens.push(new Ha()), Qb();
}
function Gr() {
  k.tokens.push(new Ha()), k.start = k.pos, (function() {
    for (; ; ) {
      if (k.pos >= he.length) return void Ae("Unterminated template");
      const e = he.charCodeAt(k.pos);
      if (e === V.graveAccent || e === V.dollarSign && he.charCodeAt(k.pos + 1) === V.leftCurlyBrace) return k.pos === k.start && L(h.template) ? e === V.dollarSign ? (k.pos += 2, void Ne(h.dollarBraceL)) : (++k.pos, void Ne(h.backQuote)) : void Ne(h.template);
      e === V.backslash && k.pos++, k.pos++;
    }
  })();
}
function Qw() {
  k.type === h.assign && --k.pos, (function() {
    const e = k.pos;
    let t = !1, s = !1;
    for (; ; ) {
      if (k.pos >= he.length) return void Ae("Unterminated regular expression", e);
      const n = he.charCodeAt(k.pos);
      if (t) t = !1;
      else {
        if (n === V.leftSquareBracket) s = !0;
        else if (n === V.rightSquareBracket && s) s = !1;
        else if (n === V.slash && !s) break;
        t = n === V.backslash;
      }
      ++k.pos;
    }
    ++k.pos, (function() {
      for (; k.pos < he.length; ) {
        const n = he.charCodeAt(k.pos);
        if (cr[n]) k.pos++;
        else {
          if (n !== V.backslash) break;
          if (k.pos += 2, he.charCodeAt(k.pos) === V.leftCurlyBrace) {
            for (; k.pos < he.length && he.charCodeAt(k.pos) !== V.rightCurlyBrace; ) k.pos++;
            k.pos++;
          }
        }
      }
    })(), Ne(h.regexp);
  })();
}
function Ie(e) {
  for (let s = k.tokens.length - e; s < k.tokens.length; s++) k.tokens[s].isType = !0;
  const t = k.isType;
  return k.isType = !0, t;
}
function Ce(e) {
  k.isType = e;
}
function Z(e) {
  return !!L(e) && (re(), !0);
}
function Kb(e) {
  const t = k.isType;
  k.isType = !0, Z(e), k.isType = t;
}
function L(e) {
  return k.type === e;
}
function Ze() {
  const e = k.snapshot();
  re();
  const t = k.type;
  return k.restoreFromSnapshot(e), t;
}
class Zw {
  constructor(t, s) {
    this.type = t, this.contextualKeyword = s;
  }
}
function _i() {
  const e = k.snapshot();
  re();
  const t = k.type, s = k.contextualKeyword;
  return k.restoreFromSnapshot(e), new Zw(t, s);
}
function fu() {
  return Jb(k.pos);
}
function Jb(e) {
  return Jm.lastIndex = e, e + Jm.exec(he)[0].length;
}
function Yb() {
  return he.charCodeAt(fu());
}
function Qb() {
  if (e0(), k.start = k.pos, k.pos >= he.length) {
    const t = k.tokens;
    return t.length >= 2 && t[t.length - 1].start >= he.length && t[t.length - 2].start >= he.length && Ae("Unexpectedly reached the end of input."), void Ne(h.eof);
  }
  var e;
  e = he.charCodeAt(k.pos), wi[e] || e === V.backslash || e === V.atSign && he.charCodeAt(k.pos + 1) === V.atSign ? (function() {
    let t = 0, s = 0, n = k.pos;
    for (; n < he.length && (s = he.charCodeAt(n), !(s < V.lowercaseA || s > V.lowercaseZ)); ) {
      const o = Ym[t + (s - V.lowercaseA) + 1];
      if (o === -1) break;
      t = o, n++;
    }
    const i = Ym[t];
    if (i > -1 && !cr[s]) return k.pos = n, void (1 & i ? Ne(i >>> 1) : Ne(h.name, i >>> 1));
    for (; n < he.length; ) {
      const o = he.charCodeAt(n);
      if (cr[o]) n++;
      else if (o === V.backslash) {
        if (n += 2, he.charCodeAt(n) === V.leftCurlyBrace) {
          for (; n < he.length && he.charCodeAt(n) !== V.rightCurlyBrace; ) n++;
          n++;
        }
      } else {
        if (o !== V.atSign || he.charCodeAt(n + 1) !== V.atSign) break;
        n += 2;
      }
    }
    k.pos = n, Ne(h.name);
  })() : s0(e);
}
function e_() {
  for (; he.charCodeAt(k.pos) !== V.asterisk || he.charCodeAt(k.pos + 1) !== V.slash; ) if (k.pos++, k.pos > he.length) return void Ae("Unterminated comment", k.pos - 2);
  k.pos += 2;
}
function Zb(e) {
  let t = he.charCodeAt(k.pos += e);
  if (k.pos < he.length) for (; t !== V.lineFeed && t !== V.carriageReturn && t !== V.lineSeparator && t !== V.paragraphSeparator && ++k.pos < he.length; ) t = he.charCodeAt(k.pos);
}
function e0() {
  for (; k.pos < he.length; ) {
    const e = he.charCodeAt(k.pos);
    switch (e) {
      case V.carriageReturn:
        he.charCodeAt(k.pos + 1) === V.lineFeed && ++k.pos;
      case V.lineFeed:
      case V.lineSeparator:
      case V.paragraphSeparator:
        ++k.pos;
        break;
      case V.slash:
        switch (he.charCodeAt(k.pos + 1)) {
          case V.asterisk:
            k.pos += 2, e_();
            break;
          case V.slash:
            Zb(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (!Wb[e]) return;
        ++k.pos;
    }
  }
}
function Ne(e, t = B.NONE) {
  k.end = k.pos, k.type = e, k.contextualKeyword = t;
}
function t0() {
  if (k.isType) return void Ue(h.greaterThan, 1);
  const e = he.charCodeAt(k.pos + 1);
  if (e === V.greaterThan) {
    const t = he.charCodeAt(k.pos + 2) === V.greaterThan ? 3 : 2;
    return he.charCodeAt(k.pos + t) === V.equalsTo ? void Ue(h.assign, t + 1) : void Ue(h.bitShiftR, t);
  }
  e === V.equalsTo ? Ue(h.relationalOrEqual, 2) : Ue(h.greaterThan, 1);
}
function r0() {
  k.type === h.greaterThan && (k.pos -= 1, t0());
}
function s0(e) {
  switch (e) {
    case V.numberSign:
      return ++k.pos, void Ne(h.hash);
    case V.dot:
      return void (function() {
        const t = he.charCodeAt(k.pos + 1);
        t >= V.digit0 && t <= V.digit9 ? Qm(!0) : t === V.dot && he.charCodeAt(k.pos + 2) === V.dot ? (k.pos += 3, Ne(h.ellipsis)) : (++k.pos, Ne(h.dot));
      })();
    case V.leftParenthesis:
      return ++k.pos, void Ne(h.parenL);
    case V.rightParenthesis:
      return ++k.pos, void Ne(h.parenR);
    case V.semicolon:
      return ++k.pos, void Ne(h.semi);
    case V.comma:
      return ++k.pos, void Ne(h.comma);
    case V.leftSquareBracket:
      return ++k.pos, void Ne(h.bracketL);
    case V.rightSquareBracket:
      return ++k.pos, void Ne(h.bracketR);
    case V.leftCurlyBrace:
      return void (je && he.charCodeAt(k.pos + 1) === V.verticalBar ? Ue(h.braceBarL, 2) : (++k.pos, Ne(h.braceL)));
    case V.rightCurlyBrace:
      return ++k.pos, void Ne(h.braceR);
    case V.colon:
      return void (he.charCodeAt(k.pos + 1) === V.colon ? Ue(h.doubleColon, 2) : (++k.pos, Ne(h.colon)));
    case V.questionMark:
      return void (function() {
        const t = he.charCodeAt(k.pos + 1), s = he.charCodeAt(k.pos + 2);
        t !== V.questionMark || je && k.isType ? t !== V.dot || s >= V.digit0 && s <= V.digit9 ? (++k.pos, Ne(h.question)) : (k.pos += 2, Ne(h.questionDot)) : s === V.equalsTo ? Ue(h.assign, 3) : Ue(h.nullishCoalescing, 2);
      })();
    case V.atSign:
      return ++k.pos, void Ne(h.at);
    case V.graveAccent:
      return ++k.pos, void Ne(h.backQuote);
    case V.digit0: {
      const t = he.charCodeAt(k.pos + 1);
      if (t === V.lowercaseX || t === V.uppercaseX || t === V.lowercaseO || t === V.uppercaseO || t === V.lowercaseB || t === V.uppercaseB) return void (function() {
        for (k.pos += 2; ; ) {
          const n = he.charCodeAt(k.pos);
          if (!(n >= V.digit0 && n <= V.digit9 || n >= V.lowercaseA && n <= V.lowercaseF || n >= V.uppercaseA && n <= V.uppercaseF || n === V.underscore)) break;
          k.pos++;
        }
        he.charCodeAt(k.pos) === V.lowercaseN ? (++k.pos, Ne(h.bigint)) : Ne(h.num);
      })();
    }
    case V.digit1:
    case V.digit2:
    case V.digit3:
    case V.digit4:
    case V.digit5:
    case V.digit6:
    case V.digit7:
    case V.digit8:
    case V.digit9:
      return void Qm(!1);
    case V.quotationMark:
    case V.apostrophe:
      return void (function(t) {
        for (k.pos++; ; ) {
          if (k.pos >= he.length) return void Ae("Unterminated string constant");
          const s = he.charCodeAt(k.pos);
          if (s === V.backslash) k.pos++;
          else if (s === t) break;
          k.pos++;
        }
        k.pos++, Ne(h.string);
      })(e);
    case V.slash:
      return void (he.charCodeAt(k.pos + 1) === V.equalsTo ? Ue(h.assign, 2) : Ue(h.slash, 1));
    case V.percentSign:
    case V.asterisk:
      return void (function(t) {
        let s = t === V.asterisk ? h.star : h.modulo, n = 1, i = he.charCodeAt(k.pos + 1);
        t === V.asterisk && i === V.asterisk && (n++, i = he.charCodeAt(k.pos + 2), s = h.exponent), i === V.equalsTo && he.charCodeAt(k.pos + 2) !== V.greaterThan && (n++, s = h.assign), Ue(s, n);
      })(e);
    case V.verticalBar:
    case V.ampersand:
      return void (function(t) {
        const s = he.charCodeAt(k.pos + 1);
        if (s !== t) {
          if (t === V.verticalBar) {
            if (s === V.greaterThan) return void Ue(h.pipeline, 2);
            if (s === V.rightCurlyBrace && je) return void Ue(h.braceBarR, 2);
          }
          s !== V.equalsTo ? Ue(t === V.verticalBar ? h.bitwiseOR : h.bitwiseAND, 1) : Ue(h.assign, 2);
        } else he.charCodeAt(k.pos + 2) === V.equalsTo ? Ue(h.assign, 3) : Ue(t === V.verticalBar ? h.logicalOR : h.logicalAND, 2);
      })(e);
    case V.caret:
      return void (he.charCodeAt(k.pos + 1) === V.equalsTo ? Ue(h.assign, 2) : Ue(h.bitwiseXOR, 1));
    case V.plusSign:
    case V.dash:
      return void (function(t) {
        const s = he.charCodeAt(k.pos + 1);
        s !== t ? s === V.equalsTo ? Ue(h.assign, 2) : t === V.plusSign ? Ue(h.plus, 1) : Ue(h.minus, 1) : Ue(h.preIncDec, 2);
      })(e);
    case V.lessThan:
      return void (function() {
        const t = he.charCodeAt(k.pos + 1);
        if (t === V.lessThan) return he.charCodeAt(k.pos + 2) === V.equalsTo ? void Ue(h.assign, 3) : void (k.isType ? Ue(h.lessThan, 1) : Ue(h.bitShiftL, 2));
        t === V.equalsTo ? Ue(h.relationalOrEqual, 2) : Ue(h.lessThan, 1);
      })();
    case V.greaterThan:
      return void t0();
    case V.equalsTo:
    case V.exclamationMark:
      return void (function(t) {
        const s = he.charCodeAt(k.pos + 1);
        if (s !== V.equalsTo) return t === V.equalsTo && s === V.greaterThan ? (k.pos += 2, void Ne(h.arrow)) : void Ue(t === V.equalsTo ? h.eq : h.bang, 1);
        Ue(h.equality, he.charCodeAt(k.pos + 2) === V.equalsTo ? 3 : 2);
      })(e);
    case V.tilde:
      return void Ue(h.tilde, 1);
  }
  Ae(`Unexpected character '${String.fromCharCode(e)}'`, k.pos);
}
function Ue(e, t) {
  k.pos += t, Ne(e);
}
function Rl() {
  for (; ; ) {
    const e = he.charCodeAt(k.pos);
    if (!(e >= V.digit0 && e <= V.digit9 || e === V.underscore)) break;
    k.pos++;
  }
}
function Qm(e) {
  let t = !1, s = !1;
  e || Rl();
  let n = he.charCodeAt(k.pos);
  n === V.dot && (++k.pos, Rl(), n = he.charCodeAt(k.pos)), n !== V.uppercaseE && n !== V.lowercaseE || (n = he.charCodeAt(++k.pos), n !== V.plusSign && n !== V.dash || ++k.pos, Rl(), n = he.charCodeAt(k.pos)), n === V.lowercaseN ? (++k.pos, t = !0) : n === V.lowercaseM && (++k.pos, s = !0), Ne(t ? h.bigint : s ? h.decimal : h.num);
}
function pi(e, t = e.currentIndex()) {
  let s = t + 1;
  if (Zi(e, s)) {
    const n = e.identifierNameAtIndex(t);
    return { isType: !1, leftName: n, rightName: n, endIndex: s };
  }
  if (s++, Zi(e, s)) return { isType: !0, leftName: null, rightName: null, endIndex: s };
  if (s++, Zi(e, s)) return { isType: !1, leftName: e.identifierNameAtIndex(t), rightName: e.identifierNameAtIndex(t + 2), endIndex: s };
  if (s++, Zi(e, s)) return { isType: !0, leftName: null, rightName: null, endIndex: s };
  throw new Error(`Unexpected import/export specifier at ${t}`);
}
function Zi(e, t) {
  const s = e.tokens[t];
  return s.type === h.braceR || s.type === h.comma;
}
const t_ = /* @__PURE__ */ new Map([["quot", '"'], ["amp", "&"], ["apos", "'"], ["lt", "<"], ["gt", ">"], ["nbsp", "Â "], ["iexcl", "Â¡"], ["cent", "Â¢"], ["pound", "Â£"], ["curren", "Â¤"], ["yen", "Â¥"], ["brvbar", "Â¦"], ["sect", "Â§"], ["uml", "Â¨"], ["copy", "Â©"], ["ordf", "Âª"], ["laquo", "Â«"], ["not", "Â¬"], ["shy", "Â­"], ["reg", "Â®"], ["macr", "Â¯"], ["deg", "Â°"], ["plusmn", "Â±"], ["sup2", "Â²"], ["sup3", "Â³"], ["acute", "Â´"], ["micro", "Âµ"], ["para", "Â¶"], ["middot", "Â·"], ["cedil", "Â¸"], ["sup1", "Â¹"], ["ordm", "Âº"], ["raquo", "Â»"], ["frac14", "Â¼"], ["frac12", "Â½"], ["frac34", "Â¾"], ["iquest", "Â¿"], ["Agrave", "Ã€"], ["Aacute", "Ã"], ["Acirc", "Ã‚"], ["Atilde", "Ãƒ"], ["Auml", "Ã„"], ["Aring", "Ã…"], ["AElig", "Ã†"], ["Ccedil", "Ã‡"], ["Egrave", "Ãˆ"], ["Eacute", "Ã‰"], ["Ecirc", "ÃŠ"], ["Euml", "Ã‹"], ["Igrave", "ÃŒ"], ["Iacute", "Ã"], ["Icirc", "Ã"], ["Iuml", "Ã"], ["ETH", "Ã"], ["Ntilde", "Ã‘"], ["Ograve", "Ã’"], ["Oacute", "Ã“"], ["Ocirc", "Ã”"], ["Otilde", "Ã•"], ["Ouml", "Ã–"], ["times", "Ã—"], ["Oslash", "Ã˜"], ["Ugrave", "Ã™"], ["Uacute", "Ãš"], ["Ucirc", "Ã›"], ["Uuml", "Ãœ"], ["Yacute", "Ã"], ["THORN", "Ã"], ["szlig", "ÃŸ"], ["agrave", "Ã "], ["aacute", "Ã¡"], ["acirc", "Ã¢"], ["atilde", "Ã£"], ["auml", "Ã¤"], ["aring", "Ã¥"], ["aelig", "Ã¦"], ["ccedil", "Ã§"], ["egrave", "Ã¨"], ["eacute", "Ã©"], ["ecirc", "Ãª"], ["euml", "Ã«"], ["igrave", "Ã¬"], ["iacute", "Ã­"], ["icirc", "Ã®"], ["iuml", "Ã¯"], ["eth", "Ã°"], ["ntilde", "Ã±"], ["ograve", "Ã²"], ["oacute", "Ã³"], ["ocirc", "Ã´"], ["otilde", "Ãµ"], ["ouml", "Ã¶"], ["divide", "Ã·"], ["oslash", "Ã¸"], ["ugrave", "Ã¹"], ["uacute", "Ãº"], ["ucirc", "Ã»"], ["uuml", "Ã¼"], ["yacute", "Ã½"], ["thorn", "Ã¾"], ["yuml", "Ã¿"], ["OElig", "Å’"], ["oelig", "Å“"], ["Scaron", "Å "], ["scaron", "Å¡"], ["Yuml", "Å¸"], ["fnof", "Æ’"], ["circ", "Ë†"], ["tilde", "Ëœ"], ["Alpha", "Î‘"], ["Beta", "Î’"], ["Gamma", "Î“"], ["Delta", "Î”"], ["Epsilon", "Î•"], ["Zeta", "Î–"], ["Eta", "Î—"], ["Theta", "Î˜"], ["Iota", "Î™"], ["Kappa", "Îš"], ["Lambda", "Î›"], ["Mu", "Îœ"], ["Nu", "Î"], ["Xi", "Î"], ["Omicron", "ÎŸ"], ["Pi", "Î "], ["Rho", "Î¡"], ["Sigma", "Î£"], ["Tau", "Î¤"], ["Upsilon", "Î¥"], ["Phi", "Î¦"], ["Chi", "Î§"], ["Psi", "Î¨"], ["Omega", "Î©"], ["alpha", "Î±"], ["beta", "Î²"], ["gamma", "Î³"], ["delta", "Î´"], ["epsilon", "Îµ"], ["zeta", "Î¶"], ["eta", "Î·"], ["theta", "Î¸"], ["iota", "Î¹"], ["kappa", "Îº"], ["lambda", "Î»"], ["mu", "Î¼"], ["nu", "Î½"], ["xi", "Î¾"], ["omicron", "Î¿"], ["pi", "Ï€"], ["rho", "Ï"], ["sigmaf", "Ï‚"], ["sigma", "Ïƒ"], ["tau", "Ï„"], ["upsilon", "Ï…"], ["phi", "Ï†"], ["chi", "Ï‡"], ["psi", "Ïˆ"], ["omega", "Ï‰"], ["thetasym", "Ï‘"], ["upsih", "Ï’"], ["piv", "Ï–"], ["ensp", "â€‚"], ["emsp", "â€ƒ"], ["thinsp", "â€‰"], ["zwnj", "â€Œ"], ["zwj", "â€"], ["lrm", "â€"], ["rlm", "â€"], ["ndash", "â€“"], ["mdash", "â€”"], ["lsquo", "â€˜"], ["rsquo", "â€™"], ["sbquo", "â€š"], ["ldquo", "â€œ"], ["rdquo", "â€"], ["bdquo", "â€"], ["dagger", "â€ "], ["Dagger", "â€¡"], ["bull", "â€¢"], ["hellip", "â€¦"], ["permil", "â€°"], ["prime", "â€²"], ["Prime", "â€³"], ["lsaquo", "â€¹"], ["rsaquo", "â€º"], ["oline", "â€¾"], ["frasl", "â„"], ["euro", "â‚¬"], ["image", "â„‘"], ["weierp", "â„˜"], ["real", "â„œ"], ["trade", "â„¢"], ["alefsym", "â„µ"], ["larr", "â†"], ["uarr", "â†‘"], ["rarr", "â†’"], ["darr", "â†“"], ["harr", "â†”"], ["crarr", "â†µ"], ["lArr", "â‡"], ["uArr", "â‡‘"], ["rArr", "â‡’"], ["dArr", "â‡“"], ["hArr", "â‡”"], ["forall", "âˆ€"], ["part", "âˆ‚"], ["exist", "âˆƒ"], ["empty", "âˆ…"], ["nabla", "âˆ‡"], ["isin", "âˆˆ"], ["notin", "âˆ‰"], ["ni", "âˆ‹"], ["prod", "âˆ"], ["sum", "âˆ‘"], ["minus", "âˆ’"], ["lowast", "âˆ—"], ["radic", "âˆš"], ["prop", "âˆ"], ["infin", "âˆ"], ["ang", "âˆ "], ["and", "âˆ§"], ["or", "âˆ¨"], ["cap", "âˆ©"], ["cup", "âˆª"], ["int", "âˆ«"], ["there4", "âˆ´"], ["sim", "âˆ¼"], ["cong", "â‰…"], ["asymp", "â‰ˆ"], ["ne", "â‰ "], ["equiv", "â‰¡"], ["le", "â‰¤"], ["ge", "â‰¥"], ["sub", "âŠ‚"], ["sup", "âŠƒ"], ["nsub", "âŠ„"], ["sube", "âŠ†"], ["supe", "âŠ‡"], ["oplus", "âŠ•"], ["otimes", "âŠ—"], ["perp", "âŠ¥"], ["sdot", "â‹…"], ["lceil", "âŒˆ"], ["rceil", "âŒ‰"], ["lfloor", "âŒŠ"], ["rfloor", "âŒ‹"], ["lang", "âŒ©"], ["rang", "âŒª"], ["loz", "â—Š"], ["spades", "â™ "], ["clubs", "â™£"], ["hearts", "â™¥"], ["diams", "â™¦"]]);
function n0(e) {
  const [t, s] = Zm(e.jsxPragma || "React.createElement"), [n, i] = Zm(e.jsxFragmentPragma || "React.Fragment");
  return { base: t, suffix: s, fragmentBase: n, fragmentSuffix: i };
}
function Zm(e) {
  let t = e.indexOf(".");
  return t === -1 && (t = e.length), [e.slice(0, t), e.slice(t)];
}
class lr {
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
}
class gs extends lr {
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  __init3() {
    this.filenameVarName = null;
  }
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(t, s, n, i, o) {
    super(), this.rootTransformer = t, this.tokens = s, this.importProcessor = n, this.nameManager = i, this.options = o, gs.prototype.__init.call(this), gs.prototype.__init2.call(this), gs.prototype.__init3.call(this), gs.prototype.__init4.call(this), gs.prototype.__init5.call(this), this.jsxPragmaInfo = n0(o), this.isAutomaticRuntime = o.jsxRuntime === "automatic", this.jsxImportSource = o.jsxImportSource || "react";
  }
  process() {
    return !!this.tokens.matches1(h.jsxTagStart) && (this.processJSXTag(), !0);
  }
  getPrefixCode() {
    let t = "";
    if (this.filenameVarName && (t += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`), this.isAutomaticRuntime) if (this.importProcessor) for (const [s, n] of Object.entries(this.cjsAutomaticModuleNameResolutions)) t += `var ${n} = require("${s}");`;
    else {
      const { createElement: s, ...n } = this.esmAutomaticImportNameResolutions;
      s && (t += `import {createElement as ${s}} from "${this.jsxImportSource}";`);
      const i = Object.entries(n).map(([o, c]) => `${o} as ${c}`).join(", ");
      i && (t += `import {${i}} from "${this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime")}";`);
    }
    return t;
  }
  processJSXTag() {
    const { jsxRole: t, start: s } = this.tokens.currentToken(), n = this.options.production ? null : this.getElementLocationCode(s);
    this.isAutomaticRuntime && t !== ir.KeyAfterPropSpread ? this.transformTagToJSXFunc(n, t) : this.transformTagToCreateElement(n);
  }
  getElementLocationCode(t) {
    return `lineNumber: ${this.getLineNumberForIndex(t)}`;
  }
  getLineNumberForIndex(t) {
    const s = this.tokens.code;
    for (; this.lastIndex < t && this.lastIndex < s.length; ) s[this.lastIndex] === `
` && this.lastLineNumber++, this.lastIndex++;
    return this.lastLineNumber;
  }
  transformTagToJSXFunc(t, s) {
    const n = s === ir.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(n));
    let i = null;
    if (this.tokens.matches1(h.jsxTagEnd)) this.tokens.replaceToken(`${this.getFragmentCode()}, {`), this.processAutomaticChildrenAndEndProps(s);
    else {
      if (this.processTagIntro(), this.tokens.appendCode(", {"), i = this.processProps(!0), this.tokens.matches2(h.slash, h.jsxTagEnd)) this.tokens.appendCode("}");
      else {
        if (!this.tokens.matches1(h.jsxTagEnd)) throw new Error("Expected either /> or > at the end of the tag.");
        this.tokens.removeToken(), this.processAutomaticChildrenAndEndProps(s);
      }
      i && this.tokens.appendCode(`, ${i}`);
    }
    for (this.options.production || (i === null && this.tokens.appendCode(", void 0"), this.tokens.appendCode(`, ${n}, ${this.getDevSource(t)}, this`)), this.tokens.removeInitialToken(); !this.tokens.matches1(h.jsxTagEnd); ) this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  transformTagToCreateElement(t) {
    if (this.tokens.replaceToken(this.getCreateElementInvocationCode()), this.tokens.matches1(h.jsxTagEnd)) this.tokens.replaceToken(`${this.getFragmentCode()}, null`), this.processChildren(!0);
    else if (this.processTagIntro(), this.processPropsObjectWithDevInfo(t), !this.tokens.matches2(h.slash, h.jsxTagEnd)) {
      if (!this.tokens.matches1(h.jsxTagEnd)) throw new Error("Expected either /> or > at the end of the tag.");
      this.tokens.removeToken(), this.processChildren(!0);
    }
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(h.jsxTagEnd); ) this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  getJSXFuncInvocationCode(t) {
    return this.options.production ? t ? this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
  }
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) return this.claimAutoImportedFuncInvocation("createElement", "");
    {
      const { jsxPragmaInfo: t } = this;
      return `${this.importProcessor && this.importProcessor.getIdentifierReplacement(t.base) || t.base}${t.suffix}(`;
    }
  }
  getFragmentCode() {
    if (this.isAutomaticRuntime) return this.claimAutoImportedName("Fragment", this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
    {
      const { jsxPragmaInfo: t } = this;
      return (this.importProcessor && this.importProcessor.getIdentifierReplacement(t.fragmentBase) || t.fragmentBase) + t.fragmentSuffix;
    }
  }
  claimAutoImportedFuncInvocation(t, s) {
    const n = this.claimAutoImportedName(t, s);
    return this.importProcessor ? `${n}.call(void 0, ` : `${n}(`;
  }
  claimAutoImportedName(t, s) {
    if (this.importProcessor) {
      const n = this.jsxImportSource + s;
      return this.cjsAutomaticModuleNameResolutions[n] || (this.cjsAutomaticModuleNameResolutions[n] = this.importProcessor.getFreeIdentifierForPath(n)), `${this.cjsAutomaticModuleNameResolutions[n]}.${t}`;
    }
    return this.esmAutomaticImportNameResolutions[t] || (this.esmAutomaticImportNameResolutions[t] = this.nameManager.claimFreeName(`_${t}`)), this.esmAutomaticImportNameResolutions[t];
  }
  processTagIntro() {
    let t = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[t].isType || !this.tokens.matches2AtIndex(t - 1, h.jsxName, h.jsxName) && !this.tokens.matches2AtIndex(t - 1, h.greaterThan, h.jsxName) && !this.tokens.matches1AtIndex(t, h.braceL) && !this.tokens.matches1AtIndex(t, h.jsxTagEnd) && !this.tokens.matches2AtIndex(t, h.slash, h.jsxTagEnd); ) t++;
    if (t === this.tokens.currentIndex() + 1) {
      const s = this.tokens.identifierName();
      i0(s) && this.tokens.replaceToken(`'${s}'`);
    }
    for (; this.tokens.currentIndex() < t; ) this.rootTransformer.processToken();
  }
  processPropsObjectWithDevInfo(t) {
    const s = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(t)}`;
    this.tokens.matches1(h.jsxName) || this.tokens.matches1(h.braceL) ? (this.tokens.appendCode(", {"), this.processProps(!1), s ? this.tokens.appendCode(` ${s}}`) : this.tokens.appendCode("}")) : s ? this.tokens.appendCode(`, {${s}}`) : this.tokens.appendCode(", null");
  }
  processProps(t) {
    let s = null;
    for (; ; ) {
      if (this.tokens.matches2(h.jsxName, h.eq)) {
        const n = this.tokens.identifierName();
        if (t && n === "key") {
          s !== null && this.tokens.appendCode(s.replace(/[^\n]/g, "")), this.tokens.removeToken(), this.tokens.removeToken();
          const i = this.tokens.snapshot();
          this.processPropValue(), s = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(i);
          continue;
        }
        this.processPropName(n), this.tokens.replaceToken(": "), this.processPropValue();
      } else if (this.tokens.matches1(h.jsxName)) {
        const n = this.tokens.identifierName();
        this.processPropName(n), this.tokens.appendCode(": true");
      } else {
        if (!this.tokens.matches1(h.braceL)) break;
        this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("");
      }
      this.tokens.appendCode(",");
    }
    return s;
  }
  processPropName(t) {
    t.includes("-") ? this.tokens.replaceToken(`'${t}'`) : this.tokens.copyToken();
  }
  processPropValue() {
    this.tokens.matches1(h.braceL) ? (this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("")) : this.tokens.matches1(h.jsxTagStart) ? this.processJSXTag() : this.processStringPropValue();
  }
  processStringPropValue() {
    const t = this.tokens.currentToken(), s = this.tokens.code.slice(t.start + 1, t.end - 1), n = eg(s), i = (function(o) {
      let c = "";
      for (let l = 0; l < o.length; l++) {
        const p = o[l];
        if (p === `
`) if (/\s/.test(o[l + 1])) for (c += " "; l < o.length && /\s/.test(o[l + 1]); ) l++;
        else c += `
`;
        else if (p === "&") {
          const { entity: d, newI: g } = tg(o, l + 1);
          c += d, l = g - 1;
        } else c += p;
      }
      return JSON.stringify(c);
    })(s);
    this.tokens.replaceToken(i + n);
  }
  processAutomaticChildrenAndEndProps(t) {
    t === ir.StaticChildren ? (this.tokens.appendCode(" children: ["), this.processChildren(!1), this.tokens.appendCode("]}")) : (t === ir.OneChild && this.tokens.appendCode(" children: "), this.processChildren(!1), this.tokens.appendCode("}"));
  }
  processChildren(t) {
    let s = t;
    for (; ; ) {
      if (this.tokens.matches2(h.jsxTagStart, h.slash)) return;
      let n = !1;
      if (this.tokens.matches1(h.braceL)) this.tokens.matches2(h.braceL, h.braceR) ? (this.tokens.replaceToken(""), this.tokens.replaceToken("")) : (this.tokens.replaceToken(s ? ", " : ""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken(""), n = !0);
      else if (this.tokens.matches1(h.jsxTagStart)) this.tokens.appendCode(s ? ", " : ""), this.processJSXTag(), n = !0;
      else {
        if (!this.tokens.matches1(h.jsxText) && !this.tokens.matches1(h.jsxEmptyText)) throw new Error("Unexpected token when processing JSX children.");
        n = this.processChildTextElement(s);
      }
      n && (s = !0);
    }
  }
  processChildTextElement(t) {
    const s = this.tokens.currentToken(), n = this.tokens.code.slice(s.start, s.end), i = eg(n), o = (function(c) {
      let l = "", p = "", d = !1, g = !1;
      for (let f = 0; f < c.length; f++) {
        const x = c[f];
        if (x === " " || x === "	" || x === "\r") d || (p += x);
        else if (x === `
`) p = "", d = !0;
        else {
          if (g && d && (l += " "), l += p, p = "", x === "&") {
            const { entity: m, newI: y } = tg(c, f + 1);
            f = y - 1, l += m;
          } else l += x;
          g = !0, d = !1;
        }
      }
      return d || (l += p), JSON.stringify(l);
    })(n);
    return o === '""' ? (this.tokens.replaceToken(i), !1) : (this.tokens.replaceToken(`${t ? ", " : ""}${o}${i}`), !0);
  }
  getDevSource(t) {
    return `{fileName: ${this.getFilenameVarName()}, ${t}}`;
  }
  getFilenameVarName() {
    return this.filenameVarName || (this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName")), this.filenameVarName;
  }
}
function i0(e) {
  const t = e.charCodeAt(0);
  return t >= V.lowercaseA && t <= V.lowercaseZ;
}
function eg(e) {
  let t = 0, s = 0;
  for (const n of e) n === `
` ? (t++, s = 0) : n === " " && s++;
  return `
`.repeat(t) + " ".repeat(s);
}
function tg(e, t) {
  let s, n = "", i = 0, o = t;
  if (e[o] === "#") {
    let c, l = 10;
    if (o++, e[o] === "x") for (l = 16, o++, c = o; o < e.length && s_(e.charCodeAt(o)); ) o++;
    else for (c = o; o < e.length && r_(e.charCodeAt(o)); ) o++;
    if (e[o] === ";") {
      const p = e.slice(c, o);
      p && (o++, s = String.fromCodePoint(parseInt(p, l)));
    }
  } else for (; o < e.length && i++ < 10; ) {
    const c = e[o];
    if (o++, c === ";") {
      s = t_.get(n);
      break;
    }
    n += c;
  }
  return s ? { entity: s, newI: o } : { entity: "&", newI: t };
}
function r_(e) {
  return e >= V.digit0 && e <= V.digit9;
}
function s_(e) {
  return e >= V.digit0 && e <= V.digit9 || e >= V.lowercaseA && e <= V.lowercaseF || e >= V.uppercaseA && e <= V.uppercaseF;
}
function o0(e, t) {
  const s = n0(t), n = /* @__PURE__ */ new Set();
  for (let i = 0; i < e.tokens.length; i++) {
    const o = e.tokens[i];
    o.type !== h.name || o.isType || o.identifierRole !== ke.Access && o.identifierRole !== ke.ObjectShorthand && o.identifierRole !== ke.ExportAccess || o.shadowsGlobal || n.add(e.identifierNameForToken(o)), o.type === h.jsxTagStart && n.add(s.base), o.type === h.jsxTagStart && i + 1 < e.tokens.length && e.tokens[i + 1].type === h.jsxTagEnd && (n.add(s.base), n.add(s.fragmentBase)), o.type === h.jsxName && o.identifierRole === ke.Access && (i0(e.identifierNameForToken(o)) && e.tokens[i + 1].type !== h.dot || n.add(e.identifierNameForToken(o)));
  }
  return n;
}
class ys {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(t, s, n, i, o, c, l) {
    this.nameManager = t, this.tokens = s, this.enableLegacyTypeScriptModuleInterop = n, this.options = i, this.isTypeScriptTransformEnabled = o, this.keepUnusedImports = c, this.helperManager = l, ys.prototype.__init.call(this), ys.prototype.__init2.call(this), ys.prototype.__init3.call(this), ys.prototype.__init4.call(this), ys.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let t = 0; t < this.tokens.tokens.length; t++) this.tokens.matches1AtIndex(t, h._import) && !this.tokens.matches3AtIndex(t, h._import, h.name, h.eq) && this.preprocessImportAtIndex(t), this.tokens.matches1AtIndex(t, h._export) && !this.tokens.matches2AtIndex(t, h._export, h.eq) && this.preprocessExportAtIndex(t);
    this.generateImportReplacements();
  }
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = o0(this.tokens, this.options);
    for (const [t, s] of this.importInfoByPath.entries())
      s.hasBareImport || s.hasStarExport || s.exportStarNames.length > 0 || s.namedExports.length > 0 || [...s.defaultNames, ...s.wildcardNames, ...s.namedImports.map(({ localName: n }) => n)].every((n) => this.shouldAutomaticallyElideImportedName(n)) && this.importsToReplace.set(t, "");
  }
  shouldAutomaticallyElideImportedName(t) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(t);
  }
  generateImportReplacements() {
    for (const [t, s] of this.importInfoByPath.entries()) {
      const { defaultNames: n, wildcardNames: i, namedImports: o, namedExports: c, exportStarNames: l, hasStarExport: p } = s;
      if (n.length === 0 && i.length === 0 && o.length === 0 && c.length === 0 && l.length === 0 && !p) {
        this.importsToReplace.set(t, `require('${t}');`);
        continue;
      }
      const d = this.getFreeIdentifierForPath(t);
      let g;
      g = this.enableLegacyTypeScriptModuleInterop ? d : i.length > 0 ? i[0] : this.getFreeIdentifierForPath(t);
      let f = `var ${d} = require('${t}');`;
      if (i.length > 0) for (const x of i)
        f += ` var ${x} = ${this.enableLegacyTypeScriptModuleInterop ? d : `${this.helperManager.getHelperName("interopRequireWildcard")}(${d})`};`;
      else l.length > 0 && g !== d ? f += ` var ${g} = ${this.helperManager.getHelperName("interopRequireWildcard")}(${d});` : n.length > 0 && g !== d && (f += ` var ${g} = ${this.helperManager.getHelperName("interopRequireDefault")}(${d});`);
      for (const { importedName: x, localName: m } of c) f += ` ${this.helperManager.getHelperName("createNamedExportFrom")}(${d}, '${m}', '${x}');`;
      for (const x of l) f += ` exports.${x} = ${g};`;
      p && (f += ` ${this.helperManager.getHelperName("createStarExport")}(${d});`), this.importsToReplace.set(t, f);
      for (const x of n) this.identifierReplacements.set(x, `${g}.default`);
      for (const { importedName: x, localName: m } of o) this.identifierReplacements.set(m, `${d}.${x}`);
    }
  }
  getFreeIdentifierForPath(t) {
    const s = t.split("/"), n = s[s.length - 1].replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${n}`);
  }
  preprocessImportAtIndex(t) {
    const s = [], n = [], i = [];
    if (t++, (this.tokens.matchesContextualAtIndex(t, B._type) || this.tokens.matches1AtIndex(t, h._typeof)) && !this.tokens.matches1AtIndex(t + 1, h.comma) && !this.tokens.matchesContextualAtIndex(t + 1, B._from) || this.tokens.matches1AtIndex(t, h.parenL)) return;
    if (this.tokens.matches1AtIndex(t, h.name) && (s.push(this.tokens.identifierNameAtIndex(t)), t++, this.tokens.matches1AtIndex(t, h.comma) && t++), this.tokens.matches1AtIndex(t, h.star) && (t += 2, n.push(this.tokens.identifierNameAtIndex(t)), t++), this.tokens.matches1AtIndex(t, h.braceL)) {
      const l = this.getNamedImports(t + 1);
      t = l.newIndex;
      for (const p of l.namedImports) p.importedName === "default" ? s.push(p.localName) : i.push(p);
    }
    if (this.tokens.matchesContextualAtIndex(t, B._from) && t++, !this.tokens.matches1AtIndex(t, h.string)) throw new Error("Expected string token at the end of import statement.");
    const o = this.tokens.stringValueAtIndex(t), c = this.getImportInfo(o);
    c.defaultNames.push(...s), c.wildcardNames.push(...n), c.namedImports.push(...i), s.length === 0 && n.length === 0 && i.length === 0 && (c.hasBareImport = !0);
  }
  preprocessExportAtIndex(t) {
    if (this.tokens.matches2AtIndex(t, h._export, h._var) || this.tokens.matches2AtIndex(t, h._export, h._let) || this.tokens.matches2AtIndex(t, h._export, h._const)) this.preprocessVarExportAtIndex(t);
    else if (this.tokens.matches2AtIndex(t, h._export, h._function) || this.tokens.matches2AtIndex(t, h._export, h._class)) {
      const s = this.tokens.identifierNameAtIndex(t + 2);
      this.addExportBinding(s, s);
    } else if (this.tokens.matches3AtIndex(t, h._export, h.name, h._function)) {
      const s = this.tokens.identifierNameAtIndex(t + 3);
      this.addExportBinding(s, s);
    } else this.tokens.matches2AtIndex(t, h._export, h.braceL) ? this.preprocessNamedExportAtIndex(t) : this.tokens.matches2AtIndex(t, h._export, h.star) && this.preprocessExportStarAtIndex(t);
  }
  preprocessVarExportAtIndex(t) {
    let s = 0;
    for (let n = t + 2; ; n++) if (this.tokens.matches1AtIndex(n, h.braceL) || this.tokens.matches1AtIndex(n, h.dollarBraceL) || this.tokens.matches1AtIndex(n, h.bracketL)) s++;
    else if (this.tokens.matches1AtIndex(n, h.braceR) || this.tokens.matches1AtIndex(n, h.bracketR)) s--;
    else {
      if (s === 0 && !this.tokens.matches1AtIndex(n, h.name)) break;
      if (this.tokens.matches1AtIndex(1, h.eq)) {
        const i = this.tokens.currentToken().rhsEndIndex;
        if (i == null) throw new Error("Expected = token with an end index.");
        n = i - 1;
      } else if (Gb(this.tokens.tokens[n])) {
        const i = this.tokens.identifierNameAtIndex(n);
        this.identifierReplacements.set(i, `exports.${i}`);
      }
    }
  }
  preprocessNamedExportAtIndex(t) {
    t += 2;
    const { newIndex: s, namedImports: n } = this.getNamedImports(t);
    if (t = s, !this.tokens.matchesContextualAtIndex(t, B._from)) {
      for (const { importedName: o, localName: c } of n) this.addExportBinding(o, c);
      return;
    }
    if (t++, !this.tokens.matches1AtIndex(t, h.string)) throw new Error("Expected string token at the end of import statement.");
    const i = this.tokens.stringValueAtIndex(t);
    this.getImportInfo(i).namedExports.push(...n);
  }
  preprocessExportStarAtIndex(t) {
    let s = null;
    if (this.tokens.matches3AtIndex(t, h._export, h.star, h._as) ? (t += 3, s = this.tokens.identifierNameAtIndex(t), t += 2) : t += 3, !this.tokens.matches1AtIndex(t, h.string)) throw new Error("Expected string token at the end of star export statement.");
    const n = this.tokens.stringValueAtIndex(t), i = this.getImportInfo(n);
    s !== null ? i.exportStarNames.push(s) : i.hasStarExport = !0;
  }
  getNamedImports(t) {
    const s = [];
    for (; ; ) {
      if (this.tokens.matches1AtIndex(t, h.braceR)) {
        t++;
        break;
      }
      const n = pi(this.tokens, t);
      if (t = n.endIndex, n.isType || s.push({ importedName: n.leftName, localName: n.rightName }), this.tokens.matches2AtIndex(t, h.comma, h.braceR)) {
        t += 2;
        break;
      }
      if (this.tokens.matches1AtIndex(t, h.braceR)) {
        t++;
        break;
      }
      if (!this.tokens.matches1AtIndex(t, h.comma)) throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[t])}`);
      t++;
    }
    return { newIndex: t, namedImports: s };
  }
  getImportInfo(t) {
    const s = this.importInfoByPath.get(t);
    if (s) return s;
    const n = { defaultNames: [], wildcardNames: [], namedImports: [], namedExports: [], hasBareImport: !1, exportStarNames: [], hasStarExport: !1 };
    return this.importInfoByPath.set(t, n), n;
  }
  addExportBinding(t, s) {
    this.exportBindingsByLocalName.has(t) || this.exportBindingsByLocalName.set(t, []), this.exportBindingsByLocalName.get(t).push(s);
  }
  claimImportCode(t) {
    const s = this.importsToReplace.get(t);
    return this.importsToReplace.set(t, ""), s || "";
  }
  getIdentifierReplacement(t) {
    return this.identifierReplacements.get(t) || null;
  }
  resolveExportBinding(t) {
    const s = this.exportBindingsByLocalName.get(t);
    return s && s.length !== 0 ? s.map((n) => `exports.${n}`).join(" = ") : null;
  }
  getGlobalNames() {
    return /* @__PURE__ */ new Set([...this.identifierReplacements.keys(), ...this.exportBindingsByLocalName.keys()]);
  }
}
var n_ = 44, i_ = 59, o_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a0 = new Uint8Array(64), a_ = new Uint8Array(128);
for (let e = 0; e < 64; e++) {
  const t = o_.charCodeAt(e);
  a0[e] = t, a_[t] = e;
}
function On(e, t, s) {
  let n = t - s;
  n = n < 0 ? -n << 1 | 1 : n << 1;
  do {
    let i = 31 & n;
    n >>>= 5, n > 0 && (i |= 32), e.write(a0[i]);
  } while (n > 0);
  return t;
}
var rg = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? { decode: (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString() } : { decode(e) {
  let t = "";
  for (let s = 0; s < e.length; s++) t += String.fromCharCode(e[s]);
  return t;
} }, c_ = class {
  constructor() {
    this.pos = 0, this.out = "", this.buffer = new Uint8Array(16384);
  }
  write(e) {
    const { buffer: t } = this;
    t[this.pos++] = e, this.pos === 16384 && (this.out += rg.decode(t), this.pos = 0);
  }
  flush() {
    const { buffer: e, out: t, pos: s } = this;
    return s > 0 ? t + rg.decode(e.subarray(0, s)) : t;
  }
};
function l_(e) {
  const t = new c_();
  let s = 0, n = 0, i = 0, o = 0;
  for (let c = 0; c < e.length; c++) {
    const l = e[c];
    if (c > 0 && t.write(i_), l.length === 0) continue;
    let p = 0;
    for (let d = 0; d < l.length; d++) {
      const g = l[d];
      d > 0 && t.write(n_), p = On(t, g[0], p), g.length !== 1 && (s = On(t, g[1], s), n = On(t, g[2], n), i = On(t, g[3], i), g.length !== 4 && (o = On(t, g[4], o)));
    }
  }
  return t.flush();
}
var sg, p_ = { exports: {} };
sg || (sg = 1, p_.exports = /* @__PURE__ */ (function() {
  const e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, s = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
  function n(b) {
    return e.test(b);
  }
  function i(b) {
    return b.startsWith("//");
  }
  function o(b) {
    return b.startsWith("/");
  }
  function c(b) {
    return b.startsWith("file:");
  }
  function l(b) {
    return /^[.?#]/.test(b);
  }
  function p(b) {
    const E = t.exec(b);
    return g(E[1], E[2] || "", E[3], E[4] || "", E[5] || "/", E[6] || "", E[7] || "");
  }
  function d(b) {
    const E = s.exec(b), w = E[2];
    return g("file:", "", E[1] || "", "", o(w) ? w : "/" + w, E[3] || "", E[4] || "");
  }
  function g(b, E, w, C, A, O, D) {
    return { scheme: b, user: E, host: w, port: C, path: A, query: O, hash: D, type: 7 };
  }
  function f(b) {
    if (i(b)) {
      const w = p("http:" + b);
      return w.scheme = "", w.type = 6, w;
    }
    if (o(b)) {
      const w = p("http://foo.com" + b);
      return w.scheme = "", w.host = "", w.type = 5, w;
    }
    if (c(b)) return d(b);
    if (n(b)) return p(b);
    const E = p("http://foo.com/" + b);
    return E.scheme = "", E.host = "", E.type = b ? b.startsWith("?") ? 3 : b.startsWith("#") ? 2 : 4 : 1, E;
  }
  function x(b) {
    if (b.endsWith("/..")) return b;
    const E = b.lastIndexOf("/");
    return b.slice(0, E + 1);
  }
  function m(b, E) {
    y(E, E.type), b.path === "/" ? b.path = E.path : b.path = x(E.path) + b.path;
  }
  function y(b, E) {
    const w = E <= 4, C = b.path.split("/");
    let A = 1, O = 0, D = !1;
    for (let j = 1; j < C.length; j++) {
      const U = C[j];
      U ? (D = !1, U !== "." && (U !== ".." ? (C[A++] = U, O++) : O ? (D = !0, O--, A--) : w && (C[A++] = U))) : D = !0;
    }
    let N = "";
    for (let j = 1; j < A; j++) N += "/" + C[j];
    (!N || D && !N.endsWith("/..")) && (N += "/"), b.path = N;
  }
  function v(b, E) {
    if (!b && !E) return "";
    const w = f(b);
    let C = w.type;
    if (E && C !== 7) {
      const O = f(E), D = O.type;
      switch (C) {
        case 1:
          w.hash = O.hash;
        case 2:
          w.query = O.query;
        case 3:
        case 4:
          m(w, O);
        case 5:
          w.user = O.user, w.host = O.host, w.port = O.port;
        case 6:
          w.scheme = O.scheme;
      }
      D > C && (C = D);
    }
    y(w, C);
    const A = w.query + w.hash;
    switch (C) {
      case 2:
      case 3:
        return A;
      case 4: {
        const O = w.path.slice(1);
        return O ? l(E || b) && !l(O) ? "./" + O + A : O + A : A || ".";
      }
      case 5:
        return w.path + A;
      default:
        return w.scheme + "//" + w.user + w.host + w.port + w.path + A;
    }
  }
  return v;
})());
var Ml = class {
  constructor() {
    this._indexes = { __proto__: null }, this.array = [];
  }
}, h_ = class {
  constructor({ file: e, sourceRoot: t } = {}) {
    this._names = new Ml(), this._sources = new Ml(), this._sourcesContent = [], this._mappings = [], this.file = e, this.sourceRoot = t, this._ignoreList = new Ml();
  }
}, Dl = (e, t, s, n, i, o, c, l) => (function(p, d, g, f, x, m, y) {
  const { _mappings: v, _sources: b, _sourcesContent: E, _names: w } = d, C = (function(N, j) {
    for (let U = N.length; U <= j; U++) N[U] = [];
    return N[j];
  })(v, g), A = (function(N, j) {
    let U = N.length;
    for (let X = U - 1; X >= 0 && !(j >= N[X][0]); U = X--)
      ;
    return U;
  })(C, f);
  if (!x)
    return (function(N, j) {
      return j === 0 ? !0 : N[j - 1].length === 1;
    })(C, A) ? void 0 : ng(C, A, [f]);
  const O = (function(N, j) {
    const U = (function(F, q) {
      return F._indexes[q];
    })(N, j);
    if (U !== void 0) return U;
    const { array: X, _indexes: W } = N, H = X.push(j);
    return W[j] = H - 1;
  })(b, x), D = -1;
  if (O === E.length && (E[O] = null), !(function(N, j, U, X, W, H) {
    if (j === 0) return !1;
    const F = N[j - 1];
    return F.length !== 1 && U === F[1] && X === F[2] && W === F[3] && H === (F.length === 5 ? F[4] : -1);
  })(C, A, O, m, y, D))
    return ng(C, A, [f, O, m, y]);
})(0, e, t, s, n, i, o);
function ng(e, t, s) {
  for (let n = e.length; n > t; n--) e[n] = e[n - 1];
  e[t] = s;
}
function u_({ code: e, mappings: t }, s, n, i, o) {
  const c = (function(v, b) {
    const E = new Array(b.length);
    let w = 0, C = b[w].start, A = 0;
    for (let O = 0; O < v.length; O++) O === C && (E[w] = C - A, w++, C = b[w].start), v.charCodeAt(O) === V.lineFeed && (A = O + 1);
    return E;
  })(i, o), l = new h_({ file: n.compiledFilename });
  let p = 0, d = t[0];
  for (; d === void 0 && p < t.length - 1; ) p++, d = t[p];
  let g = 0, f = 0;
  d !== f && Dl(l, g, 0, s, g, 0);
  for (let v = 0; v < e.length; v++) {
    if (v === d) {
      const b = d - f, E = c[p];
      for (Dl(l, g, b, s, g, E); (d === v || d === void 0) && p < t.length - 1; ) p++, d = t[p];
    }
    e.charCodeAt(v) === V.lineFeed && (g++, f = v + 1, d !== f && Dl(l, g, 0, s, g, 0));
  }
  const { sourceRoot: x, sourcesContent: m, ...y } = (function(v) {
    const b = (function(E) {
      const { _mappings: w, _sources: C, _sourcesContent: A, _names: O, _ignoreList: D } = E;
      return (function(N) {
        const { length: j } = N;
        let U = j;
        for (let X = U - 1; X >= 0 && !(N[X].length > 0); U = X, X--) ;
        U < j && (N.length = U);
      })(w), { version: 3, file: E.file || void 0, names: O.array, sourceRoot: E.sourceRoot || void 0, sources: C.array, sourcesContent: A, mappings: w, ignoreList: D.array };
    })(v);
    return Object.assign({}, b, { mappings: l_(b.mappings) });
  })(l);
  return y;
}
const d_ = { require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `, interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `, interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `, createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `, createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `, nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `, asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `, optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `, asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `, optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `, asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  ` };
class Ko {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(t) {
    this.nameManager = t, Ko.prototype.__init.call(this), Ko.prototype.__init2.call(this);
  }
  getHelperName(t) {
    let s = this.helperNames[t];
    return s || (s = this.nameManager.claimFreeName(`_${t}`), this.helperNames[t] = s, s);
  }
  emitHelpers() {
    let t = "";
    this.helperNames.optionalChainDelete && this.getHelperName("optionalChain"), this.helperNames.asyncOptionalChainDelete && this.getHelperName("asyncOptionalChain");
    for (const [s, n] of Object.entries(d_)) {
      const i = this.helperNames[s];
      let o = n;
      s === "optionalChainDelete" ? o = o.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain) : s === "asyncOptionalChainDelete" ? o = o.replace("ASYNC_OPTIONAL_CHAIN_NAME", this.helperNames.asyncOptionalChain) : s === "require" && (this.createRequireName === null && (this.createRequireName = this.nameManager.claimFreeName("_createRequire")), o = o.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName)), i && (t += " ", t += o.replace(s, i).replace(/\s+/g, " ").trim());
    }
    return t;
  }
}
function ig(e, t, s) {
  (function(n, i) {
    for (const o of n.tokens) if (o.type === h.name && !o.isType && Xw(o) && i.has(n.identifierNameForToken(o))) return !0;
    return !1;
  })(e, s) && (function(n, i, o) {
    const c = [];
    let l = i.length - 1;
    for (let p = n.tokens.length - 1; ; p--) {
      for (; c.length > 0 && c[c.length - 1].startTokenIndex === p + 1; ) c.pop();
      for (; l >= 0 && i[l].endTokenIndex === p + 1; ) c.push(i[l]), l--;
      if (p < 0) break;
      const d = n.tokens[p], g = n.identifierNameForToken(d);
      if (c.length > 1 && !d.isType && d.type === h.name && o.has(g)) {
        if (Kw(d)) og(c[c.length - 1], n, g);
        else if (Jw(d)) {
          let f = c.length - 1;
          for (; f > 0 && !c[f].isFunctionScope; ) f--;
          if (f < 0) throw new Error("Did not find parent function scope.");
          og(c[f], n, g);
        }
      }
    }
    if (c.length > 0) throw new Error("Expected empty scope stack after processing file.");
  })(e, t, s);
}
function og(e, t, s) {
  for (let n = e.startTokenIndex; n < e.endTokenIndex; n++) {
    const i = t.tokens[n];
    i.type !== h.name && i.type !== h.jsxName || t.identifierNameForToken(i) !== s || (i.shadowsGlobal = !0);
  }
}
class mu {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(t, s) {
    mu.prototype.__init.call(this), this.usedNames = new Set((function(n, i) {
      const o = [];
      for (const c of i) c.type === h.name && o.push(n.slice(c.start, c.end));
      return o;
    })(t, s));
  }
  claimFreeName(t) {
    const s = this.findFreeName(t);
    return this.usedNames.add(s), s;
  }
  findFreeName(t) {
    if (!this.usedNames.has(t)) return t;
    let s = 2;
    for (; this.usedNames.has(t + String(s)); ) s++;
    return t + String(s);
  }
}
var ag, cg, lg, eo = {}, to = {}, rr = {};
function Sp() {
  if (ag) return rr;
  ag = 1;
  var e, t = rr && rr.__extends || (e = function(c, l) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, d) {
      p.__proto__ = d;
    } || function(p, d) {
      for (var g in d) d.hasOwnProperty(g) && (p[g] = d[g]);
    }, e(c, l);
  }, function(c, l) {
    function p() {
      this.constructor = c;
    }
    e(c, l), c.prototype = l === null ? Object.create(l) : (p.prototype = l.prototype, new p());
  });
  Object.defineProperty(rr, "__esModule", { value: !0 }), rr.DetailContext = rr.NoopContext = rr.VError = void 0;
  var s = (function(c) {
    function l(p, d) {
      var g = c.call(this, d) || this;
      return g.path = p, Object.setPrototypeOf(g, l.prototype), g;
    }
    return t(l, c), l;
  })(Error);
  rr.VError = s;
  var n = (function() {
    function c() {
    }
    return c.prototype.fail = function(l, p, d) {
      return !1;
    }, c.prototype.unionResolver = function() {
      return this;
    }, c.prototype.createContext = function() {
      return this;
    }, c.prototype.resolveUnion = function(l) {
    }, c;
  })();
  rr.NoopContext = n;
  var i = (function() {
    function c() {
      this._propNames = [""], this._messages = [null], this._score = 0;
    }
    return c.prototype.fail = function(l, p, d) {
      return this._propNames.push(l), this._messages.push(p), this._score += d, !1;
    }, c.prototype.unionResolver = function() {
      return new o();
    }, c.prototype.resolveUnion = function(l) {
      for (var p, d, g = null, f = 0, x = l.contexts; f < x.length; f++) {
        var m = x[f];
        (!g || m._score >= g._score) && (g = m);
      }
      g && g._score > 0 && ((p = this._propNames).push.apply(p, g._propNames), (d = this._messages).push.apply(d, g._messages));
    }, c.prototype.getError = function(l) {
      for (var p = [], d = this._propNames.length - 1; d >= 0; d--) {
        var g = this._propNames[d];
        l += typeof g == "number" ? "[" + g + "]" : g ? "." + g : "";
        var f = this._messages[d];
        f && p.push(l + " " + f);
      }
      return new s(l, p.join("; "));
    }, c.prototype.getErrorDetail = function(l) {
      for (var p = [], d = this._propNames.length - 1; d >= 0; d--) {
        var g = this._propNames[d];
        l += typeof g == "number" ? "[" + g + "]" : g ? "." + g : "";
        var f = this._messages[d];
        f && p.push({ path: l, message: f });
      }
      var x = null;
      for (d = p.length - 1; d >= 0; d--) x && (p[d].nested = [x]), x = p[d];
      return x;
    }, c;
  })();
  rr.DetailContext = i;
  var o = (function() {
    function c() {
      this.contexts = [];
    }
    return c.prototype.createContext = function() {
      var l = new i();
      return this.contexts.push(l), l;
    }, c;
  })();
  return rr;
}
function pg() {
  return cg || (cg = 1, (function(e) {
    var t, s = to && to.__extends || (t = function(F, q) {
      return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(G, ee) {
        G.__proto__ = ee;
      } || function(G, ee) {
        for (var ce in ee) ee.hasOwnProperty(ce) && (G[ce] = ee[ce]);
      }, t(F, q);
    }, function(F, q) {
      function G() {
        this.constructor = F;
      }
      t(F, q), F.prototype = q === null ? Object.create(q) : (G.prototype = q.prototype, new G());
    });
    Object.defineProperty(e, "__esModule", { value: !0 }), e.basicTypes = e.BasicType = e.TParamList = e.TParam = e.param = e.TFunc = e.func = e.TProp = e.TOptional = e.opt = e.TIface = e.iface = e.TEnumLiteral = e.enumlit = e.TEnumType = e.enumtype = e.TIntersection = e.intersection = e.TUnion = e.union = e.TTuple = e.tuple = e.TArray = e.array = e.TLiteral = e.lit = e.TName = e.name = e.TType = void 0;
    var n = Sp(), i = function() {
    };
    function o(F) {
      return typeof F == "string" ? l(F) : F;
    }
    function c(F, q) {
      var G = F[q];
      if (!G) throw new Error("Unknown type " + q);
      return G;
    }
    function l(F) {
      return new p(F);
    }
    e.TType = i, e.name = l;
    var p = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.name = G, ee._failMsg = "is not a " + G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee, ce) {
        var Te = this, Q = c(G, this.name), pe = Q.getChecker(G, ee, ce);
        return Q instanceof N || Q instanceof q ? pe : function(J, $) {
          return !!pe(J, $) || $.fail(null, Te._failMsg, 0);
        };
      }, q;
    })(i);
    e.TName = p, e.lit = function(F) {
      return new d(F);
    };
    var d = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.value = G, ee.name = JSON.stringify(G), ee._failMsg = "is not " + ee.name, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this;
        return function(Te, Q) {
          return Te === ce.value || Q.fail(null, ce._failMsg, -1);
        };
      }, q;
    })(i);
    e.TLiteral = d, e.array = function(F) {
      return new g(o(F));
    };
    var g = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.ttype = G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this.ttype.getChecker(G, ee);
        return function(Te, Q) {
          if (!Array.isArray(Te)) return Q.fail(null, "is not an array", 0);
          for (var pe = 0; pe < Te.length; pe++)
            if (!ce(Te[pe], Q)) return Q.fail(pe, null, 1);
          return !0;
        };
      }, q;
    })(i);
    e.TArray = g, e.tuple = function() {
      for (var F = [], q = 0; q < arguments.length; q++) F[q] = arguments[q];
      return new f(F.map(function(G) {
        return o(G);
      }));
    };
    var f = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.ttypes = G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this.ttypes.map(function(Q) {
          return Q.getChecker(G, ee);
        }), Te = function(Q, pe) {
          if (!Array.isArray(Q)) return pe.fail(null, "is not an array", 0);
          for (var J = 0; J < ce.length; J++)
            if (!ce[J](Q[J], pe)) return pe.fail(J, null, 1);
          return !0;
        };
        return ee ? function(Q, pe) {
          return !!Te(Q, pe) && (Q.length <= ce.length || pe.fail(ce.length, "is extraneous", 2));
        } : Te;
      }, q;
    })(i);
    e.TTuple = f, e.union = function() {
      for (var F = [], q = 0; q < arguments.length; q++) F[q] = arguments[q];
      return new x(F.map(function(G) {
        return o(G);
      }));
    };
    var x = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        ee.ttypes = G;
        var ce = G.map(function(Q) {
          return Q instanceof p || Q instanceof d ? Q.name : null;
        }).filter(function(Q) {
          return Q;
        }), Te = G.length - ce.length;
        return ce.length ? (Te > 0 && ce.push(Te + " more"), ee._failMsg = "is none of " + ce.join(", ")) : ee._failMsg = "is none of " + Te + " types", ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this, Te = this.ttypes.map(function(Q) {
          return Q.getChecker(G, ee);
        });
        return function(Q, pe) {
          for (var J = pe.unionResolver(), $ = 0; $ < Te.length; $++)
            if (Te[$](Q, J.createContext())) return !0;
          return pe.resolveUnion(J), pe.fail(null, ce._failMsg, 0);
        };
      }, q;
    })(i);
    e.TUnion = x, e.intersection = function() {
      for (var F = [], q = 0; q < arguments.length; q++) F[q] = arguments[q];
      return new m(F.map(function(G) {
        return o(G);
      }));
    };
    var m = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.ttypes = G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = /* @__PURE__ */ new Set(), Te = this.ttypes.map(function(Q) {
          return Q.getChecker(G, ee, ce);
        });
        return function(Q, pe) {
          return !!Te.every(function(J) {
            return J(Q, pe);
          }) || pe.fail(null, null, 0);
        };
      }, q;
    })(i);
    e.TIntersection = m, e.enumtype = function(F) {
      return new y(F);
    };
    var y = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.members = G, ee.validValues = /* @__PURE__ */ new Set(), ee._failMsg = "is not a valid enum value", ee.validValues = new Set(Object.keys(G).map(function(ce) {
          return G[ce];
        })), ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this;
        return function(Te, Q) {
          return !!ce.validValues.has(Te) || Q.fail(null, ce._failMsg, 0);
        };
      }, q;
    })(i);
    e.TEnumType = y, e.enumlit = function(F, q) {
      return new v(F, q);
    };
    var v = (function(F) {
      function q(G, ee) {
        var ce = F.call(this) || this;
        return ce.enumName = G, ce.prop = ee, ce._failMsg = "is not " + G + "." + ee, ce;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this, Te = c(G, this.enumName);
        if (!(Te instanceof y)) throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        var Q = Te.members[this.prop];
        if (!Te.members.hasOwnProperty(this.prop)) throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        return function(pe, J) {
          return pe === Q || J.fail(null, ce._failMsg, -1);
        };
      }, q;
    })(i);
    function b(F) {
      return Object.keys(F).map(function(q) {
        return (function(G, ee) {
          return ee instanceof w ? new C(G, ee.ttype, !0) : new C(G, o(ee), !1);
        })(q, F[q]);
      });
    }
    e.TEnumLiteral = v, e.iface = function(F, q) {
      return new E(F, b(q));
    };
    var E = (function(F) {
      function q(G, ee) {
        var ce = F.call(this) || this;
        return ce.bases = G, ce.props = ee, ce.propSet = new Set(ee.map(function(Te) {
          return Te.name;
        })), ce;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee, ce) {
        var Te = this, Q = this.bases.map(function(se) {
          return c(G, se).getChecker(G, ee);
        }), pe = this.props.map(function(se) {
          return se.ttype.getChecker(G, ee);
        }), J = new n.NoopContext(), $ = this.props.map(function(se, z) {
          return !se.isOpt && !pe[z](void 0, J);
        }), oe = function(se, z) {
          if (typeof se != "object" || se === null) return z.fail(null, "is not an object", 0);
          for (var ie = 0; ie < Q.length; ie++) if (!Q[ie](se, z)) return !1;
          for (ie = 0; ie < pe.length; ie++) {
            var ae = Te.props[ie].name, ge = se[ae];
            if (ge === void 0) {
              if ($[ie]) return z.fail(ae, "is missing", 1);
            } else if (!pe[ie](ge, z)) return z.fail(ae, null, 1);
          }
          return !0;
        };
        if (!ee) return oe;
        var Y = this.propSet;
        return ce && (this.propSet.forEach(function(se) {
          return ce.add(se);
        }), Y = ce), function(se, z) {
          if (!oe(se, z)) return !1;
          for (var ie in se) if (!Y.has(ie)) return z.fail(ie, "is extraneous", 2);
          return !0;
        };
      }, q;
    })(i);
    e.TIface = E, e.opt = function(F) {
      return new w(o(F));
    };
    var w = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.ttype = G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this.ttype.getChecker(G, ee);
        return function(Te, Q) {
          return Te === void 0 || ce(Te, Q);
        };
      }, q;
    })(i);
    e.TOptional = w;
    var C = function(F, q, G) {
      this.name = F, this.ttype = q, this.isOpt = G;
    };
    e.TProp = C, e.func = function(F) {
      for (var q = [], G = 1; G < arguments.length; G++) q[G - 1] = arguments[G];
      return new A(new D(q), o(F));
    };
    var A = (function(F) {
      function q(G, ee) {
        var ce = F.call(this) || this;
        return ce.paramList = G, ce.result = ee, ce;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        return function(ce, Te) {
          return typeof ce == "function" || Te.fail(null, "is not a function", 0);
        };
      }, q;
    })(i);
    e.TFunc = A, e.param = function(F, q, G) {
      return new O(F, o(q), !!G);
    };
    var O = function(F, q, G) {
      this.name = F, this.ttype = q, this.isOpt = G;
    };
    e.TParam = O;
    var D = (function(F) {
      function q(G) {
        var ee = F.call(this) || this;
        return ee.params = G, ee;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this, Te = this.params.map(function($) {
          return $.ttype.getChecker(G, ee);
        }), Q = new n.NoopContext(), pe = this.params.map(function($, oe) {
          return !$.isOpt && !Te[oe](void 0, Q);
        }), J = function($, oe) {
          if (!Array.isArray($)) return oe.fail(null, "is not an array", 0);
          for (var Y = 0; Y < Te.length; Y++) {
            var se = ce.params[Y];
            if ($[Y] === void 0) {
              if (pe[Y]) return oe.fail(se.name, "is missing", 1);
            } else if (!Te[Y]($[Y], oe)) return oe.fail(se.name, null, 1);
          }
          return !0;
        };
        return ee ? function($, oe) {
          return !!J($, oe) && ($.length <= Te.length || oe.fail(Te.length, "is extraneous", 2));
        } : J;
      }, q;
    })(i);
    e.TParamList = D;
    var N = (function(F) {
      function q(G, ee) {
        var ce = F.call(this) || this;
        return ce.validator = G, ce.message = ee, ce;
      }
      return s(q, F), q.prototype.getChecker = function(G, ee) {
        var ce = this;
        return function(Te, Q) {
          return !!ce.validator(Te) || Q.fail(null, ce.message, 0);
        };
      }, q;
    })(i);
    e.BasicType = N, e.basicTypes = { any: new N(function(F) {
      return !0;
    }, "is invalid"), number: new N(function(F) {
      return typeof F == "number";
    }, "is not a number"), object: new N(function(F) {
      return typeof F == "object" && F;
    }, "is not an object"), boolean: new N(function(F) {
      return typeof F == "boolean";
    }, "is not a boolean"), string: new N(function(F) {
      return typeof F == "string";
    }, "is not a string"), symbol: new N(function(F) {
      return typeof F == "symbol";
    }, "is not a symbol"), void: new N(function(F) {
      return F == null;
    }, "is not void"), undefined: new N(function(F) {
      return F === void 0;
    }, "is not undefined"), null: new N(function(F) {
      return F === null;
    }, "is not null"), never: new N(function(F) {
      return !1;
    }, "is unexpected"), Date: new N(U("[object Date]"), "is not a Date"), RegExp: new N(U("[object RegExp]"), "is not a RegExp") };
    var j = Object.prototype.toString;
    function U(F) {
      return function(q) {
        return typeof q == "object" && q && j.call(q) === F;
      };
    }
    typeof Buffer < "u" && (e.basicTypes.Buffer = new N(function(F) {
      return Buffer.isBuffer(F);
    }, "is not a Buffer"));
    for (var X = function(F) {
      e.basicTypes[F.name] = new N(function(q) {
        return q instanceof F;
      }, "is not a " + F.name);
    }, W = 0, H = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; W < H.length; W++)
      X(H[W]);
  })(to)), to;
}
var ze = (lg || (lg = 1, (function(e) {
  var t = eo && eo.__spreadArrays || function() {
    for (var l = 0, p = 0, d = arguments.length; p < d; p++) l += arguments[p].length;
    var g = Array(l), f = 0;
    for (p = 0; p < d; p++) for (var x = arguments[p], m = 0, y = x.length; m < y; m++, f++) g[f] = x[m];
    return g;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Checker = e.createCheckers = void 0;
  var s = pg(), n = Sp(), i = pg();
  Object.defineProperty(e, "TArray", { enumerable: !0, get: function() {
    return i.TArray;
  } }), Object.defineProperty(e, "TEnumType", { enumerable: !0, get: function() {
    return i.TEnumType;
  } }), Object.defineProperty(e, "TEnumLiteral", { enumerable: !0, get: function() {
    return i.TEnumLiteral;
  } }), Object.defineProperty(e, "TFunc", { enumerable: !0, get: function() {
    return i.TFunc;
  } }), Object.defineProperty(e, "TIface", { enumerable: !0, get: function() {
    return i.TIface;
  } }), Object.defineProperty(e, "TLiteral", { enumerable: !0, get: function() {
    return i.TLiteral;
  } }), Object.defineProperty(e, "TName", { enumerable: !0, get: function() {
    return i.TName;
  } }), Object.defineProperty(e, "TOptional", { enumerable: !0, get: function() {
    return i.TOptional;
  } }), Object.defineProperty(e, "TParam", { enumerable: !0, get: function() {
    return i.TParam;
  } }), Object.defineProperty(e, "TParamList", { enumerable: !0, get: function() {
    return i.TParamList;
  } }), Object.defineProperty(e, "TProp", { enumerable: !0, get: function() {
    return i.TProp;
  } }), Object.defineProperty(e, "TTuple", { enumerable: !0, get: function() {
    return i.TTuple;
  } }), Object.defineProperty(e, "TType", { enumerable: !0, get: function() {
    return i.TType;
  } }), Object.defineProperty(e, "TUnion", { enumerable: !0, get: function() {
    return i.TUnion;
  } }), Object.defineProperty(e, "TIntersection", { enumerable: !0, get: function() {
    return i.TIntersection;
  } }), Object.defineProperty(e, "array", { enumerable: !0, get: function() {
    return i.array;
  } }), Object.defineProperty(e, "enumlit", { enumerable: !0, get: function() {
    return i.enumlit;
  } }), Object.defineProperty(e, "enumtype", { enumerable: !0, get: function() {
    return i.enumtype;
  } }), Object.defineProperty(e, "func", { enumerable: !0, get: function() {
    return i.func;
  } }), Object.defineProperty(e, "iface", { enumerable: !0, get: function() {
    return i.iface;
  } }), Object.defineProperty(e, "lit", { enumerable: !0, get: function() {
    return i.lit;
  } }), Object.defineProperty(e, "name", { enumerable: !0, get: function() {
    return i.name;
  } }), Object.defineProperty(e, "opt", { enumerable: !0, get: function() {
    return i.opt;
  } }), Object.defineProperty(e, "param", { enumerable: !0, get: function() {
    return i.param;
  } }), Object.defineProperty(e, "tuple", { enumerable: !0, get: function() {
    return i.tuple;
  } }), Object.defineProperty(e, "union", { enumerable: !0, get: function() {
    return i.union;
  } }), Object.defineProperty(e, "intersection", { enumerable: !0, get: function() {
    return i.intersection;
  } }), Object.defineProperty(e, "BasicType", { enumerable: !0, get: function() {
    return i.BasicType;
  } });
  var o = Sp();
  Object.defineProperty(e, "VError", { enumerable: !0, get: function() {
    return o.VError;
  } }), e.createCheckers = function() {
    for (var l = [], p = 0; p < arguments.length; p++) l[p] = arguments[p];
    for (var d = Object.assign.apply(Object, t([{}, s.basicTypes], l)), g = {}, f = 0, x = l; f < x.length; f++) for (var m = x[f], y = 0, v = Object.keys(m); y < v.length; y++) {
      var b = v[y];
      g[b] = new c(d, m[b]);
    }
    return g;
  };
  var c = (function() {
    function l(p, d, g) {
      if (g === void 0 && (g = "value"), this.suite = p, this.ttype = d, this._path = g, this.props = /* @__PURE__ */ new Map(), d instanceof s.TIface) for (var f = 0, x = d.props; f < x.length; f++) {
        var m = x[f];
        this.props.set(m.name, m.ttype);
      }
      this.checkerPlain = this.ttype.getChecker(p, !1), this.checkerStrict = this.ttype.getChecker(p, !0);
    }
    return l.prototype.setReportedPath = function(p) {
      this._path = p;
    }, l.prototype.check = function(p) {
      return this._doCheck(this.checkerPlain, p);
    }, l.prototype.test = function(p) {
      return this.checkerPlain(p, new n.NoopContext());
    }, l.prototype.validate = function(p) {
      return this._doValidate(this.checkerPlain, p);
    }, l.prototype.strictCheck = function(p) {
      return this._doCheck(this.checkerStrict, p);
    }, l.prototype.strictTest = function(p) {
      return this.checkerStrict(p, new n.NoopContext());
    }, l.prototype.strictValidate = function(p) {
      return this._doValidate(this.checkerStrict, p);
    }, l.prototype.getProp = function(p) {
      var d = this.props.get(p);
      if (!d) throw new Error("Type has no property " + p);
      return new l(this.suite, d, this._path + "." + p);
    }, l.prototype.methodArgs = function(p) {
      var d = this._getMethod(p);
      return new l(this.suite, d.paramList);
    }, l.prototype.methodResult = function(p) {
      var d = this._getMethod(p);
      return new l(this.suite, d.result);
    }, l.prototype.getArgs = function() {
      if (!(this.ttype instanceof s.TFunc)) throw new Error("getArgs() applied to non-function");
      return new l(this.suite, this.ttype.paramList);
    }, l.prototype.getResult = function() {
      if (!(this.ttype instanceof s.TFunc)) throw new Error("getResult() applied to non-function");
      return new l(this.suite, this.ttype.result);
    }, l.prototype.getType = function() {
      return this.ttype;
    }, l.prototype._doCheck = function(p, d) {
      if (!p(d, new n.NoopContext())) {
        var g = new n.DetailContext();
        throw p(d, g), g.getError(this._path);
      }
    }, l.prototype._doValidate = function(p, d) {
      if (p(d, new n.NoopContext())) return null;
      var g = new n.DetailContext();
      return p(d, g), g.getErrorDetail(this._path);
    }, l.prototype._getMethod = function(p) {
      var d = this.props.get(p);
      if (!d) throw new Error("Type has no property " + p);
      if (!(d instanceof s.TFunc)) throw new Error("Property " + p + " is not a method");
      return d;
    }, l;
  })();
  e.Checker = c;
})(eo)), eo);
const f_ = { Transform: ze.union(ze.lit("jsx"), ze.lit("typescript"), ze.lit("flow"), ze.lit("imports"), ze.lit("react-hot-loader"), ze.lit("jest")), SourceMapOptions: ze.iface([], { compiledFilename: "string" }), Options: ze.iface([], { transforms: ze.array("Transform"), disableESTransforms: ze.opt("boolean"), jsxRuntime: ze.opt(ze.union(ze.lit("classic"), ze.lit("automatic"), ze.lit("preserve"))), production: ze.opt("boolean"), jsxImportSource: ze.opt("string"), jsxPragma: ze.opt("string"), jsxFragmentPragma: ze.opt("string"), keepUnusedImports: ze.opt("boolean"), preserveDynamicImport: ze.opt("boolean"), injectCreateRequireForImportRequire: ze.opt("boolean"), enableLegacyTypeScriptModuleInterop: ze.opt("boolean"), enableLegacyBabel5ModuleInterop: ze.opt("boolean"), sourceMapOptions: ze.opt("SourceMapOptions"), filePath: ze.opt("string") }) }, { Options: m_ } = ze.createCheckers(f_);
function c0() {
  re(), xt(!1);
}
function l0(e) {
  re(), za(e);
}
function ts(e) {
  _e(), gu(e);
}
function Jo() {
  _e(), k.tokens[k.tokens.length - 1].identifierRole = ke.ImportDeclaration;
}
function gu(e) {
  let t;
  t = k.scopeDepth === 0 ? ke.TopLevelDeclaration : e ? ke.BlockScopedDeclaration : ke.FunctionScopedDeclaration, k.tokens[k.tokens.length - 1].identifierRole = t;
}
function za(e) {
  switch (k.type) {
    case h._this: {
      const t = Ie(0);
      return re(), void Ce(t);
    }
    case h._yield:
    case h.name:
      return k.type = h.name, void ts(e);
    case h.bracketL:
      return re(), void yu(h.bracketR, e, !0);
    case h.braceL:
      return void wu(!0, e);
    default:
      Ae();
  }
}
function yu(e, t, s = !1, n = !1, i = 0) {
  let o = !0, c = !1;
  const l = k.tokens.length;
  for (; !Z(e) && !k.error; ) if (o ? o = !1 : (te(h.comma), k.tokens[k.tokens.length - 1].contextId = i, !c && k.tokens[l].isType && (k.tokens[k.tokens.length - 1].isType = !0, c = !0)), !(s && L(h.comma))) {
    if (Z(e)) break;
    if (L(h.ellipsis)) {
      l0(t), p0(), Z(h.comma), te(e);
      break;
    }
    g_(n, t);
  }
}
function g_(e, t) {
  e && wp([B._public, B._protected, B._private, B._readonly, B._override]), Yo(t), p0(), Yo(t, !0);
}
function p0() {
  je ? (function() {
    const e = Ie(0);
    Z(h.question), L(h.colon) && Ms(), Ce(e);
  })() : Le && (function() {
    const e = Ie(0);
    Z(h.question), xn(), Ce(e);
  })();
}
function Yo(e, t = !1) {
  if (t || za(e), !Z(h.eq)) return;
  const s = k.tokens.length - 1;
  xt(), k.tokens[s].rhsEndIndex = k.tokens.length;
}
function Ep() {
  return L(h.name);
}
function h0() {
  const e = k.snapshot();
  return re(), !!((L(h.bracketL) || L(h.braceL) || L(h.star) || L(h.ellipsis) || L(h.hash) || L(h.name) || k.type & h.IS_KEYWORD || L(h.string) || L(h.num) || L(h.bigint) || L(h.decimal)) && !Lt()) || (k.restoreFromSnapshot(e), !1);
}
function wp(e) {
  for (; u0(e) !== null; )
    ;
}
function u0(e) {
  if (!L(h.name)) return null;
  const t = k.contextualKeyword;
  if (e.indexOf(t) !== -1 && h0()) {
    switch (t) {
      case B._readonly:
        k.tokens[k.tokens.length - 1].type = h._readonly;
        break;
      case B._abstract:
        k.tokens[k.tokens.length - 1].type = h._abstract;
        break;
      case B._static:
        k.tokens[k.tokens.length - 1].type = h._static;
        break;
      case B._public:
        k.tokens[k.tokens.length - 1].type = h._public;
        break;
      case B._private:
        k.tokens[k.tokens.length - 1].type = h._private;
        break;
      case B._protected:
        k.tokens[k.tokens.length - 1].type = h._protected;
        break;
      case B._override:
        k.tokens[k.tokens.length - 1].type = h._override;
        break;
      case B._declare:
        k.tokens[k.tokens.length - 1].type = h._declare;
    }
    return t;
  }
  return null;
}
function hi() {
  for (_e(); Z(h.dot); ) _e();
}
function hg() {
  te(h._import), te(h.parenL), te(h.string), te(h.parenR), Z(h.dot) && hi(), L(h.lessThan) && hn();
}
function y_() {
  Z(h._const);
  const e = Z(h._in), t = lt(B._out);
  Z(h._const), !e && !t || L(h.name) ? _e() : k.tokens[k.tokens.length - 1].type = h.name, Z(h._extends) && et(), Z(h.eq) && et();
}
function As() {
  L(h.lessThan) && Qo();
}
function Qo() {
  const e = Ie(0);
  for (L(h.lessThan) || L(h.typeParameterStart) ? re() : Ae(); !Z(h.greaterThan) && !k.error; ) y_(), Z(h.comma);
  Ce(e);
}
function xu(e) {
  const t = e === h.arrow;
  var s;
  As(), te(h.parenL), k.scopeDepth++, s = !1, yu(h.parenR, s), k.scopeDepth--, (t || L(e)) && Wa(e);
}
function Zo() {
  Z(h.comma) || Ke();
}
function ug() {
  xu(h.colon), Zo();
}
function d0() {
  if (!L(h.bracketL) || !(function() {
    const t = k.snapshot();
    re();
    const s = Z(h.name) && L(h.colon);
    return k.restoreFromSnapshot(t), s;
  })()) return !1;
  const e = Ie(0);
  return te(h.bracketL), _e(), Pi(), te(h.bracketR), xn(), Zo(), Ce(e), !0;
}
function dg(e) {
  Z(h.question), e || !L(h.parenL) && !L(h.lessThan) ? (xn(), Zo()) : (xu(h.colon), Zo());
}
function x_() {
  if (L(h.parenL) || L(h.lessThan)) return void ug();
  if (L(h._new)) return re(), void (L(h.parenL) || L(h.lessThan) ? ug() : dg(!1));
  const e = !!u0([B._readonly]);
  d0() || ((be(B._get) || be(B._set)) && h0(), di(-1), dg(e));
}
function f0() {
  for (te(h.braceL); !Z(h.braceR) && !k.error; ) x_();
}
function b_() {
  const e = k.snapshot(), t = (function() {
    return re(), Z(h.plus) || Z(h.minus) ? be(B._readonly) : (be(B._readonly) && re(), !L(h.bracketL) || (re(), !Ep()) ? !1 : (re(), L(h._in)));
  })();
  return k.restoreFromSnapshot(e), t;
}
function T_() {
  te(h.braceL), L(h.plus) || L(h.minus) ? (re(), st(B._readonly)) : lt(B._readonly), te(h.bracketL), _e(), te(h._in), et(), lt(B._as) && et(), te(h.bracketR), L(h.plus) || L(h.minus) ? (re(), te(h.question)) : Z(h.question), Z(h.colon) && et(), Ke(), te(h.braceR);
}
function v_() {
  Z(h.ellipsis) ? et() : (et(), Z(h.question)), Z(h.colon) && et();
}
var Jr;
function Fl(e) {
  e === Jr.TSAbstractConstructorType && st(B._abstract), e !== Jr.TSConstructorType && e !== Jr.TSAbstractConstructorType || te(h._new);
  const t = k.inDisallowConditionalTypesContext;
  k.inDisallowConditionalTypesContext = !1, xu(h.arrow), k.inDisallowConditionalTypesContext = t;
}
function k_() {
  switch (k.type) {
    case h.name:
      return hi(), void (!Lt() && L(h.lessThan) && hn());
    case h._void:
    case h._null:
      return void re();
    case h.string:
    case h.num:
    case h.bigint:
    case h.decimal:
    case h._true:
    case h._false:
      return void un();
    case h.minus:
      return re(), void un();
    case h._this:
      return re(), void (be(B._is) && !Lt() && (re(), Pi()));
    case h._typeof:
      return te(h._typeof), L(h._import) ? hg() : hi(), void (!Lt() && L(h.lessThan) && hn());
    case h._import:
      return void hg();
    case h.braceL:
      return void (b_() ? T_() : f0());
    case h.bracketL:
      return void (function() {
        for (te(h.bracketL); !Z(h.bracketR) && !k.error; ) v_(), Z(h.comma);
      })();
    case h.parenL:
      return te(h.parenL), et(), void te(h.parenR);
    case h.backQuote:
      return void (function() {
        for (Gr(), Gr(); !L(h.backQuote) && !k.error; ) te(h.dollarBraceL), et(), Gr(), Gr();
        re();
      })();
    default:
      if (k.type & h.IS_KEYWORD) return re(), void (k.tokens[k.tokens.length - 1].type = h.name);
  }
  Ae();
}
function _p() {
  if (be(B._keyof) || be(B._unique) || be(B._readonly)) re(), _p();
  else if (be(B._infer)) (function() {
    if (st(B._infer), _e(), L(h._extends)) {
      const e = k.snapshot();
      te(h._extends);
      const t = k.inDisallowConditionalTypesContext;
      k.inDisallowConditionalTypesContext = !0, et(), k.inDisallowConditionalTypesContext = t, (k.error || !k.inDisallowConditionalTypesContext && L(h.question)) && k.restoreFromSnapshot(e);
    }
  })();
  else {
    const e = k.inDisallowConditionalTypesContext;
    k.inDisallowConditionalTypesContext = !1, (function() {
      for (k_(); !Lt() && Z(h.bracketL); ) Z(h.bracketR) || (et(), te(h.bracketR));
    })(), k.inDisallowConditionalTypesContext = e;
  }
}
function fg() {
  if (Z(h.bitwiseAND), _p(), L(h.bitwiseAND)) for (; Z(h.bitwiseAND); ) _p();
}
function S_() {
  return !!L(h.lessThan) || L(h.parenL) && (function() {
    const e = k.snapshot(), t = (function() {
      return re(), !!(L(h.parenR) || L(h.ellipsis) || (function() {
        if (L(h.name) || L(h._this)) return re(), !0;
        if (L(h.braceL) || L(h.bracketL)) {
          let s = 1;
          for (re(); s > 0 && !k.error; ) L(h.braceL) || L(h.bracketL) ? s++ : (L(h.braceR) || L(h.bracketR)) && s--, re();
          return !0;
        }
        return !1;
      })() && (L(h.colon) || L(h.comma) || L(h.question) || L(h.eq) || L(h.parenR) && (re(), L(h.arrow))));
    })();
    return k.restoreFromSnapshot(e), t;
  })();
}
function Wa(e) {
  const t = Ie(0);
  te(e), (function() {
    const s = k.snapshot();
    return be(B._asserts) ? (re(), lt(B._is) ? (et(), !0) : Ep() || L(h._this) ? (re(), lt(B._is) && et(), !0) : (k.restoreFromSnapshot(s), !1)) : Ep() || L(h._this) ? (re(), be(B._is) && !Lt() ? (re(), et(), !0) : (k.restoreFromSnapshot(s), !1)) : !1;
  })() || et(), Ce(t);
}
function xn() {
  L(h.colon) && Pi();
}
function Pi() {
  const e = Ie(0);
  te(h.colon), et(), Ce(e);
}
function et() {
  if (mg(), k.inDisallowConditionalTypesContext || Lt() || !Z(h._extends)) return;
  const e = k.inDisallowConditionalTypesContext;
  k.inDisallowConditionalTypesContext = !0, mg(), k.inDisallowConditionalTypesContext = e, te(h.question), et(), te(h.colon), et();
}
function mg() {
  S_() ? Fl(Jr.TSFunctionType) : L(h._new) ? Fl(Jr.TSConstructorType) : be(B._abstract) && Ze() === h._new ? Fl(Jr.TSAbstractConstructorType) : (function() {
    if (Z(h.bitwiseOR), fg(), L(h.bitwiseOR)) for (; Z(h.bitwiseOR); ) fg();
  })();
}
function m0() {
  for (; !L(h.braceL) && !k.error; ) E_(), Z(h.comma);
}
function E_() {
  hi(), L(h.lessThan) && hn();
}
function w_() {
  if (L(h.string) ? un() : _e(), Z(h.eq)) {
    const e = k.tokens.length - 1;
    xt(), k.tokens[e].rhsEndIndex = k.tokens.length;
  }
}
function bu() {
  for (ts(!1), te(h.braceL); !Z(h.braceR) && !k.error; ) w_(), Z(h.comma);
}
function Tu() {
  te(h.braceL), Xa(h.braceR);
}
function Pp() {
  ts(!1), Z(h.dot) ? Pp() : Tu();
}
function g0() {
  be(B._global) ? _e() : L(h.string) ? is() : Ae(), L(h.braceL) ? Tu() : Ke();
}
function Ap() {
  Jo(), te(h.eq), be(B._require) && Ze() === h.parenL ? (st(B._require), te(h.parenL), L(h.string) || Ae(), un(), te(h.parenR)) : hi(), Ke();
}
function gg() {
  return ea(k.contextualKeyword, !0);
}
function __(e) {
  switch (e) {
    case B._declare: {
      const t = k.tokens.length - 1;
      if ((function() {
        if (vr()) return !1;
        switch (k.type) {
          case h._function: {
            const n = Ie(1);
            return re(), Is(k.start, !0), Ce(n), !0;
          }
          case h._class: {
            const n = Ie(1);
            return Ss(!0, !1), Ce(n), !0;
          }
          case h._const:
            if (L(h._const) && du(B._enum)) {
              const n = Ie(1);
              return te(h._const), st(B._enum), k.tokens[k.tokens.length - 1].type = h._enum, bu(), Ce(n), !0;
            }
          case h._var:
          case h._let: {
            const n = Ie(1);
            return ko(k.type !== h._var), Ce(n), !0;
          }
          case h.name: {
            const n = Ie(1), i = k.contextualKeyword;
            let o = !1;
            return i === B._global ? (g0(), o = !0) : o = ea(i, !0), Ce(n), o;
          }
          default:
            return !1;
        }
      })()) return k.tokens[t].type = h._declare, !0;
      break;
    }
    case B._global:
      if (L(h.braceL)) return Tu(), !0;
      break;
    default:
      return ea(e, !1);
  }
  return !1;
}
function ea(e, t) {
  switch (e) {
    case B._abstract:
      if ($s(t) && L(h._class)) return k.tokens[k.tokens.length - 1].type = h._abstract, Ss(!0, !1), !0;
      break;
    case B._enum:
      if ($s(t) && L(h.name)) return k.tokens[k.tokens.length - 1].type = h._enum, bu(), !0;
      break;
    case B._interface:
      if ($s(t) && L(h.name)) {
        const s = Ie(t ? 2 : 1);
        return ts(!1), As(), Z(h._extends) && m0(), f0(), Ce(s), !0;
      }
      break;
    case B._module:
      if ($s(t)) {
        if (L(h.string)) {
          const s = Ie(t ? 2 : 1);
          return g0(), Ce(s), !0;
        }
        if (L(h.name)) {
          const s = Ie(t ? 2 : 1);
          return Pp(), Ce(s), !0;
        }
      }
      break;
    case B._namespace:
      if ($s(t) && L(h.name)) {
        const s = Ie(t ? 2 : 1);
        return Pp(), Ce(s), !0;
      }
      break;
    case B._type:
      if ($s(t) && L(h.name)) {
        const s = Ie(t ? 2 : 1);
        return ts(!1), As(), te(h.eq), et(), Ke(), Ce(s), !0;
      }
  }
  return !1;
}
function $s(e) {
  return e ? (re(), !0) : !vr();
}
function P_() {
  const e = k.snapshot();
  return Qo(), bn(), L(h.colon) && Wa(h.colon), te(h.arrow), k.error ? (k.restoreFromSnapshot(e), !1) : (Xn(!0), !0);
}
function vu() {
  k.type === h.bitShiftL && (k.pos -= 1, Ne(h.lessThan)), hn();
}
function hn() {
  const e = Ie(0);
  for (te(h.lessThan); !L(h.greaterThan) && !k.error; ) et(), Z(h.comma);
  e ? (te(h.greaterThan), Ce(e)) : (Ce(e), r0(), te(h.greaterThan), k.tokens[k.tokens.length - 1].isType = !0);
}
function yg() {
  if (L(h.name)) switch (k.contextualKeyword) {
    case B._abstract:
    case B._declare:
    case B._enum:
    case B._interface:
    case B._module:
    case B._namespace:
    case B._type:
      return !0;
  }
  return !1;
}
function A_(e, t) {
  return Va ? (function(s, n) {
    if (!L(h.lessThan)) return fr(s, n);
    const i = k.snapshot();
    let o = fr(s, n);
    return k.error && (k.restoreFromSnapshot(i), k.type = h.typeParameterStart, Qo(), o = fr(s, n), o || Ae()), o;
  })(e, t) : (function(s, n) {
    if (!L(h.lessThan)) return fr(s, n);
    const i = k.snapshot();
    Qo();
    const o = fr(s, n);
    return o || Ae(), k.error ? (k.restoreFromSnapshot(i), fr(s, n)) : o;
  })(e, t);
}
function Cp() {
  Qt();
}
function y0(e) {
  Cp(), Z(h.colon) ? Cp() : k.tokens[k.tokens.length - 1].identifierRole = e;
}
function x0() {
  const e = k.tokens.length;
  y0(ke.Access);
  let t = !1;
  for (; L(h.dot); ) t = !0, Qt(), Cp();
  if (!t) {
    const s = k.tokens[e], n = he.charCodeAt(s.start);
    n >= V.lowercaseA && n <= V.lowercaseZ && (s.identifierRole = null);
  }
}
function C_() {
  switch (k.type) {
    case h.braceL:
      return re(), mt(), void Qt();
    case h.jsxTagStart:
      return T0(), void Qt();
    case h.string:
      return void Qt();
    default:
      Ae("JSX value should be either an expression or a quoted JSX text");
  }
}
function I_() {
  te(h.ellipsis), mt();
}
function N_(e) {
  if (L(h.jsxTagEnd)) return !1;
  x0(), Le && (function() {
    if (Z(h.jsxTagStart)) {
      k.tokens[k.tokens.length - 1].type = h.typeParameterStart;
      const n = Ie(1);
      for (; !L(h.greaterThan) && !k.error; ) et(), Z(h.comma);
      Qt(), Ce(n);
    }
  })();
  let t = !1;
  for (; !L(h.slash) && !L(h.jsxTagEnd) && !k.error; ) Z(h.braceL) ? (t = !0, te(h.ellipsis), xt(), Qt()) : (t && k.end - k.start === 3 && he.charCodeAt(k.start) === V.lowercaseK && he.charCodeAt(k.start + 1) === V.lowercaseE && he.charCodeAt(k.start + 2) === V.lowercaseY && (k.tokens[e].jsxRole = ir.KeyAfterPropSpread), y0(ke.ObjectKey), L(h.eq) && (Qt(), C_()));
  const s = L(h.slash);
  return s && Qt(), s;
}
function O_() {
  L(h.jsxTagEnd) || x0();
}
function b0() {
  const e = k.tokens.length - 1;
  k.tokens[e].jsxRole = ir.NoChildren;
  let t = 0;
  if (!N_(e)) for (qs(); ; ) switch (k.type) {
    case h.jsxTagStart:
      if (Qt(), L(h.slash)) return Qt(), O_(), void (k.tokens[e].jsxRole !== ir.KeyAfterPropSpread && (t === 1 ? k.tokens[e].jsxRole = ir.OneChild : t > 1 && (k.tokens[e].jsxRole = ir.StaticChildren)));
      t++, b0(), qs();
      break;
    case h.jsxText:
      t++, qs();
      break;
    case h.jsxEmptyText:
      qs();
      break;
    case h.braceL:
      re(), L(h.ellipsis) ? (I_(), qs(), t += 2) : (L(h.braceR) || (t++, mt()), qs());
      break;
    default:
      return void Ae();
  }
}
function T0() {
  Qt(), b0();
}
function Qt() {
  k.tokens.push(new Ha()), e0(), k.start = k.pos;
  const e = he.charCodeAt(k.pos);
  if (wi[e]) (function() {
    let t;
    do {
      if (k.pos > he.length) return void Ae("Unexpectedly reached the end of input.");
      t = he.charCodeAt(++k.pos);
    } while (cr[t] || t === V.dash);
    Ne(h.jsxName);
  })();
  else if (e === V.quotationMark || e === V.apostrophe) (function(t) {
    for (k.pos++; ; ) {
      if (k.pos >= he.length) return void Ae("Unterminated string constant");
      if (he.charCodeAt(k.pos) === t) {
        k.pos++;
        break;
      }
      k.pos++;
    }
    Ne(h.string);
  })(e);
  else switch (++k.pos, e) {
    case V.greaterThan:
      Ne(h.jsxTagEnd);
      break;
    case V.lessThan:
      Ne(h.jsxTagStart);
      break;
    case V.slash:
      Ne(h.slash);
      break;
    case V.equalsTo:
      Ne(h.eq);
      break;
    case V.leftCurlyBrace:
      Ne(h.braceL);
      break;
    case V.dot:
      Ne(h.dot);
      break;
    case V.colon:
      Ne(h.colon);
      break;
    default:
      Ae();
  }
}
function qs() {
  k.tokens.push(new Ha()), k.start = k.pos, (function() {
    let e = !1, t = !1;
    for (; ; ) {
      if (k.pos >= he.length) return void Ae("Unterminated JSX contents");
      const s = he.charCodeAt(k.pos);
      if (s === V.lessThan || s === V.leftCurlyBrace) return k.pos === k.start ? s === V.lessThan ? (k.pos++, void Ne(h.jsxTagStart)) : void s0(s) : void Ne(e && !t ? h.jsxEmptyText : h.jsxText);
      s === V.lineFeed ? e = !0 : s !== V.space && s !== V.carriageReturn && s !== V.tab && (t = !0), k.pos++;
    }
  })();
}
(function(e) {
  e[e.TSFunctionType = 0] = "TSFunctionType", e[e.TSConstructorType = 1] = "TSConstructorType", e[e.TSAbstractConstructorType = 2] = "TSAbstractConstructorType";
})(Jr || (Jr = {}));
class L_ {
  constructor(t) {
    this.stop = t;
  }
}
function mt(e = !1) {
  if (xt(e), L(h.comma)) for (; Z(h.comma); ) xt(e);
}
function xt(e = !1, t = !1) {
  return Le ? A_(e, t) : je ? (function(s, n) {
    if (L(h.lessThan)) {
      const i = k.snapshot();
      let o = fr(s, n);
      if (!k.error) return o;
      k.restoreFromSnapshot(i), k.type = h.typeParameterStart;
      const c = Ie(0);
      if (pr(), Ce(c), o = fr(s, n), o) return !0;
      Ae();
    }
    return fr(s, n);
  })(e, t) : fr(e, t);
}
function fr(e, t) {
  if (L(h._yield)) return re(), L(h.semi) || zt() || (Z(h.star), xt()), !1;
  (L(h.parenL) || L(h.name) || L(h._yield)) && (k.potentialArrowAt = k.start);
  const s = (function(n) {
    return (function(o) {
      const c = k.tokens.length;
      return ui() ? !0 : (bo(c, -1, o), !1);
    })(n) ? !0 : ((function(o) {
      Le || je ? (function(c) {
        if (L(h.question)) {
          const l = Ze();
          if (l === h.colon || l === h.comma || l === h.parenR) return;
        }
        xg(c);
      })(o) : xg(o);
    })(n), !1);
  })(e);
  return t && Su(), k.type & h.IS_ASSIGN ? (re(), xt(e), !1) : s;
}
function xg(e) {
  Z(h.question) && (xt(), te(h.colon), xt(e));
}
function bo(e, t, s) {
  if (Le && (h._in & h.PRECEDENCE_MASK) > t && !Lt() && (lt(B._as) || lt(B._satisfies))) {
    const i = Ie(1);
    return et(), Ce(i), r0(), void bo(e, t, s);
  }
  const n = k.type & h.PRECEDENCE_MASK;
  if (n > 0 && (!s || !L(h._in)) && n > t) {
    const i = k.type;
    re(), i === h.nullishCoalescing && (k.tokens[k.tokens.length - 1].nullishStartIndex = e);
    const o = k.tokens.length;
    ui(), bo(o, i & h.IS_RIGHT_ASSOCIATIVE ? n - 1 : n, s), i === h.nullishCoalescing && (k.tokens[e].numNullishCoalesceStarts++, k.tokens[k.tokens.length - 1].numNullishCoalesceEnds++), bo(e, t, s);
  }
}
function ui() {
  if (Le && !Va && Z(h.lessThan)) return (function() {
    const e = Ie(1);
    et(), te(h.greaterThan), Ce(e), ui();
  })(), !1;
  if (be(B._module) && Yb() === V.leftCurlyBrace && !Hb()) return st(B._module), te(h.braceL), Xa(h.braceR), !1;
  if (k.type & h.IS_PREFIX) return re(), ui(), !1;
  if (v0()) return !0;
  for (; k.type & h.IS_POSTFIX && !zt(); ) k.type === h.preIncDec && (k.type = h.postIncDec), re();
  return !1;
}
function v0() {
  const e = k.tokens.length;
  return !!is() || (ku(e), k.tokens.length > e && k.tokens[e].isOptionalChainStart && (k.tokens[k.tokens.length - 1].isOptionalChainEnd = !0), !1);
}
function ku(e, t = !1) {
  je ? (function(s, n = !1) {
    if (k.tokens[k.tokens.length - 1].contextualKeyword === B._async && L(h.lessThan)) {
      const i = k.snapshot();
      if ((function() {
        k.scopeDepth++;
        const c = k.tokens.length;
        return bn(), Np() ? (fi(c), !0) : !1;
      })() && !k.error) return;
      k.restoreFromSnapshot(i);
    }
    bg(s, n);
  })(e, t) : bg(e, t);
}
function bg(e, t = !1) {
  const s = new L_(!1);
  do
    R_(e, t, s);
  while (!s.stop && !k.error);
}
function R_(e, t, s) {
  Le ? (function(n, i, o) {
    if (Lt() || !Z(h.bang)) {
      if (L(h.lessThan) || L(h.bitShiftL)) {
        const c = k.snapshot();
        if (!i && k0() && P_() || (vu(), !i && Z(h.parenL) ? (k.tokens[k.tokens.length - 1].subscriptStartIndex = n, Xr()) : L(h.backQuote) ? Eu() : (k.type === h.greaterThan || k.type !== h.parenL && k.type & h.IS_EXPRESSION_START && !Lt()) && Ae(), !k.error)) return;
        k.restoreFromSnapshot(c);
      } else !i && L(h.questionDot) && Ze() === h.lessThan && (re(), k.tokens[n].isOptionalChainStart = !0, k.tokens[k.tokens.length - 1].subscriptStartIndex = n, hn(), te(h.parenL), Xr());
      jl(n, i, o);
    } else k.tokens[k.tokens.length - 1].type = h.nonNullAssertion;
  })(e, t, s) : je ? (function(n, i, o) {
    if (L(h.questionDot) && Ze() === h.lessThan) return i ? void (o.stop = !0) : (re(), Cs(), te(h.parenL), void Xr());
    if (!i && L(h.lessThan)) {
      const c = k.snapshot();
      if (Cs(), te(h.parenL), Xr(), !k.error) return;
      k.restoreFromSnapshot(c);
    }
    jl(n, i, o);
  })(e, t, s) : jl(e, t, s);
}
function jl(e, t, s) {
  if (!t && Z(h.doubleColon)) Ip(), s.stop = !0, ku(e, t);
  else if (L(h.questionDot)) {
    if (k.tokens[e].isOptionalChainStart = !0, t && Ze() === h.parenL) return void (s.stop = !0);
    re(), k.tokens[k.tokens.length - 1].subscriptStartIndex = e, Z(h.bracketL) ? (mt(), te(h.bracketR)) : Z(h.parenL) ? Xr() : ta();
  } else if (Z(h.dot)) k.tokens[k.tokens.length - 1].subscriptStartIndex = e, ta();
  else if (Z(h.bracketL)) k.tokens[k.tokens.length - 1].subscriptStartIndex = e, mt(), te(h.bracketR);
  else if (!t && L(h.parenL)) if (k0()) {
    const n = k.snapshot(), i = k.tokens.length;
    re(), k.tokens[k.tokens.length - 1].subscriptStartIndex = e;
    const o = li();
    k.tokens[k.tokens.length - 1].contextId = o, Xr(), k.tokens[k.tokens.length - 1].contextId = o, (L(h.colon) || L(h.arrow)) && (k.restoreFromSnapshot(n), s.stop = !0, k.scopeDepth++, bn(), (function(c) {
      Le ? L(h.colon) && Pi() : je && (function() {
        if (L(h.colon)) {
          const l = k.noAnonFunctionType;
          k.noAnonFunctionType = !0, Ms(), k.noAnonFunctionType = l;
        }
      })(), te(h.arrow), fi(c);
    })(i));
  } else {
    re(), k.tokens[k.tokens.length - 1].subscriptStartIndex = e;
    const n = li();
    k.tokens[k.tokens.length - 1].contextId = n, Xr(), k.tokens[k.tokens.length - 1].contextId = n;
  }
  else L(h.backQuote) ? Eu() : s.stop = !0;
}
function k0() {
  return k.tokens[k.tokens.length - 1].contextualKeyword === B._async && !zt();
}
function Xr() {
  let e = !0;
  for (; !Z(h.parenR) && !k.error; ) {
    if (e) e = !1;
    else if (te(h.comma), Z(h.parenR)) break;
    w0(!1);
  }
}
function Ip() {
  const e = k.tokens.length;
  is(), ku(e, !0);
}
function is() {
  if (Z(h.modulo)) return _e(), !1;
  if (L(h.jsxText) || L(h.jsxEmptyText)) return un(), !1;
  if (L(h.lessThan) && Va) return k.type = h.jsxTagStart, T0(), re(), !1;
  const e = k.potentialArrowAt === k.start;
  switch (k.type) {
    case h.slash:
    case h.assign:
      Qw();
    case h._super:
    case h._this:
    case h.regexp:
    case h.num:
    case h.bigint:
    case h.decimal:
    case h.string:
    case h._null:
    case h._true:
    case h._false:
      return re(), !1;
    case h._import:
      return re(), L(h.dot) && (k.tokens[k.tokens.length - 1].type = h.name, re(), _e()), !1;
    case h.name: {
      const t = k.tokens.length, s = k.start, n = k.contextualKeyword;
      return _e(), n === B._await ? (ui(), !1) : n === B._async && L(h._function) && !zt() ? (re(), Is(s, !1), !1) : e && n === B._async && !zt() && L(h.name) ? (k.scopeDepth++, ts(!1), te(h.arrow), fi(t), !0) : L(h._do) && !zt() ? (re(), Kr(), !1) : e && !zt() && L(h.arrow) ? (k.scopeDepth++, gu(!1), te(h.arrow), fi(t), !0) : (k.tokens[k.tokens.length - 1].identifierRole = ke.Access, !1);
    }
    case h._do:
      return re(), Kr(), !1;
    case h.parenL:
      return S0(e);
    case h.bracketL:
      return re(), Tg(h.bracketR, !0), !1;
    case h.braceL:
      return wu(!1, !1), !1;
    case h._function:
      return (function() {
        const t = k.start;
        _e(), Z(h.dot) && _e(), Is(t, !1);
      })(), !1;
    case h.at:
      Ou();
    case h._class:
      return Ss(!1), !1;
    case h._new:
      return (function() {
        if (te(h._new), Z(h.dot)) return void _e();
        Ip(), Z(h.questionDot), je && (function() {
          if (L(h.lessThan)) {
            const t = k.snapshot();
            Cs(), k.error && k.restoreFromSnapshot(t);
          }
        })(), Z(h.parenL) && Tg(h.parenR);
      })(), !1;
    case h.backQuote:
      return Eu(), !1;
    case h.doubleColon:
      return re(), Ip(), !1;
    case h.hash: {
      const t = Yb();
      return wi[t] || t === V.backslash ? ta() : re(), !1;
    }
    default:
      return Ae(), !1;
  }
}
function ta() {
  Z(h.hash), _e();
}
function un() {
  re();
}
function ro() {
  te(h.parenL), mt(), te(h.parenR);
}
function S0(e) {
  const t = k.snapshot(), s = k.tokens.length;
  te(h.parenL);
  let n = !0;
  for (; !L(h.parenR) && !k.error; ) {
    if (n) n = !1;
    else if (te(h.comma), L(h.parenR)) break;
    if (L(h.ellipsis)) {
      l0(!1), Su();
      break;
    }
    xt(!1, !0);
  }
  return te(h.parenR), e && (L(h.colon) || !zt()) && Np() ? (k.restoreFromSnapshot(t), k.scopeDepth++, bn(), Np(), fi(s), !k.error || (k.restoreFromSnapshot(t), S0(!1), !1)) : !1;
}
function Np() {
  return Le ? (function() {
    if (L(h.colon)) {
      const e = k.snapshot();
      Wa(h.colon), zt() && Ae(), L(h.arrow) || Ae(), k.error && k.restoreFromSnapshot(e);
    }
    return Z(h.arrow);
  })() : je ? (function() {
    if (L(h.colon)) {
      const e = Ie(0), t = k.snapshot(), s = k.noAnonFunctionType;
      k.noAnonFunctionType = !0, _u(), k.noAnonFunctionType = s, zt() && Ae(), L(h.arrow) || Ae(), k.error && k.restoreFromSnapshot(t), Ce(e);
    }
    return Z(h.arrow);
  })() : Z(h.arrow);
}
function Su() {
  (Le || je) && (Kb(h.question), L(h.colon) && (Le ? Pi() : je && Ms()));
}
function Eu() {
  for (Gr(), Gr(); !L(h.backQuote) && !k.error; ) te(h.dollarBraceL), mt(), Gr(), Gr();
  re();
}
function wu(e, t) {
  const s = li();
  let n = !0;
  for (re(), k.tokens[k.tokens.length - 1].contextId = s; !Z(h.braceR) && !k.error; ) {
    if (n) n = !1;
    else if (te(h.comma), Z(h.braceR)) break;
    let i = !1;
    if (L(h.ellipsis)) {
      const o = k.tokens.length;
      if (c0(), e && (k.tokens.length === o + 2 && gu(t), Z(h.braceR))) break;
      continue;
    }
    e || (i = Z(h.star)), !e && be(B._async) ? (i && Ae(), _e(), L(h.colon) || L(h.parenL) || L(h.braceR) || L(h.eq) || L(h.comma) || (L(h.star) && (re(), i = !0), di(s))) : di(s), D_(e, t, s);
  }
  k.tokens[k.tokens.length - 1].contextId = s;
}
function M_(e, t) {
  const s = k.start;
  return L(h.parenL) ? (e && Ae(), Op(s, !1), !0) : !!(function(n) {
    return !n && (L(h.string) || L(h.num) || L(h.bracketL) || L(h.name) || !!(k.type & h.IS_KEYWORD));
  })(e) && (di(t), Op(s, !1), !0);
}
function D_(e, t, s) {
  Le ? As() : je && L(h.lessThan) && (pr(), L(h.parenL) || Ae()), M_(e, s) || (function(n, i) {
    if (Z(h.colon)) return void (n ? Yo(i) : xt(!1));
    let o;
    o = n ? k.scopeDepth === 0 ? ke.ObjectShorthandTopLevelDeclaration : i ? ke.ObjectShorthandBlockScopedDeclaration : ke.ObjectShorthandFunctionScopedDeclaration : ke.ObjectShorthand, k.tokens[k.tokens.length - 1].identifierRole = o, Yo(i, !0);
  })(e, t);
}
function di(e) {
  je && Nu(), Z(h.bracketL) ? (k.tokens[k.tokens.length - 1].contextId = e, xt(), te(h.bracketR), k.tokens[k.tokens.length - 1].contextId = e) : (L(h.num) || L(h.string) || L(h.bigint) || L(h.decimal) ? is() : ta(), k.tokens[k.tokens.length - 1].identifierRole = ke.ObjectKey, k.tokens[k.tokens.length - 1].contextId = e);
}
function Op(e, t) {
  const s = li();
  k.scopeDepth++;
  const n = k.tokens.length;
  bn(t, s), E0(e, s);
  const i = k.tokens.length;
  k.scopes.push(new Er(n, i, !0)), k.scopeDepth--;
}
function fi(e) {
  Xn(!0);
  const t = k.tokens.length;
  k.scopes.push(new Er(e, t, !0)), k.scopeDepth--;
}
function E0(e, t = 0) {
  Le ? (function(s, n) {
    if (L(h.colon) && Wa(h.colon), !L(h.braceL) && vr()) {
      let i = k.tokens.length - 1;
      for (; i >= 0 && (k.tokens[i].start >= s || k.tokens[i].type === h._default || k.tokens[i].type === h._export); ) k.tokens[i].isType = !0, i--;
      return;
    }
    Xn(!1, n);
  })(e, t) : je ? (function(s) {
    L(h.colon) && _u(), Xn(!1, s);
  })(t) : Xn(!1, t);
}
function Xn(e, t = 0) {
  e && !L(h.braceL) ? xt() : Kr(!0, t);
}
function Tg(e, t = !1) {
  let s = !0;
  for (; !Z(e) && !k.error; ) {
    if (s) s = !1;
    else if (te(h.comma), Z(e)) break;
    w0(t);
  }
}
function w0(e) {
  e && L(h.comma) || (L(h.ellipsis) ? (c0(), Su()) : L(h.question) ? re() : xt(!1, !0));
}
function _e() {
  re(), k.tokens[k.tokens.length - 1].type = h.name;
}
function wr(e) {
  const t = Ie(0);
  te(e || h.colon), Bt(), Ce(t);
}
function vg() {
  te(h.modulo), st(B._checks), Z(h.parenL) && (mt(), te(h.parenR));
}
function _u() {
  const e = Ie(0);
  te(h.colon), L(h.modulo) ? vg() : (Bt(), L(h.modulo) && vg()), Ce(e);
}
function Lp() {
  L(h._class) ? (re(), Rp(!0)) : L(h._function) ? (re(), _e(), L(h.lessThan) && pr(), te(h.parenL), Dp(), te(h.parenR), _u(), Ke()) : L(h._var) ? (re(), C0(), Ke()) : lt(B._module) ? Z(h.dot) ? (st(B._exports), Ms(), Ke()) : (function() {
    for (L(h.string) ? is() : _e(), te(h.braceL); !L(h.braceR) && !k.error; ) L(h._import) ? (re(), M0()) : Ae();
    te(h.braceR);
  })() : be(B._type) ? (re(), Pu()) : be(B._opaque) ? (re(), Au(!0)) : be(B._interface) ? (re(), Rp()) : L(h._export) ? (te(h._export), Z(h._default) ? L(h._function) || L(h._class) ? Lp() : (Bt(), Ke()) : L(h._var) || L(h._function) || L(h._class) || be(B._opaque) ? Lp() : L(h.star) || L(h.braceL) || be(B._interface) || be(B._type) || be(B._opaque) ? L0() : Ae()) : Ae();
}
function Rp(e = !1) {
  if (Ga(), L(h.lessThan) && pr(), Z(h._extends)) do
    To();
  while (!e && Z(h.comma));
  if (be(B._mixins)) {
    re();
    do
      To();
    while (Z(h.comma));
  }
  if (be(B._implements)) {
    re();
    do
      To();
    while (Z(h.comma));
  }
  vo(e, !1, e);
}
function To() {
  _0(!1), L(h.lessThan) && Cs();
}
function Mp() {
  Rp();
}
function Ga() {
  _e();
}
function Pu() {
  Ga(), L(h.lessThan) && pr(), wr(h.eq), Ke();
}
function Au(e) {
  st(B._type), Ga(), L(h.lessThan) && pr(), L(h.colon) && wr(h.colon), e || wr(h.eq), Ke();
}
function F_() {
  Nu(), C0(), Z(h.eq) && Bt();
}
function pr() {
  const e = Ie(0);
  L(h.lessThan) || L(h.typeParameterStart) ? re() : Ae();
  do
    F_(), L(h.greaterThan) || te(h.comma);
  while (!L(h.greaterThan) && !k.error);
  te(h.greaterThan), Ce(e);
}
function Cs() {
  const e = Ie(0);
  for (te(h.lessThan); !L(h.greaterThan) && !k.error; ) Bt(), L(h.greaterThan) || te(h.comma);
  te(h.greaterThan), Ce(e);
}
function Cu() {
  L(h.num) || L(h.string) ? is() : _e();
}
function j_() {
  Ze() === h.colon ? (Cu(), wr()) : Bt(), te(h.bracketR), wr();
}
function B_() {
  Cu(), te(h.bracketR), te(h.bracketR), L(h.lessThan) || L(h.parenL) ? Iu() : (Z(h.question), wr());
}
function Iu() {
  for (L(h.lessThan) && pr(), te(h.parenL); !L(h.parenR) && !L(h.ellipsis) && !k.error; ) ra(), L(h.parenR) || te(h.comma);
  Z(h.ellipsis) && ra(), te(h.parenR), wr();
}
function U_() {
  Iu();
}
function vo(e, t, s) {
  let n;
  for (t && L(h.braceBarL) ? (te(h.braceBarL), n = h.braceBarR) : (te(h.braceL), n = h.braceR); !L(n) && !k.error; ) {
    if (s && be(B._proto)) {
      const i = Ze();
      i !== h.colon && i !== h.question && (re(), e = !1);
    }
    if (e && be(B._static)) {
      const i = Ze();
      i !== h.colon && i !== h.question && re();
    }
    if (Nu(), Z(h.bracketL)) Z(h.bracketL) ? B_() : j_();
    else if (L(h.parenL) || L(h.lessThan)) U_();
    else {
      if (be(B._get) || be(B._set)) {
        const i = Ze();
        i !== h.name && i !== h.string && i !== h.num || re();
      }
      $_();
    }
    q_();
  }
  te(n);
}
function $_() {
  if (L(h.ellipsis)) {
    if (te(h.ellipsis), Z(h.comma) || Z(h.semi), L(h.braceR)) return;
    Bt();
  } else Cu(), L(h.lessThan) || L(h.parenL) ? Iu() : (Z(h.question), wr());
}
function q_() {
  Z(h.semi) || Z(h.comma) || L(h.braceR) || L(h.braceBarR) || Ae();
}
function _0(e) {
  for (e || _e(); Z(h.dot); ) _e();
}
function ra() {
  const e = Ze();
  e === h.colon || e === h.question ? (_e(), Z(h.question), wr()) : Bt();
}
function Dp() {
  for (; !L(h.parenR) && !L(h.ellipsis) && !k.error; ) ra(), L(h.parenR) || te(h.comma);
  Z(h.ellipsis) && ra();
}
function P0() {
  let e = !1;
  const t = k.noAnonFunctionType;
  switch (k.type) {
    case h.name:
      return be(B._interface) ? void (function() {
        if (st(B._interface), Z(h._extends)) do
          To();
        while (Z(h.comma));
        vo(!1, !1, !1);
      })() : (_e(), _0(!0), void (L(h.lessThan) && Cs()));
    case h.braceL:
      return void vo(!1, !1, !1);
    case h.braceBarL:
      return void vo(!1, !0, !1);
    case h.bracketL:
      return void (function() {
        for (te(h.bracketL); k.pos < he.length && !L(h.bracketR) && (Bt(), !L(h.bracketR)); ) te(h.comma);
        te(h.bracketR);
      })();
    case h.lessThan:
      return pr(), te(h.parenL), Dp(), te(h.parenR), te(h.arrow), void Bt();
    case h.parenL:
      if (re(), !L(h.parenR) && !L(h.ellipsis)) if (L(h.name)) {
        const s = Ze();
        e = s !== h.question && s !== h.colon;
      } else e = !0;
      if (e) {
        if (k.noAnonFunctionType = !1, Bt(), k.noAnonFunctionType = t, k.noAnonFunctionType || !(L(h.comma) || L(h.parenR) && Ze() === h.arrow)) return void te(h.parenR);
        Z(h.comma);
      }
      return Dp(), te(h.parenR), te(h.arrow), void Bt();
    case h.minus:
      return re(), void un();
    case h.string:
    case h.num:
    case h._true:
    case h._false:
    case h._null:
    case h._this:
    case h._void:
    case h.star:
      return void re();
    default:
      if (k.type === h._typeof) return te(h._typeof), void P0();
      if (k.type & h.IS_KEYWORD) return re(), void (k.tokens[k.tokens.length - 1].type = h.name);
  }
  Ae();
}
function A0() {
  Z(h.question) ? A0() : (function() {
    for (P0(); !zt() && (L(h.bracketL) || L(h.questionDot)); ) Z(h.questionDot), te(h.bracketL), Z(h.bracketR) || (Bt(), te(h.bracketR));
  })();
}
function kg() {
  A0(), !k.noAnonFunctionType && Z(h.arrow) && Bt();
}
function Sg() {
  for (Z(h.bitwiseAND), kg(); Z(h.bitwiseAND); ) kg();
}
function Bt() {
  (function() {
    for (Z(h.bitwiseOR), Sg(); Z(h.bitwiseOR); ) Sg();
  })();
}
function Ms() {
  wr();
}
function C0() {
  _e(), L(h.colon) && Ms();
}
function Nu() {
  (L(h.plus) || L(h.minus)) && (re(), k.tokens[k.tokens.length - 1].isType = !0);
}
function V_() {
  if (L(h._typeof) || be(B._type)) {
    const t = _i();
    (((e = t).type === h.name || e.type & h.IS_KEYWORD) && e.contextualKeyword !== B._from || t.type === h.braceL || t.type === h.star) && re();
  }
  var e;
}
function I0() {
  st(B._enum), k.tokens[k.tokens.length - 1].type = h._enum, _e(), (function() {
    lt(B._of) && re(), te(h.braceL), (function() {
      for (; !L(h.braceR) && !k.error && !Z(h.ellipsis); ) H_(), L(h.braceR) || te(h.comma);
    })(), te(h.braceR);
  })();
}
function H_() {
  _e(), Z(h.eq) && re();
}
function Ht(e) {
  je && (function() {
    if (L(h.name) && k.contextualKeyword === B._interface) {
      const t = Ie(0);
      return re(), Mp(), Ce(t), !0;
    }
    return !!be(B._enum) && (I0(), !0);
  })() || (L(h.at) && Ou(), (function(t) {
    if (Le && (function() {
      if (k.type === h._const) {
        const c = _i();
        if (c.type === h.name && c.contextualKeyword === B._enum) return te(h._const), st(B._enum), k.tokens[k.tokens.length - 1].type = h._enum, bu(), !0;
      }
      return !1;
    })()) return;
    const s = k.type;
    switch (s) {
      case h._break:
      case h._continue:
        return re(), void (vr() || (_e(), Ke()));
      case h._debugger:
        return re(), void Ke();
      case h._do:
        return re(), Ht(!1), te(h._while), ro(), void Z(h.semi);
      case h._for:
        return void (function() {
          k.scopeDepth++;
          const c = k.tokens.length;
          (function() {
            re();
            let p = !1;
            if (be(B._await) && (p = !0, re()), te(h.parenL), L(h.semi)) return p && Ae(), void Bl();
            const d = Eg();
            if (d || L(h._var) || L(h._let) || L(h._const) || (function() {
              return !(!be(B._using) || du(B._of));
            })()) return d && st(B._await), re(), O0(!0, k.type !== h._var), L(h._in) || be(B._of) ? void _g(p) : void Bl();
            if (mt(!0), L(h._in) || be(B._of)) return void _g(p);
            p && Ae(), Bl();
          })();
          const l = k.tokens.length;
          k.scopes.push(new Er(c, l, !1)), k.scopeDepth--;
        })();
      case h._function:
        if (Ze() === h.dot) break;
        return t || Ae(), void (function() {
          const c = k.start;
          re(), Is(c, !0);
        })();
      case h._class:
        return t || Ae(), void Ss(!0);
      case h._if:
        return re(), ro(), Ht(!1), void (Z(h._else) && Ht(!1));
      case h._return:
        return re(), void (vr() || (mt(), Ke()));
      case h._switch:
        return void (function() {
          re(), ro(), k.scopeDepth++;
          const c = k.tokens.length;
          for (te(h.braceL); !L(h.braceR) && !k.error; ) if (L(h._case) || L(h._default)) {
            const p = L(h._case);
            re(), p && mt(), te(h.colon);
          } else Ht(!0);
          re();
          const l = k.tokens.length;
          k.scopes.push(new Er(c, l, !1)), k.scopeDepth--;
        })();
      case h._throw:
        return re(), mt(), void Ke();
      case h._try:
        return void (function() {
          if (re(), Kr(), L(h._catch)) {
            re();
            let c = null;
            if (L(h.parenL) && (k.scopeDepth++, c = k.tokens.length, te(h.parenL), za(!0), Le && xn(), te(h.parenR)), Kr(), c != null) {
              const l = k.tokens.length;
              k.scopes.push(new Er(c, l, !1)), k.scopeDepth--;
            }
          }
          Z(h._finally) && Kr();
        })();
      case h._let:
      case h._const:
        t || Ae();
      case h._var:
        return void ko(s !== h._var);
      case h._while:
        return re(), ro(), void Ht(!1);
      case h.braceL:
        return void Kr();
      case h.semi:
        return void re();
      case h._export:
      case h._import: {
        const c = Ze();
        if (c === h.parenL || c === h.dot) break;
        return re(), void (s === h._import ? M0() : L0());
      }
      case h.name:
        if (k.contextualKeyword === B._async) {
          const c = k.start, l = k.snapshot();
          if (re(), L(h._function) && !zt()) return te(h._function), void Is(c, !0);
          k.restoreFromSnapshot(l);
        } else {
          if (k.contextualKeyword === B._using && !Hb() && Ze() === h.name) return void ko(!0);
          if (Eg()) return st(B._await), void ko(!0);
        }
    }
    const n = k.tokens.length;
    mt();
    let i = null;
    if (k.tokens.length === n + 1) {
      const c = k.tokens[k.tokens.length - 1];
      c.type === h.name && (i = c.contextualKeyword);
    }
    if (i == null) return void Ke();
    Z(h.colon) ? Ht(!0) : (o = i, Le ? (function(c) {
      __(c) || Ke();
    })(o) : je ? (function(c) {
      if (c === B._declare) {
        if (L(h._class) || L(h.name) || L(h._function) || L(h._var) || L(h._export)) {
          const l = Ie(1);
          Lp(), Ce(l);
        }
      } else if (L(h.name)) {
        if (c === B._interface) {
          const l = Ie(1);
          Mp(), Ce(l);
        } else if (c === B._type) {
          const l = Ie(1);
          Pu(), Ce(l);
        } else if (c === B._opaque) {
          const l = Ie(1);
          Au(!1), Ce(l);
        }
      }
      Ke();
    })(o) : Ke());
    var o;
  })(e));
}
function Eg() {
  if (!be(B._await)) return !1;
  const e = k.snapshot();
  return re(), !be(B._using) || Lt() ? (k.restoreFromSnapshot(e), !1) : (re(), !L(h.name) || Lt() ? (k.restoreFromSnapshot(e), !1) : (k.restoreFromSnapshot(e), !0));
}
function Ou() {
  for (; L(h.at); ) N0();
}
function N0() {
  if (re(), Z(h.parenL)) mt(), te(h.parenR);
  else {
    for (_e(); Z(h.dot); ) _e();
    Le && (L(h.lessThan) || L(h.bitShiftL)) && vu(), wg();
  }
}
function wg() {
  Z(h.parenL) && Xr();
}
function ko(e) {
  re(), O0(!1, e), Ke();
}
function Kr(e = !1, t = 0) {
  const s = k.tokens.length;
  k.scopeDepth++, te(h.braceL), t && (k.tokens[k.tokens.length - 1].contextId = t), Xa(h.braceR), t && (k.tokens[k.tokens.length - 1].contextId = t);
  const n = k.tokens.length;
  k.scopes.push(new Er(s, n, e)), k.scopeDepth--;
}
function Xa(e) {
  for (; !Z(e) && !k.error; ) Ht(!0);
}
function Bl() {
  te(h.semi), L(h.semi) || mt(), te(h.semi), L(h.parenR) || mt(), te(h.parenR), Ht(!1);
}
function _g(e) {
  e ? lt(B._of) : re(), mt(), te(h.parenR), Ht(!1);
}
function O0(e, t) {
  for (; ; ) {
    if (z_(t), Z(h.eq)) {
      const s = k.tokens.length - 1;
      xt(e), k.tokens[s].rhsEndIndex = k.tokens.length;
    }
    if (!Z(h.comma)) break;
  }
}
function z_(e) {
  za(e), Le ? (function() {
    const t = Ie(0);
    Lt() || Z(h.bang), xn(), Ce(t);
  })() : je && L(h.colon) && Ms();
}
function Is(e, t, s = !1) {
  L(h.star) && re(), !t || s || L(h.name) || L(h._yield) || Ae();
  let n = null;
  L(h.name) && (t || (n = k.tokens.length, k.scopeDepth++), ts(!1));
  const i = k.tokens.length;
  k.scopeDepth++, bn(), E0(e);
  const o = k.tokens.length;
  k.scopes.push(new Er(i, o, !0)), k.scopeDepth--, n !== null && (k.scopes.push(new Er(n, o, !0)), k.scopeDepth--);
}
function bn(e = !1, t = 0) {
  Le ? As() : je && (function() {
    if (L(h.lessThan)) {
      const s = Ie(0);
      pr(), Ce(s);
    }
  })(), te(h.parenL), t && (k.tokens[k.tokens.length - 1].contextId = t), yu(h.parenR, !1, !1, e, t), t && (k.tokens[k.tokens.length - 1].contextId = t);
}
function Ss(e, t = !1) {
  const s = li();
  re(), k.tokens[k.tokens.length - 1].contextId = s, k.tokens[k.tokens.length - 1].isExpression = !e;
  let n = null;
  e || (n = k.tokens.length, k.scopeDepth++), (function(o, c = !1) {
    Le && (!o || c) && be(B._implements) || (L(h.name) && ts(!0), Le ? As() : je && L(h.lessThan) && pr());
  })(e, t), (function() {
    let o = !1;
    Z(h._extends) ? (v0(), o = !0) : o = !1, Le ? (function(c) {
      if (c && (L(h.lessThan) || L(h.bitShiftL)) && vu(), lt(B._implements)) {
        k.tokens[k.tokens.length - 1].type = h._implements;
        const l = Ie(1);
        m0(), Ce(l);
      }
    })(o) : je && (function(c) {
      if (c && L(h.lessThan) && Cs(), be(B._implements)) {
        const l = Ie(0);
        re(), k.tokens[k.tokens.length - 1].type = h._implements;
        do
          Ga(), L(h.lessThan) && Cs();
        while (Z(h.comma));
        Ce(l);
      }
    })(o);
  })();
  const i = k.tokens.length;
  if ((function(o) {
    for (te(h.braceL); !Z(h.braceR) && !k.error; )
      if (!Z(h.semi)) {
        if (L(h.at)) {
          N0();
          continue;
        }
        W_(k.start, o);
      }
  })(s), !k.error && (k.tokens[i].contextId = s, k.tokens[k.tokens.length - 1].contextId = s, n !== null)) {
    const o = k.tokens.length;
    k.scopes.push(new Er(n, o, !1)), k.scopeDepth--;
  }
}
function Pg() {
  return L(h.eq) || L(h.semi) || L(h.braceR) || L(h.bang) || L(h.colon);
}
function Ag() {
  return L(h.parenL) || L(h.lessThan);
}
function W_(e, t) {
  Le && wp([B._declare, B._public, B._protected, B._private, B._override]);
  let s = !1;
  if (L(h.name) && k.contextualKeyword === B._static) {
    if (_e(), Ag()) return void Ln(e, !1);
    if (Pg()) return void so();
    if (k.tokens[k.tokens.length - 1].type = h._static, s = !0, L(h.braceL)) return k.tokens[k.tokens.length - 1].contextId = t, void Kr();
  }
  (function(n, i, o) {
    if (Le && (function(p) {
      const d = k.tokens.length;
      wp([B._abstract, B._readonly, B._declare, B._static, B._override]);
      const g = k.tokens.length;
      if (d0()) {
        for (let f = p ? d - 1 : d; f < g; f++) k.tokens[f].isType = !0;
        return !0;
      }
      return !1;
    })(i)) return;
    if (Z(h.star)) return Rn(o), void Ln(n, !1);
    Rn(o);
    let c = !1;
    const l = k.tokens[k.tokens.length - 1];
    l.contextualKeyword === B._constructor && (c = !0), Cg(), Ag() ? Ln(n, c) : Pg() ? so() : l.contextualKeyword !== B._async || vr() ? l.contextualKeyword !== B._get && l.contextualKeyword !== B._set || vr() && L(h.star) ? l.contextualKeyword !== B._accessor || vr() ? vr() ? so() : Ae() : (Rn(o), so()) : (l.contextualKeyword === B._get ? k.tokens[k.tokens.length - 1].type = h._get : k.tokens[k.tokens.length - 1].type = h._set, Rn(o), Ln(n, !1)) : (k.tokens[k.tokens.length - 1].type = h._async, L(h.star) && re(), Rn(o), Cg(), Ln(n, !1));
  })(e, s, t);
}
function Ln(e, t) {
  Le ? As() : je && L(h.lessThan) && pr(), Op(e, t);
}
function Rn(e) {
  di(e);
}
function Cg() {
  if (Le) {
    const e = Ie(0);
    Z(h.question), Ce(e);
  }
}
function so() {
  if (Le ? (Kb(h.bang), xn()) : je && L(h.colon) && Ms(), L(h.eq)) {
    const e = k.tokens.length;
    re(), xt(), k.tokens[e].rhsEndIndex = k.tokens.length;
  }
  Ke();
}
function L0() {
  const e = k.tokens.length - 1;
  Le && (function() {
    if (Z(h._import)) return be(B._type) && Ze() !== h.eq && st(B._type), Ap(), !0;
    if (Z(h.eq)) return mt(), Ke(), !0;
    if (lt(B._as)) return st(B._namespace), _e(), Ke(), !0;
    if (be(B._type)) {
      const t = Ze();
      t !== h.braceL && t !== h.star || re();
    }
    return !1;
  })() || ((je ? L(h.star) || be(B._type) && Ze() === h.star : L(h.star)) ? je ? (function() {
    if (lt(B._type)) {
      const t = Ie(2);
      Ul(), Ce(t);
    } else Ul();
  })() : Ul() : (function() {
    if (Le && yg() || je && L(h.name) && (k.contextualKeyword === B._type || k.contextualKeyword === B._interface || k.contextualKeyword === B._opaque || k.contextualKeyword === B._enum)) return !1;
    if (L(h.name)) return k.contextualKeyword !== B._async;
    if (!L(h._default)) return !1;
    const t = fu(), s = _i(), n = s.type === h.name && s.contextualKeyword === B._from;
    if (s.type === h.comma) return !0;
    if (n) {
      const i = he.charCodeAt(Jb(t + 4));
      return i === V.quotationMark || i === V.apostrophe;
    }
    return !1;
  })() ? (_e(), L(h.comma) && Ze() === h.star ? (te(h.comma), te(h.star), st(B._as), _e()) : R0(), Kn()) : Z(h._default) ? (function() {
    if (Le && (function() {
      if (be(B._abstract) && Ze() === h._class) return k.type = h._abstract, re(), Ss(!0, !0), !0;
      if (be(B._interface)) {
        const s = Ie(2);
        return ea(B._interface, !0), Ce(s), !0;
      }
      return !1;
    })() || je && be(B._enum) && (I0(), 1)) return;
    const t = k.start;
    Z(h._function) ? Is(t, !0, !0) : be(B._async) && Ze() === h._function ? (lt(B._async), Z(h._function), Is(t, !0, !0)) : L(h._class) ? Ss(!0, !0) : L(h.at) ? (Ou(), Ss(!0, !0)) : (xt(), Ke());
  })() : Le && yg() || je && (be(B._type) || be(B._interface) || be(B._opaque) || be(B._enum)) || k.type === h._var || k.type === h._const || k.type === h._let || k.type === h._function || k.type === h._class || be(B._async) || L(h.at) ? Le ? (function() {
    const t = lt(B._declare);
    t && (k.tokens[k.tokens.length - 1].type = h._declare);
    let s = !1;
    if (L(h.name)) if (t) {
      const n = Ie(2);
      s = gg(), Ce(n);
    } else s = gg();
    if (!s) if (t) {
      const n = Ie(2);
      Ht(!0), Ce(n);
    } else Ht(!0);
  })() : je ? (function() {
    if (be(B._type)) {
      const t = Ie(1);
      re(), L(h.braceL) ? (Fp(), Kn()) : Pu(), Ce(t);
    } else if (be(B._opaque)) {
      const t = Ie(1);
      re(), Au(!1), Ce(t);
    } else if (be(B._interface)) {
      const t = Ie(1);
      re(), Mp(), Ce(t);
    } else Ht(!0);
  })() : Ht(!0) : (Fp(), Kn()), k.tokens[e].rhsEndIndex = k.tokens.length);
}
function R0() {
  Z(h.comma) && Fp();
}
function Kn() {
  lt(B._from) && (is(), D0()), Ke();
}
function Ul() {
  te(h.star), be(B._as) && (re(), k.tokens[k.tokens.length - 1].type = h._as, _e(), R0()), Kn();
}
function Fp() {
  let e = !0;
  for (te(h.braceL); !Z(h.braceR) && !k.error; ) {
    if (e) e = !1;
    else if (te(h.comma), Z(h.braceR)) break;
    G_();
  }
}
function G_() {
  Le ? (function() {
    if (_e(), L(h.comma) || L(h.braceR)) k.tokens[k.tokens.length - 1].identifierRole = ke.ExportAccess;
    else {
      if (_e(), L(h.comma) || L(h.braceR)) return k.tokens[k.tokens.length - 1].identifierRole = ke.ExportAccess, k.tokens[k.tokens.length - 2].isType = !0, void (k.tokens[k.tokens.length - 1].isType = !0);
      _e(), L(h.comma) || L(h.braceR) ? k.tokens[k.tokens.length - 3].identifierRole = ke.ExportAccess : (_e(), k.tokens[k.tokens.length - 3].identifierRole = ke.ExportAccess, k.tokens[k.tokens.length - 4].isType = !0, k.tokens[k.tokens.length - 3].isType = !0, k.tokens[k.tokens.length - 2].isType = !0, k.tokens[k.tokens.length - 1].isType = !0);
    }
  })() : (_e(), k.tokens[k.tokens.length - 1].identifierRole = ke.ExportAccess, lt(B._as) && _e());
}
function X_() {
  be(B._module) && (function() {
    const e = k.snapshot();
    return st(B._module), lt(B._from) ? be(B._from) ? (k.restoreFromSnapshot(e), !0) : (k.restoreFromSnapshot(e), !1) : L(h.comma) ? (k.restoreFromSnapshot(e), !1) : (k.restoreFromSnapshot(e), !0);
  })() && re();
}
function M0() {
  if (Le && L(h.name) && Ze() === h.eq) Ap();
  else {
    if (Le && be(B._type)) {
      const e = _i();
      if (e.type === h.name && e.contextualKeyword !== B._from) {
        if (st(B._type), Ze() === h.eq) return void Ap();
      } else e.type !== h.star && e.type !== h.braceL || st(B._type);
    }
    L(h.string) || (X_(), (function() {
      je && V_();
      let e = !0;
      if (!(L(h.name) && (Ig(), !Z(h.comma)))) {
        if (L(h.star)) return re(), st(B._as), void Ig();
        for (te(h.braceL); !Z(h.braceR) && !k.error; ) {
          if (e) e = !1;
          else if (Z(h.colon) && Ae("ES2015 named imports do not destructure. Use another statement for destructuring after the import."), te(h.comma), Z(h.braceR)) break;
          K_();
        }
      }
    })(), st(B._from)), is(), D0(), Ke();
  }
}
function Ig() {
  Jo();
}
function K_() {
  Le ? (function() {
    if (_e(), L(h.comma) || L(h.braceR)) k.tokens[k.tokens.length - 1].identifierRole = ke.ImportDeclaration;
    else {
      if (_e(), L(h.comma) || L(h.braceR)) return k.tokens[k.tokens.length - 1].identifierRole = ke.ImportDeclaration, k.tokens[k.tokens.length - 2].isType = !0, void (k.tokens[k.tokens.length - 1].isType = !0);
      if (_e(), L(h.comma) || L(h.braceR)) return k.tokens[k.tokens.length - 3].identifierRole = ke.ImportAccess, void (k.tokens[k.tokens.length - 1].identifierRole = ke.ImportDeclaration);
      _e(), k.tokens[k.tokens.length - 3].identifierRole = ke.ImportAccess, k.tokens[k.tokens.length - 1].identifierRole = ke.ImportDeclaration, k.tokens[k.tokens.length - 4].isType = !0, k.tokens[k.tokens.length - 3].isType = !0, k.tokens[k.tokens.length - 2].isType = !0, k.tokens[k.tokens.length - 1].isType = !0;
    }
  })() : je ? (function() {
    const e = k.contextualKeyword === B._type || k.type === h._typeof;
    e ? re() : _e(), be(B._as) && !du(B._as) ? (_e(), (!e || L(h.name) || k.type & h.IS_KEYWORD) && _e()) : (e && (L(h.name) || k.type & h.IS_KEYWORD) && _e(), lt(B._as) && _e());
  })() : (Jo(), be(B._as) && (k.tokens[k.tokens.length - 1].identifierRole = ke.ImportAccess, re(), Jo()));
}
function D0() {
  (L(h._with) || be(B._assert) && !Lt()) && (re(), wu(!1, !1));
}
function J_() {
  return k.pos === 0 && he.charCodeAt(0) === V.numberSign && he.charCodeAt(1) === V.exclamationMark && Zb(2), Qb(), (function() {
    if (Xa(h.eof), k.scopes.push(new Er(0, k.tokens.length, !0)), k.scopeDepth !== 0) throw new Error(`Invalid scope depth at end of file: ${k.scopeDepth}`);
    return new Y_(k.tokens, k.scopes);
  })();
}
class Y_ {
  constructor(t, s) {
    this.tokens = t, this.scopes = s;
  }
}
class Jn {
  __init() {
    this.resultCode = "";
  }
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(t, s, n, i, o) {
    this.code = t, this.tokens = s, this.isFlowEnabled = n, this.disableESTransforms = i, this.helperManager = o, Jn.prototype.__init.call(this), Jn.prototype.__init2.call(this), Jn.prototype.__init3.call(this);
  }
  snapshot() {
    return { resultCode: this.resultCode, tokenIndex: this.tokenIndex };
  }
  restoreToSnapshot(t) {
    this.resultCode = t.resultCode, this.tokenIndex = t.tokenIndex;
  }
  dangerouslyGetAndRemoveCodeSinceSnapshot(t) {
    const s = this.resultCode.slice(t.resultCode.length);
    return this.resultCode = t.resultCode, s;
  }
  reset() {
    this.resultCode = "", this.resultMappings = new Array(this.tokens.length), this.tokenIndex = 0;
  }
  matchesContextualAtIndex(t, s) {
    return this.matches1AtIndex(t, h.name) && this.tokens[t].contextualKeyword === s;
  }
  identifierNameAtIndex(t) {
    return this.identifierNameForToken(this.tokens[t]);
  }
  identifierNameAtRelativeIndex(t) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(t));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(t) {
    return this.code.slice(t.start, t.end);
  }
  rawCodeForToken(t) {
    return this.code.slice(t.start, t.end);
  }
  stringValueAtIndex(t) {
    return this.stringValueForToken(this.tokens[t]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(t) {
    return this.code.slice(t.start + 1, t.end - 1);
  }
  matches1AtIndex(t, s) {
    return this.tokens[t].type === s;
  }
  matches2AtIndex(t, s, n) {
    return this.tokens[t].type === s && this.tokens[t + 1].type === n;
  }
  matches3AtIndex(t, s, n, i) {
    return this.tokens[t].type === s && this.tokens[t + 1].type === n && this.tokens[t + 2].type === i;
  }
  matches1(t) {
    return this.tokens[this.tokenIndex].type === t;
  }
  matches2(t, s) {
    return this.tokens[this.tokenIndex].type === t && this.tokens[this.tokenIndex + 1].type === s;
  }
  matches3(t, s, n) {
    return this.tokens[this.tokenIndex].type === t && this.tokens[this.tokenIndex + 1].type === s && this.tokens[this.tokenIndex + 2].type === n;
  }
  matches4(t, s, n, i) {
    return this.tokens[this.tokenIndex].type === t && this.tokens[this.tokenIndex + 1].type === s && this.tokens[this.tokenIndex + 2].type === n && this.tokens[this.tokenIndex + 3].type === i;
  }
  matches5(t, s, n, i, o) {
    return this.tokens[this.tokenIndex].type === t && this.tokens[this.tokenIndex + 1].type === s && this.tokens[this.tokenIndex + 2].type === n && this.tokens[this.tokenIndex + 3].type === i && this.tokens[this.tokenIndex + 4].type === o;
  }
  matchesContextual(t) {
    return this.matchesContextualAtIndex(this.tokenIndex, t);
  }
  matchesContextIdAndLabel(t, s) {
    return this.matches1(t) && this.currentToken().contextId === s;
  }
  previousWhitespaceAndComments() {
    let t = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);
    return this.isFlowEnabled && (t = t.replace(/@flow/g, "")), t;
  }
  replaceToken(t) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += t, this.appendTokenSuffix(), this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(t) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, ""), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += t, this.appendTokenSuffix(), this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  removeBalancedCode() {
    let t = 0;
    for (; !this.isAtEnd(); ) {
      if (this.matches1(h.braceL)) t++;
      else if (this.matches1(h.braceR)) {
        if (t === 0) return;
        t--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(t) {
    if (this.tokens[this.tokenIndex].type !== t) throw new Error(`Expected token ${t}`);
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end), this.appendTokenSuffix(), this.tokenIndex++;
  }
  copyTokenWithPrefix(t) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultCode += t, this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end), this.appendTokenSuffix(), this.tokenIndex++;
  }
  appendTokenPrefix() {
    const t = this.currentToken();
    if ((t.numNullishCoalesceStarts || t.isOptionalChainStart) && (t.isAsyncOperation = (function(s) {
      let n = s.currentIndex(), i = 0;
      const o = s.currentToken();
      do {
        const c = s.tokens[n];
        if (c.isOptionalChainStart && i++, c.isOptionalChainEnd && i--, i += c.numNullishCoalesceStarts, i -= c.numNullishCoalesceEnds, c.contextualKeyword === B._await && c.identifierRole == null && c.scopeDepth === o.scopeDepth) return !0;
        n += 1;
      } while (i > 0 && n < s.tokens.length);
      return !1;
    })(this)), !this.disableESTransforms) {
      if (t.numNullishCoalesceStarts) for (let s = 0; s < t.numNullishCoalesceStarts; s++) t.isAsyncOperation ? (this.resultCode += "await ", this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce")) : this.resultCode += this.helperManager.getHelperName("nullishCoalesce"), this.resultCode += "(";
      t.isOptionalChainStart && (t.isAsyncOperation && (this.resultCode += "await "), this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === h._delete ? t.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete") : this.resultCode += this.helperManager.getHelperName("optionalChainDelete") : t.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChain") : this.resultCode += this.helperManager.getHelperName("optionalChain"), this.resultCode += "([");
    }
  }
  appendTokenSuffix() {
    const t = this.currentToken();
    if (t.isOptionalChainEnd && !this.disableESTransforms && (this.resultCode += "])"), t.numNullishCoalesceEnds && !this.disableESTransforms) for (let s = 0; s < t.numNullishCoalesceEnds; s++) this.resultCode += "))";
  }
  appendCode(t) {
    this.resultCode += t;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const t = this.currentToken();
    return this.code.slice(t.start, t.end);
  }
  tokenAtRelativeIndex(t) {
    return this.tokens[this.tokenIndex + t];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  nextToken() {
    if (this.tokenIndex === this.tokens.length) throw new Error("Unexpectedly reached end of input.");
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length) throw new Error("Tried to finish processing tokens before reaching the end.");
    return this.resultCode += this.previousWhitespaceAndComments(), { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
}
function Q_(e, t, s, n) {
  const i = t.snapshot(), o = (function(m) {
    const y = m.currentToken(), v = y.contextId;
    if (v == null) throw new Error("Expected context ID on class token.");
    const b = y.isExpression;
    if (b == null) throw new Error("Expected isExpression on class token.");
    let E = null, w = !1;
    for (m.nextToken(), m.matches1(h.name) && (E = m.identifierName()); !m.matchesContextIdAndLabel(h.braceL, v); ) m.matches1(h._extends) && !m.currentToken().isType && (w = !0), m.nextToken();
    return { isExpression: b, className: E, hasSuperclass: w };
  })(t);
  let c = [];
  const l = [], p = [];
  let d = null;
  const g = [], f = [], x = t.currentToken().contextId;
  if (x == null) throw new Error("Expected non-null class context ID on class open-brace.");
  for (t.nextToken(); !t.matchesContextIdAndLabel(h.braceR, x); ) if (t.matchesContextual(B._constructor) && !t.currentToken().isType) ({ constructorInitializerStatements: c, constructorInsertPos: d } = Ng(t));
  else if (t.matches1(h.semi)) n || f.push({ start: t.currentIndex(), end: t.currentIndex() + 1 }), t.nextToken();
  else if (t.currentToken().isType) t.nextToken();
  else {
    const m = t.currentIndex();
    let y = !1, v = !1, b = !1;
    for (; sa(t.currentToken()); ) t.matches1(h._static) && (y = !0), t.matches1(h.hash) && (v = !0), (t.matches1(h._declare) || t.matches1(h._abstract)) && (b = !0), t.nextToken();
    if (y && t.matches1(h.braceL)) {
      $l(t, x);
      continue;
    }
    if (v) {
      $l(t, x);
      continue;
    }
    if (t.matchesContextual(B._constructor) && !t.currentToken().isType) {
      ({ constructorInitializerStatements: c, constructorInsertPos: d } = Ng(t));
      continue;
    }
    const E = t.currentIndex();
    if (Z_(t), t.matches1(h.lessThan) || t.matches1(h.parenL)) {
      $l(t, x);
      continue;
    }
    for (; t.currentToken().isType; ) t.nextToken();
    if (t.matches1(h.eq)) {
      const w = t.currentIndex(), C = t.currentToken().rhsEndIndex;
      if (C == null) throw new Error("Expected rhsEndIndex on class field assignment.");
      for (t.nextToken(); t.currentIndex() < C; ) e.processToken();
      let A;
      y ? (A = s.claimFreeName("__initStatic"), p.push(A)) : (A = s.claimFreeName("__init"), l.push(A)), g.push({ initializerName: A, equalsIndex: w, start: E, end: t.currentIndex() });
    } else n && !b || f.push({ start: m, end: t.currentIndex() });
  }
  return t.restoreToSnapshot(i), n ? { headerInfo: o, constructorInitializerStatements: c, instanceInitializerNames: [], staticInitializerNames: [], constructorInsertPos: d, fields: [], rangesToRemove: f } : { headerInfo: o, constructorInitializerStatements: c, instanceInitializerNames: l, staticInitializerNames: p, constructorInsertPos: d, fields: g, rangesToRemove: f };
}
function $l(e, t) {
  for (e.nextToken(); e.currentToken().contextId !== t; ) e.nextToken();
  for (; sa(e.tokenAtRelativeIndex(-1)); ) e.previousToken();
}
function Ng(e) {
  const t = [];
  e.nextToken();
  const s = e.currentToken().contextId;
  if (s == null) throw new Error("Expected context ID on open-paren starting constructor params.");
  for (; !e.matchesContextIdAndLabel(h.parenR, s); ) if (e.currentToken().contextId === s) {
    if (e.nextToken(), sa(e.currentToken())) {
      for (e.nextToken(); sa(e.currentToken()); ) e.nextToken();
      const o = e.currentToken();
      if (o.type !== h.name) throw new Error("Expected identifier after access modifiers in constructor arg.");
      const c = e.identifierNameForToken(o);
      t.push(`this.${c} = ${c}`);
    }
  } else e.nextToken();
  for (e.nextToken(); e.currentToken().isType; ) e.nextToken();
  let n = e.currentIndex(), i = !1;
  for (; !e.matchesContextIdAndLabel(h.braceR, s); ) {
    if (!i && e.matches2(h._super, h.parenL)) {
      e.nextToken();
      const o = e.currentToken().contextId;
      if (o == null) throw new Error("Expected a context ID on the super call");
      for (; !e.matchesContextIdAndLabel(h.parenR, o); ) e.nextToken();
      n = e.currentIndex(), i = !0;
    }
    e.nextToken();
  }
  return e.nextToken(), { constructorInitializerStatements: t, constructorInsertPos: n };
}
function sa(e) {
  return [h._async, h._get, h._set, h.plus, h.minus, h._readonly, h._static, h._public, h._private, h._protected, h._override, h._abstract, h.star, h._declare, h.hash].includes(e.type);
}
function Z_(e) {
  if (e.matches1(h.bracketL)) {
    const t = e.currentToken().contextId;
    if (t == null) throw new Error("Expected class context ID on computed name open bracket.");
    for (; !e.matchesContextIdAndLabel(h.bracketR, t); ) e.nextToken();
    e.nextToken();
  } else e.nextToken();
}
function F0(e) {
  if (e.removeInitialToken(), e.removeToken(), e.removeToken(), e.removeToken(), e.matches1(h.parenL)) e.removeToken(), e.removeToken(), e.removeToken();
  else for (; e.matches1(h.dot); ) e.removeToken(), e.removeToken();
}
const j0 = { typeDeclarations: /* @__PURE__ */ new Set(), valueDeclarations: /* @__PURE__ */ new Set() };
function B0(e) {
  const t = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
  for (let n = 0; n < e.tokens.length; n++) {
    const i = e.tokens[n];
    i.type === h.name && Xb(i) && (i.isType ? t.add(e.identifierNameForToken(i)) : s.add(e.identifierNameForToken(i)));
  }
  return { typeDeclarations: t, valueDeclarations: s };
}
function U0(e) {
  let t = e.currentIndex();
  for (; !e.matches1AtIndex(t, h.braceR); ) t++;
  return e.matchesContextualAtIndex(t + 1, B._from) && e.matches1AtIndex(t + 2, h.string);
}
function bs(e) {
  (e.matches2(h._with, h.braceL) || e.matches2(h.name, h.braceL) && e.matchesContextual(B._assert)) && (e.removeToken(), e.removeToken(), e.removeBalancedCode(), e.removeToken());
}
function $0(e, t, s, n) {
  if (!e || t) return !1;
  const i = s.currentToken();
  if (i.rhsEndIndex == null) throw new Error("Expected non-null rhsEndIndex on export token.");
  const o = i.rhsEndIndex - s.currentIndex();
  if (o !== 3 && (o !== 4 || !s.matches1AtIndex(i.rhsEndIndex - 1, h.semi))) return !1;
  const c = s.tokenAtRelativeIndex(2);
  if (c.type !== h.name) return !1;
  const l = s.identifierNameForToken(c);
  return n.typeDeclarations.has(l) && !n.valueDeclarations.has(l);
}
class Yn extends lr {
  __init() {
    this.hadExport = !1;
  }
  __init2() {
    this.hadNamedExport = !1;
  }
  __init3() {
    this.hadDefaultExport = !1;
  }
  constructor(t, s, n, i, o, c, l, p, d, g, f, x) {
    super(), this.rootTransformer = t, this.tokens = s, this.importProcessor = n, this.nameManager = i, this.helperManager = o, this.reactHotLoaderTransformer = c, this.enableLegacyBabel5ModuleInterop = l, this.enableLegacyTypeScriptModuleInterop = p, this.isTypeScriptTransformEnabled = d, this.isFlowTransformEnabled = g, this.preserveDynamicImport = f, this.keepUnusedImports = x, Yn.prototype.__init.call(this), Yn.prototype.__init2.call(this), Yn.prototype.__init3.call(this), this.declarationInfo = d ? B0(s) : j0;
  }
  getPrefixCode() {
    let t = "";
    return this.hadExport && (t += 'Object.defineProperty(exports, "__esModule", {value: true});'), t;
  }
  getSuffixCode() {
    return this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport ? `
module.exports = exports.default;
` : "";
  }
  process() {
    return this.tokens.matches3(h._import, h.name, h.eq) ? this.processImportEquals() : this.tokens.matches1(h._import) ? (this.processImport(), !0) : this.tokens.matches2(h._export, h.eq) ? (this.tokens.replaceToken("module.exports"), !0) : this.tokens.matches1(h._export) && !this.tokens.currentToken().isType ? (this.hadExport = !0, this.processExport()) : !(!this.tokens.matches2(h.name, h.postIncDec) || !this.processPostIncDec()) || (this.tokens.matches1(h.name) || this.tokens.matches1(h.jsxName) ? this.processIdentifier() : this.tokens.matches1(h.eq) ? this.processAssignment() : this.tokens.matches1(h.assign) ? this.processComplexAssignment() : !!this.tokens.matches1(h.preIncDec) && this.processPreIncDec());
  }
  processImportEquals() {
    const t = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.importProcessor.shouldAutomaticallyElideImportedName(t) ? F0(this.tokens) : this.tokens.replaceToken("const"), !0;
  }
  processImport() {
    if (this.tokens.matches2(h._import, h.parenL)) {
      if (this.preserveDynamicImport) return void this.tokens.copyToken();
      const t = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${t}require`);
      const s = this.tokens.currentToken().contextId;
      if (s == null) throw new Error("Expected context ID on dynamic import invocation.");
      for (this.tokens.copyToken(); !this.tokens.matchesContextIdAndLabel(h.parenR, s); ) this.rootTransformer.processToken();
      return void this.tokens.replaceToken(t ? ")))" : "))");
    }
    if (this.removeImportAndDetectIfShouldElide()) this.tokens.removeToken();
    else {
      const t = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(t)), this.tokens.appendCode(this.importProcessor.claimImportCode(t));
    }
    bs(this.tokens), this.tokens.matches1(h.semi) && this.tokens.removeToken();
  }
  removeImportAndDetectIfShouldElide() {
    if (this.tokens.removeInitialToken(), this.tokens.matchesContextual(B._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, h.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, B._from)) return this.removeRemainingImport(), !0;
    if (this.tokens.matches1(h.name) || this.tokens.matches1(h.star)) return this.removeRemainingImport(), !1;
    if (this.tokens.matches1(h.string)) return !1;
    let t = !1, s = !1;
    for (; !this.tokens.matches1(h.string); ) (!t && this.tokens.matches1(h.braceL) || this.tokens.matches1(h.comma)) && (this.tokens.removeToken(), this.tokens.matches1(h.braceR) || (s = !0), (this.tokens.matches2(h.name, h.comma) || this.tokens.matches2(h.name, h.braceR) || this.tokens.matches4(h.name, h.name, h.name, h.comma) || this.tokens.matches4(h.name, h.name, h.name, h.braceR)) && (t = !0)), this.tokens.removeToken();
    return !this.keepUnusedImports && (this.isTypeScriptTransformEnabled || !!this.isFlowTransformEnabled && s) && !t;
  }
  removeRemainingImport() {
    for (; !this.tokens.matches1(h.string); ) this.tokens.removeToken();
  }
  processIdentifier() {
    const t = this.tokens.currentToken();
    if (t.shadowsGlobal) return !1;
    if (t.identifierRole === ke.ObjectShorthand) return this.processObjectShorthand();
    if (t.identifierRole !== ke.Access) return !1;
    const s = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(t));
    if (!s) return !1;
    let n = this.tokens.currentIndex() + 1;
    for (; n < this.tokens.tokens.length && this.tokens.tokens[n].type === h.parenR; ) n++;
    return this.tokens.tokens[n].type === h.parenL ? this.tokens.tokenAtRelativeIndex(1).type === h.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== h._new ? (this.tokens.replaceToken(`${s}.call(void 0, `), this.tokens.removeToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR)) : this.tokens.replaceToken(`(0, ${s})`) : this.tokens.replaceToken(s), !0;
  }
  processObjectShorthand() {
    const t = this.tokens.identifierName(), s = this.importProcessor.getIdentifierReplacement(t);
    return !!s && (this.tokens.replaceToken(`${t}: ${s}`), !0);
  }
  processExport() {
    if (this.tokens.matches2(h._export, h._enum) || this.tokens.matches3(h._export, h._const, h._enum)) return this.hadNamedExport = !0, !1;
    if (this.tokens.matches2(h._export, h._default)) return this.tokens.matches3(h._export, h._default, h._enum) ? (this.hadDefaultExport = !0, !1) : (this.processExportDefault(), !0);
    if (this.tokens.matches2(h._export, h.braceL)) return this.processExportBindings(), !0;
    if (this.tokens.matches2(h._export, h.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, B._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(h.braceL)) {
        for (; !this.tokens.matches1(h.braceR); ) this.tokens.removeToken();
        this.tokens.removeToken();
      } else this.tokens.removeToken(), this.tokens.matches1(h._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(B._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, h.string) && (this.tokens.removeToken(), this.tokens.removeToken(), bs(this.tokens)), !0;
    }
    if (this.hadNamedExport = !0, this.tokens.matches2(h._export, h._var) || this.tokens.matches2(h._export, h._let) || this.tokens.matches2(h._export, h._const)) return this.processExportVar(), !0;
    if (this.tokens.matches2(h._export, h._function) || this.tokens.matches3(h._export, h.name, h._function)) return this.processExportFunction(), !0;
    if (this.tokens.matches2(h._export, h._class) || this.tokens.matches3(h._export, h._abstract, h._class) || this.tokens.matches2(h._export, h.at)) return this.processExportClass(), !0;
    if (this.tokens.matches2(h._export, h.star)) return this.processExportStar(), !0;
    throw new Error("Unrecognized export syntax.");
  }
  processAssignment() {
    const t = this.tokens.currentIndex(), s = this.tokens.tokens[t - 1];
    if (s.isType || s.type !== h.name || s.shadowsGlobal || t >= 2 && this.tokens.matches1AtIndex(t - 2, h.dot) || t >= 2 && [h._var, h._let, h._const].includes(this.tokens.tokens[t - 2].type)) return !1;
    const n = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(s));
    return !!n && (this.tokens.copyToken(), this.tokens.appendCode(` ${n} =`), !0);
  }
  processComplexAssignment() {
    const t = this.tokens.currentIndex(), s = this.tokens.tokens[t - 1];
    if (s.type !== h.name || s.shadowsGlobal || t >= 2 && this.tokens.matches1AtIndex(t - 2, h.dot)) return !1;
    const n = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(s));
    return !!n && (this.tokens.appendCode(` = ${n}`), this.tokens.copyToken(), !0);
  }
  processPreIncDec() {
    const t = this.tokens.currentIndex(), s = this.tokens.tokens[t + 1];
    if (s.type !== h.name || s.shadowsGlobal || t + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(t + 2, h.dot) || this.tokens.matches1AtIndex(t + 2, h.bracketL) || this.tokens.matches1AtIndex(t + 2, h.parenL))) return !1;
    const n = this.tokens.identifierNameForToken(s), i = this.importProcessor.resolveExportBinding(n);
    return !!i && (this.tokens.appendCode(`${i} = `), this.tokens.copyToken(), !0);
  }
  processPostIncDec() {
    const t = this.tokens.currentIndex(), s = this.tokens.tokens[t], n = this.tokens.tokens[t + 1];
    if (s.type !== h.name || s.shadowsGlobal || t >= 1 && this.tokens.matches1AtIndex(t - 1, h.dot)) return !1;
    const i = this.tokens.identifierNameForToken(s), o = this.importProcessor.resolveExportBinding(i);
    if (!o) return !1;
    const c = this.tokens.rawCodeForToken(n), l = this.importProcessor.getIdentifierReplacement(i) || i;
    if (c === "++") this.tokens.replaceToken(`(${l} = ${o} = ${l} + 1, ${l} - 1)`);
    else {
      if (c !== "--") throw new Error(`Unexpected operator: ${c}`);
      this.tokens.replaceToken(`(${l} = ${o} = ${l} - 1, ${l} + 1)`);
    }
    return this.tokens.removeToken(), !0;
  }
  processExportDefault() {
    let t = !0;
    if (this.tokens.matches4(h._export, h._default, h._function, h.name) || this.tokens.matches5(h._export, h._default, h.name, h._function, h.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, B._async)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken();
      const s = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${s};`);
    } else if (this.tokens.matches4(h._export, h._default, h._class, h.name) || this.tokens.matches5(h._export, h._default, h._abstract, h._class, h.name) || this.tokens.matches3(h._export, h._default, h.at)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken(), this.copyDecorators(), this.tokens.matches1(h._abstract) && this.tokens.removeToken();
      const s = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${s};`);
    } else if ($0(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) t = !1, this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken();
    else if (this.reactHotLoaderTransformer) {
      const s = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${s}; exports.`), this.tokens.copyToken(), this.tokens.appendCode(` = ${s} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(s);
    } else this.tokens.replaceToken("exports."), this.tokens.copyToken(), this.tokens.appendCode(" =");
    t && (this.hadDefaultExport = !0);
  }
  copyDecorators() {
    for (; this.tokens.matches1(h.at); ) if (this.tokens.copyToken(), this.tokens.matches1(h.parenL)) this.tokens.copyExpectedToken(h.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR);
    else {
      for (this.tokens.copyExpectedToken(h.name); this.tokens.matches1(h.dot); ) this.tokens.copyExpectedToken(h.dot), this.tokens.copyExpectedToken(h.name);
      this.tokens.matches1(h.parenL) && (this.tokens.copyExpectedToken(h.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR));
    }
  }
  processExportVar() {
    this.isSimpleExportVar() ? this.processSimpleExportVar() : this.processComplexExportVar();
  }
  isSimpleExportVar() {
    let t = this.tokens.currentIndex();
    if (t++, t++, !this.tokens.matches1AtIndex(t, h.name)) return !1;
    for (t++; t < this.tokens.tokens.length && this.tokens.tokens[t].isType; ) t++;
    return !!this.tokens.matches1AtIndex(t, h.eq);
  }
  processSimpleExportVar() {
    this.tokens.removeInitialToken(), this.tokens.copyToken();
    const t = this.tokens.identifierName();
    for (; !this.tokens.matches1(h.eq); ) this.rootTransformer.processToken();
    const s = this.tokens.currentToken().rhsEndIndex;
    if (s == null) throw new Error("Expected = token with an end index.");
    for (; this.tokens.currentIndex() < s; ) this.rootTransformer.processToken();
    this.tokens.appendCode(`; exports.${t} = ${t}`);
  }
  processComplexExportVar() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const t = this.tokens.matches1(h.braceL);
    t && this.tokens.appendCode("(");
    let s = 0;
    for (; ; ) if (this.tokens.matches1(h.braceL) || this.tokens.matches1(h.dollarBraceL) || this.tokens.matches1(h.bracketL)) s++, this.tokens.copyToken();
    else if (this.tokens.matches1(h.braceR) || this.tokens.matches1(h.bracketR)) s--, this.tokens.copyToken();
    else {
      if (s === 0 && !this.tokens.matches1(h.name) && !this.tokens.currentToken().isType) break;
      if (this.tokens.matches1(h.eq)) {
        const n = this.tokens.currentToken().rhsEndIndex;
        if (n == null) throw new Error("Expected = token with an end index.");
        for (; this.tokens.currentIndex() < n; ) this.rootTransformer.processToken();
      } else {
        const n = this.tokens.currentToken();
        if (Gb(n)) {
          const i = this.tokens.identifierName();
          let o = this.importProcessor.getIdentifierReplacement(i);
          if (o === null) throw new Error(`Expected a replacement for ${i} in \`export var\` syntax.`);
          Yw(n) && (o = `${i}: ${o}`), this.tokens.replaceToken(o);
        } else this.rootTransformer.processToken();
      }
    }
    if (t) {
      const n = this.tokens.currentToken().rhsEndIndex;
      if (n == null) throw new Error("Expected = token with an end index.");
      for (; this.tokens.currentIndex() < n; ) this.rootTransformer.processToken();
      this.tokens.appendCode(")");
    }
  }
  processExportFunction() {
    this.tokens.replaceToken("");
    const t = this.processNamedFunction();
    this.tokens.appendCode(` exports.${t} = ${t};`);
  }
  processNamedFunction() {
    if (this.tokens.matches1(h._function)) this.tokens.copyToken();
    else if (this.tokens.matches2(h.name, h._function)) {
      if (!this.tokens.matchesContextual(B._async)) throw new Error("Expected async keyword in function export.");
      this.tokens.copyToken(), this.tokens.copyToken();
    }
    if (this.tokens.matches1(h.star) && this.tokens.copyToken(), !this.tokens.matches1(h.name)) throw new Error("Expected identifier for exported function name.");
    const t = this.tokens.identifierName();
    if (this.tokens.copyToken(), this.tokens.currentToken().isType) for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; ) this.tokens.removeToken();
    return this.tokens.copyExpectedToken(h.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR), this.rootTransformer.processPossibleTypeRange(), this.tokens.copyExpectedToken(h.braceL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.braceR), t;
  }
  processExportClass() {
    this.tokens.removeInitialToken(), this.copyDecorators(), this.tokens.matches1(h._abstract) && this.tokens.removeToken();
    const t = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${t} = ${t};`);
  }
  processExportBindings() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const t = U0(this.tokens), s = [];
    for (; ; ) {
      if (this.tokens.matches1(h.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const n = pi(this.tokens);
      for (; this.tokens.currentIndex() < n.endIndex; ) this.tokens.removeToken();
      if (!(n.isType || !t && this.shouldElideExportedIdentifier(n.leftName))) {
        const i = n.rightName;
        i === "default" ? this.hadDefaultExport = !0 : this.hadNamedExport = !0;
        const o = n.leftName, c = this.importProcessor.getIdentifierReplacement(o);
        s.push(`exports.${i} = ${c || o};`);
      }
      if (this.tokens.matches1(h.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(h.comma, h.braceR)) {
        this.tokens.removeToken(), this.tokens.removeToken();
        break;
      }
      if (!this.tokens.matches1(h.comma)) throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
      this.tokens.removeToken();
    }
    if (this.tokens.matchesContextual(B._from)) {
      this.tokens.removeToken();
      const n = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(n)), bs(this.tokens);
    } else this.tokens.appendCode(s.join(" "));
    this.tokens.matches1(h.semi) && this.tokens.removeToken();
  }
  processExportStar() {
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(h.string); ) this.tokens.removeToken();
    const t = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(t)), bs(this.tokens), this.tokens.matches1(h.semi) && this.tokens.removeToken();
  }
  shouldElideExportedIdentifier(t) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(t);
  }
}
class eP extends lr {
  constructor(t, s, n, i, o, c, l, p) {
    super(), this.tokens = t, this.nameManager = s, this.helperManager = n, this.reactHotLoaderTransformer = i, this.isTypeScriptTransformEnabled = o, this.isFlowTransformEnabled = c, this.keepUnusedImports = l, this.nonTypeIdentifiers = o && !l ? o0(t, p) : /* @__PURE__ */ new Set(), this.declarationInfo = o && !l ? B0(t) : j0, this.injectCreateRequireForImportRequire = !!p.injectCreateRequireForImportRequire;
  }
  process() {
    if (this.tokens.matches3(h._import, h.name, h.eq)) return this.processImportEquals();
    if (this.tokens.matches4(h._import, h.name, h.name, h.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, B._type)) {
      this.tokens.removeInitialToken();
      for (let t = 0; t < 7; t++) this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches2(h._export, h.eq)) return this.tokens.replaceToken("module.exports"), !0;
    if (this.tokens.matches5(h._export, h._import, h.name, h.name, h.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, B._type)) {
      this.tokens.removeInitialToken();
      for (let t = 0; t < 8; t++) this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches1(h._import)) return this.processImport();
    if (this.tokens.matches2(h._export, h._default)) return this.processExportDefault();
    if (this.tokens.matches2(h._export, h.braceL)) return this.processNamedExports();
    if (this.tokens.matches2(h._export, h.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, B._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(h.braceL)) {
        for (; !this.tokens.matches1(h.braceR); ) this.tokens.removeToken();
        this.tokens.removeToken();
      } else this.tokens.removeToken(), this.tokens.matches1(h._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(B._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, h.string) && (this.tokens.removeToken(), this.tokens.removeToken(), bs(this.tokens)), !0;
    }
    return !1;
  }
  processImportEquals() {
    const t = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.shouldAutomaticallyElideImportedName(t) ? F0(this.tokens) : this.injectCreateRequireForImportRequire ? (this.tokens.replaceToken("const"), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.replaceToken(this.helperManager.getHelperName("require"))) : this.tokens.replaceToken("const"), !0;
  }
  processImport() {
    if (this.tokens.matches2(h._import, h.parenL)) return !1;
    const t = this.tokens.snapshot();
    if (this.removeImportTypeBindings()) {
      for (this.tokens.restoreToSnapshot(t); !this.tokens.matches1(h.string); ) this.tokens.removeToken();
      this.tokens.removeToken(), bs(this.tokens), this.tokens.matches1(h.semi) && this.tokens.removeToken();
    }
    return !0;
  }
  removeImportTypeBindings() {
    if (this.tokens.copyExpectedToken(h._import), this.tokens.matchesContextual(B._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, h.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, B._from)) return !0;
    if (this.tokens.matches1(h.string)) return this.tokens.copyToken(), !1;
    this.tokens.matchesContextual(B._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, B._from) && this.tokens.copyToken();
    let t = !1, s = !1, n = !1;
    if (this.tokens.matches1(h.name) && (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName()) ? (this.tokens.removeToken(), this.tokens.matches1(h.comma) && this.tokens.removeToken()) : (t = !0, this.tokens.copyToken(), this.tokens.matches1(h.comma) && (n = !0, this.tokens.removeToken()))), this.tokens.matches1(h.star)) this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2)) ? (this.tokens.removeToken(), this.tokens.removeToken(), this.tokens.removeToken()) : (n && this.tokens.appendCode(","), t = !0, this.tokens.copyExpectedToken(h.star), this.tokens.copyExpectedToken(h.name), this.tokens.copyExpectedToken(h.name));
    else if (this.tokens.matches1(h.braceL)) {
      for (n && this.tokens.appendCode(","), this.tokens.copyToken(); !this.tokens.matches1(h.braceR); ) {
        s = !0;
        const i = pi(this.tokens);
        if (i.isType || this.shouldAutomaticallyElideImportedName(i.rightName)) {
          for (; this.tokens.currentIndex() < i.endIndex; ) this.tokens.removeToken();
          this.tokens.matches1(h.comma) && this.tokens.removeToken();
        } else {
          for (t = !0; this.tokens.currentIndex() < i.endIndex; ) this.tokens.copyToken();
          this.tokens.matches1(h.comma) && this.tokens.copyToken();
        }
      }
      this.tokens.copyExpectedToken(h.braceR);
    }
    return !this.keepUnusedImports && (this.isTypeScriptTransformEnabled || !!this.isFlowTransformEnabled && s) && !t;
  }
  shouldAutomaticallyElideImportedName(t) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(t);
  }
  processExportDefault() {
    if ($0(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) return this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken(), !0;
    if (!(this.tokens.matches4(h._export, h._default, h._function, h.name) || this.tokens.matches5(h._export, h._default, h.name, h._function, h.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, B._async) || this.tokens.matches4(h._export, h._default, h._class, h.name) || this.tokens.matches5(h._export, h._default, h._abstract, h._class, h.name)) && this.reactHotLoaderTransformer) {
      const t = this.nameManager.claimFreeName("_default");
      return this.tokens.replaceToken(`let ${t}; export`), this.tokens.copyToken(), this.tokens.appendCode(` ${t} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(t), !0;
    }
    return !1;
  }
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) return !1;
    this.tokens.copyExpectedToken(h._export), this.tokens.copyExpectedToken(h.braceL);
    const t = U0(this.tokens);
    let s = !1;
    for (; !this.tokens.matches1(h.braceR); ) {
      const n = pi(this.tokens);
      if (n.isType || !t && this.shouldElideExportedName(n.leftName)) {
        for (; this.tokens.currentIndex() < n.endIndex; ) this.tokens.removeToken();
        this.tokens.matches1(h.comma) && this.tokens.removeToken();
      } else {
        for (s = !0; this.tokens.currentIndex() < n.endIndex; ) this.tokens.copyToken();
        this.tokens.matches1(h.comma) && this.tokens.copyToken();
      }
    }
    return this.tokens.copyExpectedToken(h.braceR), this.keepUnusedImports || !t || s || (this.tokens.removeToken(), this.tokens.removeToken(), bs(this.tokens)), !0;
  }
  shouldElideExportedName(t) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(t) && !this.declarationInfo.valueDeclarations.has(t);
  }
}
class tP extends lr {
  constructor(t, s, n) {
    super(), this.rootTransformer = t, this.tokens = s, this.isImportsTransformEnabled = n;
  }
  process() {
    return !!(this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) || (this.tokens.matches1(h._enum) ? (this.processEnum(), !0) : this.tokens.matches2(h._export, h._enum) ? (this.processNamedExportEnum(), !0) : !!this.tokens.matches3(h._export, h._default, h._enum) && (this.processDefaultExportEnum(), !0));
  }
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const t = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum(), this.tokens.appendCode(` exports.${t} = ${t};`);
    } else this.tokens.copyToken(), this.processEnum();
  }
  processDefaultExportEnum() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const t = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum(), this.isImportsTransformEnabled ? this.tokens.appendCode(` exports.default = ${t};`) : this.tokens.appendCode(` export default ${t};`);
  }
  processEnum() {
    this.tokens.replaceToken("const"), this.tokens.copyExpectedToken(h.name);
    let t = !1;
    this.tokens.matchesContextual(B._of) && (this.tokens.removeToken(), t = this.tokens.matchesContextual(B._symbol), this.tokens.removeToken());
    const s = this.tokens.matches3(h.braceL, h.name, h.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const n = !t && !s;
    for (this.tokens.replaceTokenTrimmingLeftWhitespace(n ? ".Mirrored([" : "({"); !this.tokens.matches1(h.braceR); ) {
      if (this.tokens.matches1(h.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(t, s), this.tokens.matches1(h.comma) && this.tokens.copyToken();
    }
    this.tokens.replaceToken(n ? "]);" : "});");
  }
  processEnumElement(t, s) {
    if (t) {
      const n = this.tokens.identifierName();
      this.tokens.copyToken(), this.tokens.appendCode(`: Symbol("${n}")`);
    } else s ? (this.tokens.copyToken(), this.tokens.replaceTokenTrimmingLeftWhitespace(":"), this.tokens.copyToken()) : this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
  }
}
const no = "jest", rP = ["mock", "unmock", "enableAutomock", "disableAutomock"];
class Lu extends lr {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(t, s, n, i) {
    super(), this.rootTransformer = t, this.tokens = s, this.nameManager = n, this.importProcessor = i, Lu.prototype.__init.call(this);
  }
  process() {
    return !(this.tokens.currentToken().scopeDepth !== 0 || !this.tokens.matches4(h.name, h.dot, h.name, h.parenL) || this.tokens.identifierName() !== no) && !(function(t) {
      let s, n = t[0], i = 1;
      for (; i < t.length; ) {
        const o = t[i], c = t[i + 1];
        if (i += 2, (o === "optionalAccess" || o === "optionalCall") && n == null) return;
        o === "access" || o === "optionalAccess" ? (s = n, n = c(n)) : o !== "call" && o !== "optionalCall" || (n = c((...l) => n.call(s, ...l)), s = void 0);
      }
      return n;
    })([this, "access", (t) => t.importProcessor, "optionalAccess", (t) => t.getGlobalNames, "call", (t) => t(), "optionalAccess", (t) => t.has, "call", (t) => t(no)]) && this.extractHoistedCalls();
  }
  getHoistedCode() {
    return this.hoistedFunctionNames.length > 0 ? this.hoistedFunctionNames.map((t) => `${t}();`).join("") : "";
  }
  extractHoistedCalls() {
    this.tokens.removeToken();
    let t = !1;
    for (; this.tokens.matches3(h.dot, h.name, h.parenL); ) {
      const s = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      if (rP.includes(s)) {
        const n = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(n), this.tokens.replaceToken(`function ${n}(){${no}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR), this.tokens.appendCode(";}"), t = !1;
      } else t ? this.tokens.copyToken() : this.tokens.replaceToken(`${no}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.parenR), t = !0;
    }
    return !0;
  }
}
class sP extends lr {
  constructor(t) {
    super(), this.tokens = t;
  }
  process() {
    if (this.tokens.matches1(h.num)) {
      const t = this.tokens.currentTokenCode();
      if (t.includes("_")) return this.tokens.replaceToken(t.replace(/_/g, "")), !0;
    }
    return !1;
  }
}
class nP extends lr {
  constructor(t, s) {
    super(), this.tokens = t, this.nameManager = s;
  }
  process() {
    return !!this.tokens.matches2(h._catch, h.braceL) && (this.tokens.copyToken(), this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`), !0);
  }
}
class iP extends lr {
  constructor(t, s) {
    super(), this.tokens = t, this.nameManager = s;
  }
  process() {
    if (this.tokens.matches1(h.nullishCoalescing)) {
      const s = this.tokens.currentToken();
      return this.tokens.tokens[s.nullishStartIndex].isAsyncOperation ? this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (") : this.tokens.replaceTokenTrimmingLeftWhitespace(", () => ("), !0;
    }
    if (this.tokens.matches1(h._delete) && this.tokens.tokenAtRelativeIndex(1).isOptionalChainStart)
      return this.tokens.removeInitialToken(), !0;
    const t = this.tokens.currentToken().subscriptStartIndex;
    if (t != null && this.tokens.tokens[t].isOptionalChainStart && this.tokens.tokenAtRelativeIndex(-1).type !== h._super) {
      const s = this.nameManager.claimFreeName("_");
      let n;
      if (n = t > 0 && this.tokens.matches1AtIndex(t - 1, h._delete) && this.isLastSubscriptInChain() ? `${s} => delete ${s}` : `${s} => ${s}`, this.tokens.tokens[t].isAsyncOperation && (n = `async ${n}`), this.tokens.matches2(h.questionDot, h.parenL) || this.tokens.matches2(h.questionDot, h.lessThan)) this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${n}`);
      else if (this.tokens.matches2(h.questionDot, h.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${n}`);
      else if (this.tokens.matches1(h.questionDot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${n}.`);
      else if (this.tokens.matches1(h.dot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${n}.`);
      else if (this.tokens.matches1(h.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${n}[`);
      else {
        if (!this.tokens.matches1(h.parenL)) throw new Error("Unexpected subscript operator in optional chain.");
        this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${n}(`);
      }
      return !0;
    }
    return !1;
  }
  isLastSubscriptInChain() {
    let t = 0;
    for (let s = this.tokens.currentIndex() + 1; ; s++) {
      if (s >= this.tokens.tokens.length) throw new Error("Reached the end of the code while finding the end of the access chain.");
      if (this.tokens.tokens[s].isOptionalChainStart ? t++ : this.tokens.tokens[s].isOptionalChainEnd && t--, t < 0) return !0;
      if (t === 0 && this.tokens.tokens[s].subscriptStartIndex != null) return !1;
    }
  }
  justSkippedSuper() {
    let t = 0, s = this.tokens.currentIndex() - 1;
    for (; ; ) {
      if (s < 0) throw new Error("Reached the start of the code while finding the start of the access chain.");
      if (this.tokens.tokens[s].isOptionalChainStart ? t-- : this.tokens.tokens[s].isOptionalChainEnd && t++, t < 0) return !1;
      if (t === 0 && this.tokens.tokens[s].subscriptStartIndex != null) return this.tokens.tokens[s - 1].type === h._super;
      s--;
    }
  }
}
class oP extends lr {
  constructor(t, s, n, i) {
    super(), this.rootTransformer = t, this.tokens = s, this.importProcessor = n, this.options = i;
  }
  process() {
    const t = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const s = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      return s ? this.tokens.replaceToken(`(0, ${s})`) : this.tokens.copyToken(), this.tryProcessCreateClassCall(t), !0;
    }
    if (this.tokens.matches3(h.name, h.dot, h.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const s = this.importProcessor && this.importProcessor.getIdentifierReplacement("React") || "React";
      return this.tokens.replaceToken(s), this.tokens.copyToken(), this.tokens.copyToken(), this.tryProcessCreateClassCall(t), !0;
    }
    return !1;
  }
  tryProcessCreateClassCall(t) {
    const s = this.findDisplayName(t);
    s && this.classNeedsDisplayName() && (this.tokens.copyExpectedToken(h.parenL), this.tokens.copyExpectedToken(h.braceL), this.tokens.appendCode(`displayName: '${s}',`), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(h.braceR), this.tokens.copyExpectedToken(h.parenR));
  }
  findDisplayName(t) {
    return t < 2 ? null : this.tokens.matches2AtIndex(t - 2, h.name, h.eq) || t >= 2 && this.tokens.tokens[t - 2].identifierRole === ke.ObjectKey ? this.tokens.identifierNameAtIndex(t - 2) : this.tokens.matches2AtIndex(t - 2, h._export, h._default) ? this.getDisplayNameFromFilename() : null;
  }
  getDisplayNameFromFilename() {
    const t = (this.options.filePath || "unknown").split("/"), s = t[t.length - 1], n = s.lastIndexOf("."), i = n === -1 ? s : s.slice(0, n);
    return i === "index" && t[t.length - 2] ? t[t.length - 2] : i;
  }
  classNeedsDisplayName() {
    let t = this.tokens.currentIndex();
    if (!this.tokens.matches2(h.parenL, h.braceL)) return !1;
    const s = t + 1, n = this.tokens.tokens[s].contextId;
    if (n == null) throw new Error("Expected non-null context ID on object open-brace.");
    for (; t < this.tokens.tokens.length; t++) {
      const i = this.tokens.tokens[t];
      if (i.type === h.braceR && i.contextId === n) {
        t++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(t) === "displayName" && this.tokens.tokens[t].identifierRole === ke.ObjectKey && i.contextId === n) return !1;
    }
    if (t === this.tokens.tokens.length) throw new Error("Unexpected end of input when processing React class.");
    return this.tokens.matches1AtIndex(t, h.parenR) || this.tokens.matches2AtIndex(t, h.comma, h.parenR);
  }
}
class Ru extends lr {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(t, s) {
    super(), this.tokens = t, this.filePath = s, Ru.prototype.__init.call(this);
  }
  setExtractedDefaultExportName(t) {
    this.extractedDefaultExportName = t;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const t = /* @__PURE__ */ new Set();
    for (const n of this.tokens.tokens) !n.isType && Xb(n) && n.identifierRole !== ke.ImportDeclaration && t.add(this.tokens.identifierNameForToken(n));
    const s = Array.from(t).map((n) => ({ variableName: n, uniqueLocalName: n }));
    return this.extractedDefaultExportName && s.push({ variableName: this.extractedDefaultExportName, uniqueLocalName: "default" }), `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${s.map(({ variableName: n, uniqueLocalName: i }) => `  reactHotLoader.register(${n}, "${i}", ${JSON.stringify(this.filePath || "")});`).join(`
`)}
  leaveModule(module);
})();`;
  }
  process() {
    return !1;
  }
}
const aP = /* @__PURE__ */ new Set(["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield", "enum", "implements", "interface", "let", "package", "private", "protected", "public", "static", "await", "false", "null", "true"]);
function Og(e) {
  if (e.length === 0 || !wi[e.charCodeAt(0)]) return !1;
  for (let t = 1; t < e.length; t++) if (!cr[e.charCodeAt(t)]) return !1;
  return !aP.has(e);
}
class cP extends lr {
  constructor(t, s, n) {
    super(), this.rootTransformer = t, this.tokens = s, this.isImportsTransformEnabled = n;
  }
  process() {
    return !!(this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) || (this.tokens.matches1(h._public) || this.tokens.matches1(h._protected) || this.tokens.matches1(h._private) || this.tokens.matches1(h._abstract) || this.tokens.matches1(h._readonly) || this.tokens.matches1(h._override) || this.tokens.matches1(h.nonNullAssertion) ? (this.tokens.removeInitialToken(), !0) : this.tokens.matches1(h._enum) || this.tokens.matches2(h._const, h._enum) ? (this.processEnum(), !0) : !(!this.tokens.matches2(h._export, h._enum) && !this.tokens.matches3(h._export, h._const, h._enum)) && (this.processEnum(!0), !0));
  }
  processEnum(t = !1) {
    for (this.tokens.removeInitialToken(); this.tokens.matches1(h._const) || this.tokens.matches1(h._enum); ) this.tokens.removeToken();
    const s = this.tokens.identifierName();
    this.tokens.removeToken(), t && !this.isImportsTransformEnabled && this.tokens.appendCode("export "), this.tokens.appendCode(`var ${s}; (function (${s})`), this.tokens.copyExpectedToken(h.braceL), this.processEnumBody(s), this.tokens.copyExpectedToken(h.braceR), t && this.isImportsTransformEnabled ? this.tokens.appendCode(`)(${s} || (exports.${s} = ${s} = {}));`) : this.tokens.appendCode(`)(${s} || (${s} = {}));`);
  }
  processEnumBody(t) {
    let s = null;
    for (; !this.tokens.matches1(h.braceR); ) {
      const { nameStringCode: n, variableName: i } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken(), this.tokens.matches3(h.eq, h.string, h.comma) || this.tokens.matches3(h.eq, h.string, h.braceR) ? this.processStringLiteralEnumMember(t, n, i) : this.tokens.matches1(h.eq) ? this.processExplicitValueEnumMember(t, n, i) : this.processImplicitValueEnumMember(t, n, i, s), this.tokens.matches1(h.comma) && this.tokens.removeToken(), s = i ?? `${t}[${n}]`;
    }
  }
  extractEnumKeyInfo(t) {
    if (t.type === h.name) {
      const s = this.tokens.identifierNameForToken(t);
      return { nameStringCode: `"${s}"`, variableName: Og(s) ? s : null };
    }
    if (t.type === h.string) {
      const s = this.tokens.stringValueForToken(t);
      return { nameStringCode: this.tokens.code.slice(t.start, t.end), variableName: Og(s) ? s : null };
    }
    throw new Error("Expected name or string at beginning of enum element.");
  }
  processStringLiteralEnumMember(t, s, n) {
    n != null ? (this.tokens.appendCode(`const ${n}`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(`; ${t}[${s}] = ${n};`)) : (this.tokens.appendCode(`${t}[${s}]`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(";"));
  }
  processExplicitValueEnumMember(t, s, n) {
    const i = this.tokens.currentToken().rhsEndIndex;
    if (i == null) throw new Error("Expected rhsEndIndex on enum assign.");
    if (n != null) {
      for (this.tokens.appendCode(`const ${n}`), this.tokens.copyToken(); this.tokens.currentIndex() < i; ) this.rootTransformer.processToken();
      this.tokens.appendCode(`; ${t}[${t}[${s}] = ${n}] = ${s};`);
    } else {
      for (this.tokens.appendCode(`${t}[${t}[${s}]`), this.tokens.copyToken(); this.tokens.currentIndex() < i; ) this.rootTransformer.processToken();
      this.tokens.appendCode(`] = ${s};`);
    }
  }
  processImplicitValueEnumMember(t, s, n, i) {
    let o = i != null ? `${i} + 1` : "0";
    n != null && (this.tokens.appendCode(`const ${n} = ${o}; `), o = n), this.tokens.appendCode(`${t}[${t}[${s}] = ${o}] = ${s};`);
  }
}
class na {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(t, s, n, i) {
    na.prototype.__init.call(this), na.prototype.__init2.call(this), this.nameManager = t.nameManager, this.helperManager = t.helperManager;
    const { tokenProcessor: o, importProcessor: c } = t;
    this.tokens = o, this.isImportsTransformEnabled = s.includes("imports"), this.isReactHotLoaderTransformEnabled = s.includes("react-hot-loader"), this.disableESTransforms = !!i.disableESTransforms, i.disableESTransforms || (this.transformers.push(new iP(o, this.nameManager)), this.transformers.push(new sP(o)), this.transformers.push(new nP(o, this.nameManager))), s.includes("jsx") && (i.jsxRuntime !== "preserve" && this.transformers.push(new gs(this, o, c, this.nameManager, i)), this.transformers.push(new oP(this, o, c, i)));
    let l = null;
    if (s.includes("react-hot-loader")) {
      if (!i.filePath) throw new Error("filePath is required when using the react-hot-loader transform.");
      l = new Ru(o, i.filePath), this.transformers.push(l);
    }
    if (s.includes("imports")) {
      if (c === null) throw new Error("Expected non-null importProcessor with imports transform enabled.");
      this.transformers.push(new Yn(this, o, c, this.nameManager, this.helperManager, l, n, !!i.enableLegacyTypeScriptModuleInterop, s.includes("typescript"), s.includes("flow"), !!i.preserveDynamicImport, !!i.keepUnusedImports));
    } else this.transformers.push(new eP(o, this.nameManager, this.helperManager, l, s.includes("typescript"), s.includes("flow"), !!i.keepUnusedImports, i));
    s.includes("flow") && this.transformers.push(new tP(this, o, s.includes("imports"))), s.includes("typescript") && this.transformers.push(new cP(this, o, s.includes("imports"))), s.includes("jest") && this.transformers.push(new Lu(this, o, this.nameManager, c));
  }
  transform() {
    this.tokens.reset(), this.processBalancedCode();
    let t = this.isImportsTransformEnabled ? '"use strict";' : "";
    for (const o of this.transformers) t += o.getPrefixCode();
    t += this.helperManager.emitHelpers(), t += this.generatedVariables.map((o) => ` var ${o};`).join("");
    for (const o of this.transformers) t += o.getHoistedCode();
    let s = "";
    for (const o of this.transformers) s += o.getSuffixCode();
    const n = this.tokens.finish();
    let { code: i } = n;
    if (i.startsWith("#!")) {
      let o = i.indexOf(`
`);
      return o === -1 && (o = i.length, i += `
`), { code: i.slice(0, o + 1) + t + i.slice(o + 1) + s, mappings: this.shiftMappings(n.mappings, t.length) };
    }
    return { code: t + i + s, mappings: this.shiftMappings(n.mappings, t.length) };
  }
  processBalancedCode() {
    let t = 0, s = 0;
    for (; !this.tokens.isAtEnd(); ) {
      if (this.tokens.matches1(h.braceL) || this.tokens.matches1(h.dollarBraceL)) t++;
      else if (this.tokens.matches1(h.braceR)) {
        if (t === 0) return;
        t--;
      }
      if (this.tokens.matches1(h.parenL)) s++;
      else if (this.tokens.matches1(h.parenR)) {
        if (s === 0) return;
        s--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(h._class)) this.processClass();
    else {
      for (const t of this.transformers)
        if (t.process()) return;
      this.tokens.copyToken();
    }
  }
  processNamedClass() {
    if (!this.tokens.matches2(h._class, h.name)) throw new Error("Expected identifier for exported class name.");
    const t = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.processClass(), t;
  }
  processClass() {
    const t = Q_(this, this.tokens, this.nameManager, this.disableESTransforms), s = (t.headerInfo.isExpression || !t.headerInfo.className) && t.staticInitializerNames.length + t.instanceInitializerNames.length > 0;
    let n = t.headerInfo.className;
    s && (n = this.nameManager.claimFreeName("_class"), this.generatedVariables.push(n), this.tokens.appendCode(` (${n} =`));
    const i = this.tokens.currentToken().contextId;
    if (i == null) throw new Error("Expected class to have a context ID.");
    for (this.tokens.copyExpectedToken(h._class); !this.tokens.matchesContextIdAndLabel(h.braceL, i); ) this.processToken();
    this.processClassBody(t, n);
    const o = t.staticInitializerNames.map((c) => `${n}.${c}()`);
    s ? this.tokens.appendCode(`, ${o.map((c) => `${c}, `).join("")}${n})`) : t.staticInitializerNames.length > 0 && this.tokens.appendCode(` ${o.map((c) => `${c};`).join(" ")}`);
  }
  processClassBody(t, s) {
    const { headerInfo: n, constructorInsertPos: i, constructorInitializerStatements: o, fields: c, instanceInitializerNames: l, rangesToRemove: p } = t;
    let d = 0, g = 0;
    const f = this.tokens.currentToken().contextId;
    if (f == null) throw new Error("Expected non-null context ID on class.");
    this.tokens.copyExpectedToken(h.braceL), this.isReactHotLoaderTransformEnabled && this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
    const x = o.length + l.length > 0;
    if (i === null && x) {
      const m = this.makeConstructorInitCode(o, l, s);
      if (n.hasSuperclass) {
        const y = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(`constructor(...${y}) { super(...${y}); ${m}; }`);
      } else this.tokens.appendCode(`constructor() { ${m}; }`);
    }
    for (; !this.tokens.matchesContextIdAndLabel(h.braceR, f); ) if (d < c.length && this.tokens.currentIndex() === c[d].start) {
      let m = !1;
      for (this.tokens.matches1(h.bracketL) ? this.tokens.copyTokenWithPrefix(`${c[d].initializerName}() {this`) : this.tokens.matches1(h.string) || this.tokens.matches1(h.num) ? (this.tokens.copyTokenWithPrefix(`${c[d].initializerName}() {this[`), m = !0) : this.tokens.copyTokenWithPrefix(`${c[d].initializerName}() {this.`); this.tokens.currentIndex() < c[d].end; ) m && this.tokens.currentIndex() === c[d].equalsIndex && this.tokens.appendCode("]"), this.processToken();
      this.tokens.appendCode("}"), d++;
    } else if (g < p.length && this.tokens.currentIndex() >= p[g].start) {
      for (this.tokens.currentIndex() < p[g].end && this.tokens.removeInitialToken(); this.tokens.currentIndex() < p[g].end; ) this.tokens.removeToken();
      g++;
    } else this.tokens.currentIndex() === i ? (this.tokens.copyToken(), x && this.tokens.appendCode(`;${this.makeConstructorInitCode(o, l, s)};`), this.processToken()) : this.processToken();
    this.tokens.copyExpectedToken(h.braceR);
  }
  makeConstructorInitCode(t, s, n) {
    return [...t, ...s.map((i) => `${n}.prototype.${i}.call(this)`)].join(";");
  }
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(h.parenR, h.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let t = this.tokens.currentIndex() + 1;
      for (; this.tokens.tokens[t].isType; ) t++;
      if (this.tokens.matches1AtIndex(t, h.arrow)) {
        for (this.tokens.removeInitialToken(); this.tokens.currentIndex() < t; ) this.tokens.removeToken();
        return this.tokens.replaceTokenTrimmingLeftWhitespace(") =>"), !0;
      }
    }
    return !1;
  }
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(B._async) && !this.tokens.matches1(h._async)) return !1;
    const t = this.tokens.tokenAtRelativeIndex(1);
    if (t.type !== h.lessThan || !t.isType) return !1;
    let s = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[s].isType; ) s++;
    if (this.tokens.matches1AtIndex(s, h.parenL)) {
      for (this.tokens.replaceToken("async ("), this.tokens.removeInitialToken(); this.tokens.currentIndex() < s; ) this.tokens.removeToken();
      return this.tokens.removeToken(), this.processBalancedCode(), this.processToken(), !0;
    }
    return !1;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; ) this.tokens.removeToken();
      return !0;
    }
    return !1;
  }
  shiftMappings(t, s) {
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      i !== void 0 && (t[n] = i + s);
    }
    return t;
  }
}
var Lg, lP = {};
function pP(e, t, s) {
  t++, e.matches1AtIndex(t, h.parenL) || (e.matches1AtIndex(t, h.name) && (s.add(e.identifierNameAtIndex(t)), t++, e.matches1AtIndex(t, h.comma) && t++), e.matches1AtIndex(t, h.star) && (t += 2, s.add(e.identifierNameAtIndex(t)), t++), e.matches1AtIndex(t, h.braceL) && (function(n, i, o) {
    for (; ; ) {
      if (n.matches1AtIndex(i, h.braceR)) return;
      const c = pi(n, i);
      if (i = c.endIndex, c.isType || o.add(c.rightName), n.matches2AtIndex(i, h.comma, h.braceR) || n.matches1AtIndex(i, h.braceR)) return;
      if (!n.matches1AtIndex(i, h.comma)) throw new Error(`Unexpected token: ${JSON.stringify(n.tokens[i])}`);
      i++;
    }
  })(e, ++t, s));
}
function Rg(e, t) {
  (function(s) {
    m_.strictCheck(s);
  })(t);
  try {
    const s = (function(o, c) {
      const l = c.transforms.includes("jsx"), p = c.transforms.includes("typescript"), d = c.transforms.includes("flow"), g = c.disableESTransforms === !0, f = (function(C, A, O, D) {
        if (D && O) throw new Error("Cannot combine flow and typescript plugins.");
        Ww(C, A, O, D);
        const N = J_();
        if (k.error) throw Hw(k.error);
        return N;
      })(o, l, p, d), x = f.tokens, m = f.scopes, y = new mu(o, x), v = new Ko(y), b = new Jn(o, x, d, g, v), E = !!c.enableLegacyTypeScriptModuleInterop;
      let w = null;
      return c.transforms.includes("imports") ? (w = new ys(y, b, E, c, c.transforms.includes("typescript"), !!c.keepUnusedImports, v), w.preprocessTokens(), ig(b, m, w.getGlobalNames()), c.transforms.includes("typescript") && !c.keepUnusedImports && w.pruneTypeOnlyImports()) : c.transforms.includes("typescript") && !c.keepUnusedImports && ig(b, m, (function(C) {
        const A = /* @__PURE__ */ new Set();
        for (let O = 0; O < C.tokens.length; O++) C.matches1AtIndex(O, h._import) && !C.matches3AtIndex(O, h._import, h.name, h.eq) && pP(C, O, A);
        return A;
      })(b)), { tokenProcessor: b, scopes: m, nameManager: y, importProcessor: w, helperManager: v };
    })(e, t), n = new na(s, t.transforms, !!t.enableLegacyBabel5ModuleInterop, t).transform();
    let i = { code: n.code };
    if (t.sourceMapOptions) {
      if (!t.filePath) throw new Error("filePath must be specified when generating a source map.");
      i = { ...i, sourceMap: u_(n, t.filePath, t.sourceMapOptions, e, s.tokenProcessor.tokens) };
    }
    return i;
  } catch (s) {
    throw t.filePath && (s.message = `Error transforming ${t.filePath}: ${s.message}`), s;
  }
}
Lg || (Lg = 1, (function(e) {
  e.__esModule = !0, e.LinesAndColumns = void 0;
  var t = `
`, s = (function() {
    function n(i) {
      this.string = i;
      for (var o = [0], c = 0; c < i.length; ) switch (i[c]) {
        case t:
          c += 1, o.push(c);
          break;
        case "\r":
          i[c += 1] === t && (c += 1), o.push(c);
          break;
        default:
          c++;
      }
      this.offsets = o;
    }
    return n.prototype.locationForIndex = function(i) {
      if (i < 0 || i > this.string.length) return null;
      for (var o = 0, c = this.offsets; c[o + 1] <= i; ) o++;
      return { line: o, column: i - c[o] };
    }, n.prototype.indexForLocation = function(i) {
      var o = i.line, c = i.column;
      return o < 0 || o >= this.offsets.length || c < 0 || c > this.lengthOfLine(o) ? null : this.offsets[o] + c;
    }, n.prototype.lengthOfLine = function(i) {
      var o = this.offsets[i];
      return (i === this.offsets.length - 1 ? this.string.length : this.offsets[i + 1]) - o;
    }, n;
  })();
  e.LinesAndColumns = s, e.default = s;
})(lP));
const jp = "<template></template>", io = async (e) => {
  try {
    const t = await fetch(e);
    return t.ok ? t : new Response(jp);
  } catch {
    return new Response(jp);
  }
}, Mn = (e) => {
  e.forEach((t) => {
    console.log(t);
  });
}, Mg = async (e) => {
  const t = URL.createObjectURL(new Blob([e], { type: "application/javascript" })), s = await import(t);
  return URL.revokeObjectURL(t), s;
}, uP = async (e) => {
  const t = `data-v-${qw(e)}`, { descriptor: s, errors: n } = Hy(await (await io(e)).text() || jp, { filename: e }), i = { cacheHandlers: !0, comments: !1, expressionPlugins: [], hoistStatic: !0, optimizeImports: !0, scopeId: t, sourceMap: !1, ssr: !1 }, o = ["script", "scriptSetup"], c = await Promise.all(o.map(async (f) => {
    const { lang: x = "js", src: m } = s[f] ?? {};
    return /[jt]sx$/.test(x) && i.expressionPlugins?.push("jsx"), /tsx?$/.test(x) && i.expressionPlugins?.push("typescript"), m && await (await io(m)).text();
  })), l = "preserve", p = {}, d = s.styles.some(({ scoped: f }) => f), { expressionPlugins: g } = i;
  if (Mn(n), d && (p.__scopeId = t), s.script || s.scriptSetup) {
    o.forEach((y, v) => {
      const b = s[y];
      b && c[v] !== void 0 && (b.content = c[v]);
    });
    const { bindings: f, content: x, warnings: m = [] } = Nw(s, { id: t });
    Mn(m), f && (i.bindingMetadata = f), Object.assign(p, (await Mg(g.length ? Rg(x, { jsxRuntime: l, transforms: g }).code : x)).default);
  }
  if (s.template) {
    const { code: f, errors: x, tips: m } = Xx({ ast: s.template.ast, compilerOptions: i, filename: s.filename, id: t, scoped: d, slotted: s.slotted, source: s.template.src ? await (await io(s.template.src)).text() : s.template.content, vapor: s.vapor });
    Mn(x), Mn(m), Object.assign(p, await Mg(g.length ? Rg(f, { jsxRuntime: l, transforms: g }).code : f));
  }
  return await Promise.all(s.styles.map((f) => (async (x, { filename: m }, { content: y, module: v, scoped: b = !1, src: E }) => {
    const { code: w, errors: C } = await qE({ filename: m, id: x, modules: !!v, scoped: b, source: E ? await (await io(E)).text() : y });
    Mn(C), Bw(w, b ? { id: x } : void 0);
  })(t, s, f))), p;
};
export {
  uP as default
};
