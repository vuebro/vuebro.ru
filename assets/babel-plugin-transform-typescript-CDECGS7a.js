import{g as re}from"./ajv-keywords-DR2KGciz.js";import{r as ne}from"./babel-helper-plugin-utils-DJaLuuN1.js";import{r as ie}from"./babel-plugin-syntax-typescript-CwbC-KDa.js";import{r as te}from"./babel-helper-create-class-features-plugin-DgPxqHHm.js";import{r as Y}from"./babel-core-Bs32w3bm.js";import{r as se}from"./assert-DVti1A0a.js";import{r as oe}from"./babel-helper-annotate-as-pure-CU01bfHa.js";import{r as ae}from"./babel-helper-skip-transparent-expression-wrappers-BsHlfvbB.js";var V={},W={},k={},z;function Q(){if(z)return k;z=1,Object.defineProperty(k,"__esModule",{value:!0}),k.default=C,k.isSyntacticallyString=y,k.translateEnumValues=s;var l=Y(),j=se(),R=oe(),S=ae();const p=new WeakMap,P=l.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);function C(i,t){const{node:b,parentPath:N}=i;if(b.declare){i.remove();return}const u=b.id.name,{fill:a,data:f,isPure:c}=n(i,t,b.id);switch(N.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":{const m=t.isProgram(i.parent),T=d(N);let e=t.objectExpression([]);(T||m)&&(e=t.logicalExpression("||",t.cloneNode(a.ID),e));const r=P(Object.assign({},a,{INIT:e}));c&&(0,R.default)(r),T?(N.isExportDeclaration()?N:i).replaceWith(t.expressionStatement(t.assignmentExpression("=",t.cloneNode(b.id),r))):i.scope.registerDeclaration(i.replaceWith(t.variableDeclaration(m?"var":"let",[t.variableDeclarator(b.id,r)]))[0]),p.set(i.scope.getBindingIdentifier(u),f);break}default:throw new Error(`Unexpected enum parent '${i.parent.type}`)}function d(m){return m.isExportDeclaration()?d(m.parentPath):m.getData(u)?!0:(m.setData(u,!0),!1)}}const q=l.template.statement(`
  ENUM["NAME"] = VALUE;
`),I=l.template.statement(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`),L=(i,t)=>(i?q:I)(t);function n(i,t,b){const{enumValues:N,data:u,isPure:a}=s(i,t),f=i.get("members"),c=[];for(let d=0;d<f.length;d++){const[m,T]=N[d];c.push(t.inheritsComments(L(y(T),{ENUM:t.cloneNode(b),NAME:m,VALUE:T}),f[d].node))}return{fill:{ID:t.cloneNode(b),ASSIGNMENTS:c},data:u,isPure:a}}function y(i){switch(i=(0,S.skipTransparentExprWrapperNodes)(i),i.type){case"BinaryExpression":{const t=i.left,b=i.right;return i.operator==="+"&&(y(t)||y(b))}case"TemplateLiteral":case"StringLiteral":return!0}return!1}function E(i,t){const{seen:b,path:N,t:u}=t,a=i.node.name;if(b.has(a)){for(let f=i.scope;f!==N.scope;f=f.parent)if(f.hasOwnBinding(a))return;i.replaceWith(u.memberExpression(u.cloneNode(N.node.id),u.cloneNode(i.node))),i.skip()}}const v={ReferencedIdentifier:E};function s(i,t){var b;const N=i.scope.getBindingIdentifier(i.node.id.name),u=(b=p.get(N))!=null?b:new Map;let a=-1,f,c=!0;const m=i.get("members").map(T=>{const e=T.node,r=t.isIdentifier(e.id)?e.id.name:e.id.value,o=T.get("initializer"),M=e.initializer;let x;if(M)a=D(o,u),a!==void 0?(u.set(r,a),j(typeof a=="number"||typeof a=="string"),a===1/0||Number.isNaN(a)?x=t.identifier(String(a)):a===-1/0?x=t.unaryExpression("-",t.identifier("Infinity")):x=t.valueToNode(a)):(c&&(c=o.isPure()),o.isReferencedIdentifier()?E(o,{t,seen:u,path:i}):o.traverse(v,{t,seen:u,path:i}),x=o.node,u.set(r,void 0));else if(typeof a=="number")a+=1,x=t.numericLiteral(a),u.set(r,a);else{if(typeof a=="string")throw i.buildCodeFrameError("Enum member must have initializer.");{const _=t.memberExpression(t.cloneNode(i.node.id),t.stringLiteral(f),!0);x=t.binaryExpression("+",t.numericLiteral(1),_),u.set(r,void 0)}}return f=r,[r,x]});return{isPure:c,data:u,enumValues:m}}function D(i,t,b=new Set){return N(i);function N(c){const d=c.node;switch(d.type){case"MemberExpression":return u(c,t,b);case"StringLiteral":return d.value;case"UnaryExpression":return a(c);case"BinaryExpression":return f(c);case"NumericLiteral":return d.value;case"ParenthesizedExpression":return N(c.get("expression"));case"Identifier":return u(c,t,b);case"TemplateLiteral":{if(d.quasis.length===1)return d.quasis[0].value.cooked;const m=c.get("expressions"),T=d.quasis;let e="";for(let r=0;r<T.length;r++)if(e+=T[r].value.cooked,r+1<T.length){const o=u(m[r],t,b);if(o===void 0)return;e+=o}return e}default:return}}function u(c,d,m){if(c.isMemberExpression()){const T=c.node,e=T.object,r=T.property;if(!l.types.isIdentifier(e)||(T.computed?!l.types.isStringLiteral(r):!l.types.isIdentifier(r)))return;const o=c.scope.getBindingIdentifier(e.name),M=p.get(o);return M?M.get(r.computed?r.value:r.name):void 0}else if(c.isIdentifier()){const T=c.node.name;if(["Infinity","NaN"].includes(T))return Number(T);let e=d==null?void 0:d.get(T);return e!==void 0?e:d!=null&&d.has(T)||m.has(c.node)?void 0:(m.add(c.node),e=D(c.resolve(),d,m),e)}}function a(c){const d=N(c.get("argument"));if(d!==void 0)switch(c.node.operator){case"+":return d;case"-":return-d;case"~":return~d;default:return}}function f(c){const d=N(c.get("left"));if(d===void 0)return;const m=N(c.get("right"));if(m!==void 0)switch(c.node.operator){case"|":return d|m;case"&":return d&m;case">>":return d>>m;case">>>":return d>>>m;case"<<":return d<<m;case"^":return d^m;case"*":return d*m;case"/":return d/m;case"+":return d+m;case"-":return d-m;case"%":return d%m;case"**":return Math.pow(d,m);default:return}}}return k}var K;function H(){if(K)return W;K=1,Object.defineProperty(W,"__esModule",{value:!0}),W.EXPORTED_CONST_ENUMS_IN_NAMESPACE=void 0,W.default=R;var l=Q();const j=W.EXPORTED_CONST_ENUMS_IN_NAMESPACE=new WeakSet;function R(S,p){const{name:P}=S.node.id,C=S.parentPath.isExportNamedDeclaration();let q=C;!q&&p.isProgram(S.parent)&&(q=S.parent.body.some(n=>p.isExportNamedDeclaration(n)&&n.exportKind!=="type"&&!n.source&&n.specifiers.some(y=>p.isExportSpecifier(y)&&y.exportKind!=="type"&&y.local.name===P)));const{enumValues:I}=(0,l.translateEnumValues)(S,p);if(q||j.has(S.node)){const n=p.objectExpression(I.map(([y,E])=>p.objectProperty(p.isValidIdentifier(y)?p.identifier(y):p.stringLiteral(y),E)));S.scope.hasOwnBinding(P)?(C?S.parentPath:S).replaceWith(p.expressionStatement(p.callExpression(p.memberExpression(p.identifier("Object"),p.identifier("assign")),[S.node.id,n]))):(S.replaceWith(p.variableDeclaration("var",[p.variableDeclarator(S.node.id,n)])),S.scope.registerDeclaration(S));return}const L=new Map(I);S.scope.path.traverse({Scope(n){n.scope.hasOwnBinding(P)&&n.skip()},MemberExpression(n){if(!p.isIdentifier(n.node.object,{name:P}))return;let y;if(n.node.computed)if(p.isStringLiteral(n.node.property))y=n.node.property.value;else return;else if(p.isIdentifier(n.node.property))y=n.node.property.name;else return;L.has(y)&&n.replaceWith(p.cloneNode(L.get(y)))}}),S.remove()}return W}var $={},J;function Z(){if(J)return $;J=1,Object.defineProperty($,"__esModule",{value:!0}),$.GLOBAL_TYPES=void 0,$.isGlobalType=j,$.registerGlobalType=R;const l=$.GLOBAL_TYPES=new WeakMap;function j({scope:S},p){return S.hasBinding(p)?!1:l.get(S).has(p)?!0:(console.warn(`The exported identifier "${p}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${p}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`),!1)}function R(S,p){l.get(S).add(p)}return $}var U={},X;function le(){if(X)return U;X=1,Object.defineProperty(U,"__esModule",{value:!0}),U.default=p,U.getFirstIdentifier=S;var l=Y(),j=Z(),R=H();function S(n){return l.types.isIdentifier(n)?n:S(n.left)}function p(n,y){if(n.node.declare||n.node.id.type==="StringLiteral"){n.remove();return}if(!y)throw n.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const E=S(n.node.id).name,v=L(n,n.node);if(v===null){const s=n.findParent(D=>D.isProgram());(0,j.registerGlobalType)(s.scope,E),n.remove()}else n.scope.hasOwnBinding(E)?n.replaceWith(v):n.scope.registerDeclaration(n.replaceWithMultiple([P(E),v])[0])}function P(n){return l.types.variableDeclaration("let",[l.types.variableDeclarator(l.types.identifier(n))])}function C(n,y){return l.types.memberExpression(l.types.identifier(n),l.types.identifier(y))}function q(n,y,E){if(n.kind!=="const")throw E.file.buildCodeFrameError(n,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:v}=n;if(v.every(i=>l.types.isIdentifier(i.id))){for(const i of v)i.init=l.types.assignmentExpression("=",C(y,i.id.name),i.init);return[n]}const s=l.types.getBindingIdentifiers(n),D=[];for(const i in s)D.push(l.types.assignmentExpression("=",C(y,i),l.types.cloneNode(s[i])));return[n,l.types.expressionStatement(l.types.sequenceExpression(D))]}function I(n,y){return n.hub.buildError(y,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function L(n,y,E){const v=new Set,s=y.id,D=n.scope.generateUid(s.name),i=y.body;y.id;let t;t=l.types.isTSModuleBlock(i)?i.body:[l.types.exportNamedDeclaration(i)];let b=!0;for(let u=0;u<t.length;u++){const a=t[u];switch(a.type){case"TSModuleDeclaration":{if(!l.types.isIdentifier(a.id))throw I(n,a);const f=L(n,a);if(f!==null){b=!1;const c=a.id.name;v.has(c)?t[u]=f:(v.add(c),t.splice(u++,1,P(c),f))}continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":b=!1,v.add(a.id.name);continue;case"VariableDeclaration":{b=!1;for(const f in l.types.getBindingIdentifiers(a))v.add(f);continue}default:b&&(b=l.types.isTypeScript(a));continue;case"ExportNamedDeclaration":}if(!("declare"in a.declaration&&a.declaration.declare))switch(a.declaration.type){case"TSEnumDeclaration":R.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(a.declaration);case"FunctionDeclaration":case"ClassDeclaration":{b=!1;const f=a.declaration.id.name;v.add(f),t.splice(u++,1,a.declaration,l.types.expressionStatement(l.types.assignmentExpression("=",C(D,f),l.types.identifier(f))));break}case"VariableDeclaration":{b=!1;const f=q(a.declaration,D,n.hub);t.splice(u,f.length,...f),u+=f.length-1;break}case"TSModuleDeclaration":{if(!l.types.isIdentifier(a.declaration.id))throw I(n,a.declaration);const f=L(n,a.declaration,l.types.identifier(D));if(f!==null){b=!1;const c=a.declaration.id.name;v.has(c)?t[u]=f:(v.add(c),t.splice(u++,1,P(c),f))}else t.splice(u,1),u--}}}if(b)return null;let N=l.types.objectExpression([]);if(E){const u=l.types.memberExpression(E,s);N=l.template.expression.ast`
      ${l.types.cloneNode(u)} ||
        (${l.types.cloneNode(u)} = ${N})
    `}return l.template.statement.ast`
    (function (${l.types.identifier(D)}) {
      ${t}
    })(${s} || (${l.types.cloneNode(s)} = ${N}));
  `}return U}var h;function ce(){if(h)return V;h=1,Object.defineProperty(V,"__esModule",{value:!0}),V.default=void 0;var l=ne(),j=ie(),R=te(),S=H(),p=Q(),P=Z(),C=le();function q(E){switch(E.parent.type){case"TSTypeReference":case"TSExpressionWithTypeArguments":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return!0;case"TSQualifiedName":return E.parentPath.findParent(v=>v.type!=="TSQualifiedName").type!=="TSImportEqualsDeclaration";case"ExportSpecifier":return E.parent.exportKind==="type"||E.parentPath.parent.exportKind==="type";default:return!1}}const I=new WeakMap,L=new WeakSet;function n(E){const v=E.getBindingIdentifiers();for(const s of Object.keys(v)){const D=E.scope.getBinding(s);D&&D.identifier===v[s]&&D.scope.removeBinding(s)}E.opts.noScope=!0,E.remove(),E.opts.noScope=!1}function y(E,v,s,D,i=""){if(v.file.get("@babel/plugin-transform-modules-*")!=="commonjs")throw E.buildCodeFrameError(`\`${s}\` is only supported when compiling modules to CommonJS.
Please consider using \`${D}\`${i}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`)}return V.default=(0,l.declare)((E,v)=>{const{types:s,template:D}=E;E.assertVersion(7);const i=/\*?\s*@jsx((?:Frag)?)\s+(\S+)/,{allowNamespaces:t=!0,jsxPragma:b="React.createElement",jsxPragmaFrag:N="React.Fragment",onlyRemoveTypeImports:u=!1,optimizeConstEnums:a=!1}=v;var{allowDeclareFields:f=!1}=v;const c={field(e){const{node:r}=e;if(!f&&r.declare)throw e.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(r.declare){if(r.value)throw e.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");r.decorators||e.remove()}else if(r.definite){if(r.value)throw e.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");!f&&!r.decorators&&!s.isClassPrivateProperty(r)&&e.remove()}else(r.abstract||!f&&!r.value&&!r.decorators&&!s.isClassPrivateProperty(r))&&e.remove();r.accessibility&&(r.accessibility=null),r.abstract&&(r.abstract=null),r.readonly&&(r.readonly=null),r.optional&&(r.optional=null),r.typeAnnotation&&(r.typeAnnotation=null),r.definite&&(r.definite=null),r.declare&&(r.declare=null),r.override&&(r.override=null)},method({node:e}){e.accessibility&&(e.accessibility=null),e.abstract&&(e.abstract=null),e.optional&&(e.optional=null),e.override&&(e.override=null)},constructor(e,r){e.node.accessibility&&(e.node.accessibility=null);const o=[],{scope:M}=e;for(const x of e.get("params")){const _=x.node;if(_.type==="TSParameterProperty"){const w=_.parameter;if(L.has(w))continue;L.add(w);let B;if(s.isIdentifier(w))B=w;else if(s.isAssignmentPattern(w)&&s.isIdentifier(w.left))B=w.left;else throw x.buildCodeFrameError("Parameter properties can not be destructuring patterns.");o.push(D.statement.ast`
              this.${s.cloneNode(B)} = ${s.cloneNode(B)}
            `),x.replaceWith(x.get("parameter")),M.registerBinding("param",x)}}(0,R.injectInitialization)(r,e,o)}};return{name:"transform-typescript",inherits:j.default,visitor:{Pattern:m,Identifier:m,RestElement:m,Program:{enter(e,r){const{file:o}=r;let M=null,x=null;const _=e.scope;if(P.GLOBAL_TYPES.has(_)||P.GLOBAL_TYPES.set(_,new Set),o.ast.comments)for(const g of o.ast.comments){const A=i.exec(g.value);A&&(A[1]?x=A[2]:M=A[2])}let w=M||b;w&&([w]=w.split("."));let B=x||N;B&&([B]=B.split("."));for(let g of e.get("body")){if(g.isImportDeclaration()){if(I.has(r.file.ast.program)||I.set(r.file.ast.program,!0),g.node.importKind==="type"){for(const O of g.node.specifiers)(0,P.registerGlobalType)(_,O.local.name);g.remove();continue}const A=new Set,G=g.node.specifiers.length,ee=()=>G>0&&G===A.size;for(const O of g.node.specifiers)if(O.type==="ImportSpecifier"&&O.importKind==="type"){(0,P.registerGlobalType)(_,O.local.name);const F=g.scope.getBinding(O.local.name);F&&A.add(F.path)}if(u)I.set(e.node,!1);else{if(g.node.specifiers.length===0){I.set(e.node,!1);continue}for(const O of g.node.specifiers){const F=g.scope.getBinding(O.local.name);F&&!A.has(F.path)&&(T({binding:F,programPath:e,pragmaImportName:w,pragmaFragImportName:B})?A.add(F.path):I.set(e.node,!1))}}if(ee()&&!u)g.remove();else for(const O of A)O.remove();continue}if(!u&&g.isTSImportEqualsDeclaration()){const{id:A}=g.node,G=g.scope.getBinding(A.name);if(G&&!g.node.isExport&&T({binding:G,programPath:e,pragmaImportName:w,pragmaFragImportName:B})){g.remove();continue}}if(g.isExportDeclaration()&&(g=g.get("declaration")),g.isVariableDeclaration({declare:!0}))for(const A of Object.keys(g.getBindingIdentifiers()))(0,P.registerGlobalType)(_,A);else(g.isTSTypeAliasDeclaration()||g.isTSDeclareFunction()&&g.get("id").isIdentifier()||g.isTSInterfaceDeclaration()||g.isClassDeclaration({declare:!0})||g.isTSEnumDeclaration({declare:!0})||g.isTSModuleDeclaration({declare:!0})&&g.get("id").isIdentifier())&&(0,P.registerGlobalType)(_,g.node.id.name)}},exit(e){e.node.sourceType==="module"&&I.get(e.node)&&e.pushContainer("body",s.exportNamedDeclaration())}},ExportNamedDeclaration(e,r){if(I.has(r.file.ast.program)||I.set(r.file.ast.program,!0),e.node.exportKind==="type"){e.remove();return}if(e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every(o=>o.type==="ExportSpecifier"&&o.exportKind==="type")){e.remove();return}if(!e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every(o=>s.isExportSpecifier(o)&&(0,P.isGlobalType)(e,o.local.name))){e.remove();return}if(s.isTSModuleDeclaration(e.node.declaration)){const o=e.node.declaration;if(!s.isStringLiteral(o.id)){const M=(0,C.getFirstIdentifier)(o.id);if(e.scope.hasOwnBinding(M.name))e.replaceWith(o);else{const[x]=e.replaceWithMultiple([s.exportNamedDeclaration(s.variableDeclaration("let",[s.variableDeclarator(s.cloneNode(M))])),o]);e.scope.registerDeclaration(x)}}}I.set(r.file.ast.program,!1)},ExportAllDeclaration(e){e.node.exportKind==="type"&&e.remove()},ExportSpecifier(e){(!e.parent.source&&(0,P.isGlobalType)(e,e.node.local.name)||e.node.exportKind==="type")&&e.remove()},ExportDefaultDeclaration(e,r){if(I.has(r.file.ast.program)||I.set(r.file.ast.program,!0),s.isIdentifier(e.node.declaration)&&(0,P.isGlobalType)(e,e.node.declaration.name)){e.remove();return}I.set(r.file.ast.program,!1)},TSDeclareFunction(e){n(e)},TSDeclareMethod(e){n(e)},VariableDeclaration(e){e.node.declare&&n(e)},VariableDeclarator({node:e}){e.definite&&(e.definite=null)},TSIndexSignature(e){e.remove()},ClassDeclaration(e){const{node:r}=e;r.declare&&n(e)},Class(e){const{node:r}=e;r.typeParameters&&(r.typeParameters=null),r.superTypeParameters&&(r.superTypeParameters=null),r.implements&&(r.implements=null),r.abstract&&(r.abstract=null),e.get("body.body").forEach(o=>{o.isClassMethod()||o.isClassPrivateMethod()?o.node.kind==="constructor"?c.constructor(o,e):c.method(o):(o.isClassProperty()||o.isClassPrivateProperty()||o.isClassAccessorProperty())&&c.field(o)})},Function(e){const{node:r}=e;r.typeParameters&&(r.typeParameters=null),r.returnType&&(r.returnType=null);const o=r.params;o.length>0&&s.isIdentifier(o[0],{name:"this"})&&o.shift()},TSModuleDeclaration(e){(0,C.default)(e,t)},TSInterfaceDeclaration(e){e.remove()},TSTypeAliasDeclaration(e){e.remove()},TSEnumDeclaration(e){a&&e.node.const?(0,S.default)(e,s):(0,p.default)(e,s)},TSImportEqualsDeclaration(e,r){const{id:o,moduleReference:M}=e.node;let x,_;s.isTSExternalModuleReference(M)?(y(e,r,`import ${o.name} = require(...);`,`import ${o.name} from '...';`," alongside Typescript's --allowSyntheticDefaultImports option"),x=s.callExpression(s.identifier("require"),[M.expression]),_="const"):(x=d(M),_="var");const w=s.variableDeclaration(_,[s.variableDeclarator(o,x)]);e.replaceWith(e.node.isExport?s.exportNamedDeclaration(w):w),e.scope.registerDeclaration(e)},TSExportAssignment(e,r){y(e,r,"export = <value>;","export default <value>;"),e.replaceWith(D.statement.ast`module.exports = ${e.node.expression}`)},TSTypeAssertion(e){e.replaceWith(e.node.expression)},[`TSAsExpression${s.tsSatisfiesExpression?"|TSSatisfiesExpression":""}`](e){let{node:r}=e;do r=r.expression;while(s.isTSAsExpression(r)||s.isTSSatisfiesExpression!=null&&s.isTSSatisfiesExpression(r));e.replaceWith(r)},[E.types.tsInstantiationExpression?"TSNonNullExpression|TSInstantiationExpression":"TSNonNullExpression"](e){e.replaceWith(e.node.expression)},CallExpression(e){e.node.typeParameters=null},OptionalCallExpression(e){e.node.typeParameters=null},NewExpression(e){e.node.typeParameters=null},JSXOpeningElement(e){e.node.typeParameters=null},TaggedTemplateExpression(e){e.node.typeParameters=null}}};function d(e){return s.isTSQualifiedName(e)?s.memberExpression(d(e.left),e.right):e}function m({node:e}){e.typeAnnotation&&(e.typeAnnotation=null),s.isIdentifier(e)&&e.optional&&(e.optional=null)}function T({binding:e,programPath:r,pragmaImportName:o,pragmaFragImportName:M}){for(const _ of e.referencePaths)if(!q(_))return!1;if(e.identifier.name!==o&&e.identifier.name!==M)return!0;let x=!1;return r.traverse({"JSXElement|JSXFragment"(_){x=!0,_.stop()}}),!x}}),V}var de=ce();const Se=re(de);export{Se as t};
